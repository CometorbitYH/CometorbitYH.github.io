{"meta":{"title":"MY","subtitle":"IT IS MY LIFE","description":"每一天都在进步...","author":"杨涵","url":"https://cometorbityh.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-24T06:54:16.000Z","updated":"2019-08-24T08:45:36.335Z","comments":true,"path":"categories/index.html","permalink":"https://cometorbityh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-24T06:54:02.000Z","updated":"2019-08-24T08:47:48.572Z","comments":true,"path":"tags/index.html","permalink":"https://cometorbityh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC 学习","slug":"SpringMVC-学习","date":"2019-12-07T03:18:39.000Z","updated":"2019-12-07T14:24:27.326Z","comments":true,"path":"2019/12/07/SpringMVC-学习/","link":"","permalink":"https://cometorbityh.github.io/2019/12/07/SpringMVC-学习/","excerpt":"","text":"SpringMVC的执行流程（⭐）执行流程 步骤简述 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 第一个SpringMVC控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 方法1：实现Controller接口Controller接口介绍简述： Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 注意： 实现Controller接口后，配置文件可以不用配置处理器映射器和处理器适配器，只留下视图解析器，也能运行。 缺点： 一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 代码实现项目结构 1）导入依赖123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）web.xml（前端控制器）1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- 注册前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动级别：1 服务器启动时启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 匹配所有请求 不包括jsp--&gt; &lt;!-- /* 匹配所有请求 包括jsp--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3）springmvc-servlet.xml（springmvc核心配置文件）123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置处理器映射器 --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!-- 配置处理器适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 注册Handler --&gt; &lt;bean id=\"/hello\" class=\"com.yang.controller.HelloController\"/&gt;&lt;/beans&gt; 4）HelloController 控制器12345678910public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"你好 SpringMVC\"); mv.setViewName(\"hello\"); return mv; &#125;&#125; 5）视图页面123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;基于xml配置的SpringMVC&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 6）结果显示 方法2：使用注解Controller注解这四个注解其实都一个意思。 1234@Component： 组件 @Controller： controller@Service： service@Repository： dao 加入Controller注解后，表示这个类被Spring接管， 那么这个类中的所有方法中，如果返回值是String类型的，并且有具体页面可以跳转，那么就会被视图解析器解析，相当于是逻辑视图。 物理视图 = 前缀 + 逻辑视图 + 后缀 RequestMapping注解用于映射url到一个特定的类或方法 如果同时注解在类和方法上，那么在访问url时，应该进行url拼接，才能访问到特定的方法。 如果url带多个参数，则需要在形参前添加一个新注解： 注意：接收的形参尽量不要用基本数据类型，改而用包装类，避免为null，否则容易报异常 Optional int parameter ‘xx’ is present but cannot be translated into a null value 代码实现1）导入依赖123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）web.xml（前端控制器）1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- 注册前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动级别：1 服务器启动时启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 匹配所有请求 不包括jsp--&gt; &lt;!-- /* 匹配所有请求 包括jsp--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3）springmvc-servlet.xml（配置文件）1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 注解扫描：自动扫描包，使指定包下的注解生效，由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.yang.controller\"/&gt; &lt;!--资源过滤：使SpringMVC不处理静态资源 （.css,.js,.html,.mp3,.mp4）--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 支持mvc注解驱动【注入处理器适配器和处理器映射器】 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4）HelloController 控制器1234567891011@Controller //自动装配到springmvc配置文件中public class HelloController &#123; @RequestMapping(\"/hello\") public String hello(Model model)&#123; // 封装数据 model.addAttribute(\"msg\",\"Hello SpringMVC!\"); // 封装视图 return \"hello\"; &#125;&#125; 5）视图页面123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;基于注解&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 6）结果展示 Restful风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 特点：简洁，高效，安全 1234567891011@Controllerpublic class RestFulController &#123; @RequestMapping(\"/test/&#123;a1&#125;/&#123;a2&#125;\") public String item( @PathVariable(\"a1\")Integer a1, @PathVariable(\"a2\")Integer a2, Model model)&#123; model.addAttribute(\"result\",\"输出结果：\" + (a1+a2)); return \"hello\"; &#125;&#125; 使用method属性指定请求类型 转发 + 重定向配置了视图解析器，让我们无需写前后缀，就可以跳转到某个页面。 若没有配置视图解析器，那如何进行跳转？ 无非就是加上前后缀 转发：return &quot;forward:/WEB-INF/jsp/hello.jsp&quot;; 重定向：return &quot;redirect:/index.jsp&quot;; 获取请求参数 数据回显接收一个数据获取情断发送来的请求参数。当请求参数名字与方法中的形参名不一致时，接收不到消息。 使用注解@RequestParam可以指明请求参数的名称。 接收一个对象url传来的参数名需要和对象的属性名一样，否则接收到的值是null。 数据回显 Model – 精简版的ModelMap，推荐使用 ModelMap – 继承自LinkedHashMap类，有LinkedHashMap类的所有方法，还有自身的方法。 乱码问题","categories":[],"tags":[]},{"title":"JAVA 基础合集","slug":"JAVA-基础合集","date":"2019-12-04T07:13:37.000Z","updated":"2019-12-04T07:14:22.249Z","comments":true,"path":"2019/12/04/JAVA-基础合集/","link":"","permalink":"https://cometorbityh.github.io/2019/12/04/JAVA-基础合集/","excerpt":"","text":"数组：冒泡排序 + 选择排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test02 &#123; public static void main(String[] args) &#123; int[] a=&#123;80,3,77,99,66,44,33&#125;; /* 冒泡排序 */ /*for (int i=0;i&lt;a.length;i++)&#123; for(int j=0;j&lt;a.length-1;j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int k:a)&#123; System.out.println(k); &#125;*/ /* 选择排序 */ for (int i=0;i&lt;a.length;i++)&#123; // 假设第一个元素式最小值 int min=i; for (int j=i;j&lt;a.length-1;j++)&#123; // 给min重新赋值 if (a[min]&gt;a[j+1])&#123; min=j+1; &#125; &#125; // 交换位置 if (min!=i)&#123; int temp; temp = a[i]; a[i]=a[min]; a[min]=temp; &#125; &#125; for (int k:a)&#123; System.out.println(k); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Spring 基础","slug":"Spring-基础","date":"2019-12-02T11:24:58.000Z","updated":"2019-12-04T14:17:18.522Z","comments":true,"path":"2019/12/02/Spring-基础/","link":"","permalink":"https://cometorbityh.github.io/2019/12/02/Spring-基础/","excerpt":"","text":"1、简介1.1、历史介绍Spring ## Spring下载地址： https://repo.spring.io/release/org/springframework/spring/ 导包 spring-webmvc包能导入我们需要的关于Spring的很多包， spring-jdbc是整合Spring和Mybatis的包 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.2、优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 轻量级：包很小，导入即用 非入侵式：引入Spring后不该改变原来的代码的任何情况，而且会简化代码 控制反转（IOC）、面向切面编程（AOP）！ 支持事务的处理，对框架整合的支持！（几乎能整合市面上所有的框架） 1.3、组成 ##1.4、扩展 Spring Boot 一个快速开发的脚手架 基于Spring Boot 可以快速的开发单个微服务 ==约定大于配置！== Spring Cloud Spring Cloud 是基于Spring Boot 实现的 现在大多数公司都在使用Spring Boot进行快速开发 学习Spring boot 的前提，需要完全掌握Spring + SpringMVC ，起到承上启下的作用 1.5、弊端Spring发展到现在，已经违背了原来的理念！ 配置十分繁琐，人称 “配置地狱” ！ 2、IOC2.1、IOC 理论推导IOC 是一种思想，不是代码 在我们编写业务时，需要进行以下步骤 1234UserDao 接口UserDaoImpl 实现类UserService 业务接口UserServiceImpl 业务实现类 当有多个Dao层实现类时，Service实现类每次调用就要更换其中调用的Dao层实现类对象，这样维护代码的代价很昂贵。 解决方案：在Service实现类加入Set接口， Service实现类 123456789101112131415public class UserServiceImpl implements UserService &#123; //调用DAO层 private UserDao userDao; // 利用set进行动态实现值得注入 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; Test.java 123456789101112131415public class MyTest &#123; public static void main(String[] args) &#123; // 用户实际调用的是业务层，dao层用户不需要接触！ UserService userService = new UserServiceImpl(); // 使用set注入需要的DAO实现类的对象 ((UserServiceImpl) userService).setUserDao(new UserDaoImpl()); //((UserServiceImpl) userService).setUserDao(new UserDaoMysqlImpl()); //((UserServiceImpl) userService).setUserDao(new UserDaoOracleImpl()); userService.getUser(); &#125;&#125; 之前，程序是由程序员主动创建对象，控制权在程序员手中 现在，使用了set注入，程序不再具有主动性，而是编程被动的接受对象 之前添加Dao实现类，当用到某个Dao时，需要在Service层修改Dao的实现类对象，十分麻烦 现在只需要在Test中，set进去需要的对象，无需修改Service层就可以完成操作。 这种思想，从本质上解决了问题，不再需要程序员去管理对象的创建了（而是用户输入）。系统的耦合性大大降低，可以更见专注于业务的实现上，这是IOC的原型！ 2.2、IOC的本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 2.3、HelloSpring注入pojo类对象创建pojo类 123456789101112131415161718192021222324package com.yang.pojo;public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"Hello,\"+ name ); &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 在配置文件中配置bean 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 使用Spring来创建对象，这些对象在Spring中统称为bean --&gt; &lt;!-- bean:对象 id：bean的唯一标识 ===&gt; 变量名 class：这个bean的类型（全限定类名） ===&gt; new的对象 相当于是：person1 = new Person(); property：属性 name:属性名（对应的bean类中要有set方法，且setXXX的xxx就是name） value:注入属性值（基本数据类型） ref：引用容器中创建好的对象 --&gt; &lt;bean id=\"person1\" class=\"com.yang.pojo.Person\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在测试类中实例化容器 + 使用容器 12345678910111213import com.yang.pojo.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象（拿到Spring的容器） ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 创建bean对象（对象都在容器中管理，我们要使用，直接去里面取出来即可） Person person1 = (Person) context.getBean(\"person1\"); System.out.println(person1.toString()); &#125;&#125; 输出结果 1Person&#123;name=&apos;Spring&apos;&#125; 思考 Hello 对象是谁创建的 ? hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 , 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 . 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想 , 由主动的编程变成被动的接收 . 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 注入Service类对象12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"mysqlImpl\" class=\"com.yang.dao.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"oracleImpl\" class=\"com.yang.dao.UserDaoOracleImpl\"/&gt; &lt;!-- 要修改调用，只需修改ref即可 --&gt; &lt;bean id=\"userServiceImpl\" class=\"com.yang.service.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 创建bean对象（对象都在Spring中管理，我们要使用，直接去里面取出来即可） UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); // 调用bean对象的方法 userServiceImpl.getUser(); &#125;&#125; 总结*OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 * 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! 2.4、IOC创建对象的方式1、使用无参构造方法创建对象，默认！ 2、使用有参构造方法创建对象（3种方式） 通过属性名给参数赋值 通过参数下标给参数赋值 通过参数类型给参数赋值 123456789101112131415161718192021222324252627282930package com.yang.pojo;public class User &#123; private String name; public User() &#123; &#125; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name = \" + name); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 使用Spring来创建对象，这些对象在Spring中统称为bean --&gt; &lt;!-- id：bean的唯一标识 ===&gt; 变量名 class：这个bean的类型（全限定类名） ===&gt; new的对象 相当于是：bean person1 = new Person(); --&gt; &lt;!-- 使用无参构造方法创建对象 --&gt; &lt;bean id=\"person1\" class=\"com.yang.pojo.Person\"&gt; &lt;!-- 使用Set方法注入属性 --&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt; &lt;!-- 使用有参构造方法创建对象 --&gt; &lt;!-- 方式1：通过下标给各参数赋值 --&gt; &lt;bean id=\"user01\" class=\"com.yang.pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"赵四\"/&gt; &lt;/bean&gt; &lt;!-- 方式2：通过参数类型给各参数赋值 --&gt; &lt;bean id=\"user02\" class=\"com.yang.pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"赵四\"/&gt; &lt;/bean&gt; &lt;!-- 方式3：直接通过参数名赋值--&gt; &lt;bean id=\"user03\" class=\"com.yang.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"赵四\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910111213141516171819import com.yang.pojo.Person;import com.yang.pojo.User;import com.yang.service.UserServiceImpl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 取出对象（对象都在Spring中管理，我们要使用，直接去里面取出来即可） User user01 = (User) context.getBean(\"user01\"); user01.show(); // name = 赵四 User user02 = (User) context.getBean(\"user02\"); user02.show(); // name = 赵四 User user03 = (User) context.getBean(\"user03\"); user03.show(); // name = 赵四 &#125;&#125; 注意 在获取到IOC容器对象时，Spring 就已经创建好了对象（对象已经注册了，并且只有一个实例），因此直接获取即可。 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！ 2.5、Spring配置2.6、DI 依赖注入2.6.1、依赖注入 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 2.6.2、构造器注入见2.4 2.6.3、Set方式注入【环境搭建】 1、复杂类型 1234567891011121314151617181920package com.yang.demo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.*;public class Student &#123; private String name; private String wife; private Address address; private String[] subject; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; game; private Properties info; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getSubject() &#123; return subject; &#125; public void setSubject(String[] subject) &#123; this.subject = subject; &#125; public List&lt;String&gt; getHobbys() &#123; return hobbys; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGame() &#123; return game; &#125; public void setGame(Set&lt;String&gt; game) &#123; this.game = game; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", wife='\" + wife + '\\'' + \", address=\" + address + \", subject=\" + Arrays.toString(subject) + \", hobbys=\" + hobbys + \", card=\" + card + \", game=\" + game + \", info=\" + info + '&#125;'; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.yang.demo.Address\"&gt; &lt;property name=\"address\" value=\"隔壁屋\"/&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.yang.demo.Student\"&gt; &lt;!-- 1、基本数据类型注入 --&gt; &lt;property name=\"name\" value=\"老王\"/&gt; &lt;!-- 2、null注入--&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; &lt;!-- 3、bean注入，ref --&gt; &lt;property name=\"address\" ref=\"address\"/&gt; &lt;!-- 4、数组注入 --&gt; &lt;property name=\"subject\"&gt; &lt;array&gt; &lt;value&gt;语文&lt;/value&gt; &lt;value&gt;数学&lt;/value&gt; &lt;value&gt;英语&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 5、List 注入 --&gt; &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;RAP&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 6、Map注入 --&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"350322XXXXXXXX48XX\"/&gt; &lt;entry key=\"银行卡\" value=\"62170018***********\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 7. Set注入 --&gt; &lt;property name=\"game\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;DNF&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 8、Properties注入 --&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;1610****&lt;/prop&gt; &lt;prop key=\"姓名\"&gt;老王&lt;/prop&gt; &lt;prop key=\"年龄\"&gt;18&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415import com.yang.demo.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //Student student = (Student) context.getBean(\"student\"); Student student = context.getBean(\"student\",Student.class); System.out.println(student.toString()); &#125;&#125; 12345678910Student&#123; name='老王', wife='null', address=Address&#123;address='隔壁屋'&#125;, subject=[语文, 数学, 英语], hobbys=[唱, 跳, RAP, 篮球], card=&#123;身份证=350322XXXXXXXX48XX, 银行卡=62170018***********&#125;, game=[LOL, DNF, COC], info=&#123;学号=1610****, 姓名=老王, 年龄=18&#125;&#125; 2.6.3、c和p命名空间注入p命名空间注入，可以直接注入属性的值（property） c命名空间注入，通过构造器注入（construct-args） 注意：p命名和c命名无法直接使用，需要在bean.xml中添加约束 123&gt; xmlns:p=\"http://www.springframework.org/schema/p\"&gt; xmlns:c=\"http://www.springframework.org/schema/c\"&gt; 使用： 123456789101112131415package com.yang.demo;public class Worker &#123; private String name; private Integer age; public Worker() &#123; &#125; public Worker(String name, Integer age) &#123; this.name = name; this.age = age; &#125; //getter,setter,toString&#125; 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"worker01\" class=\"com.yang.demo.Worker\" p:name=\"老王\" p:age=\"18\"/&gt; &lt;bean id=\"worker02\" class=\"com.yang.demo.Worker\" c:name=\"老张\" c:age=\"28\"/&gt;&lt;/beans&gt; 测试 1234567891011121314151617import com.yang.demo.Worker;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Worker worker01 = context.getBean(\"worker01\", Worker.class); System.out.println(worker01.toString()); Worker worker02 = context.getBean(\"worker02\", Worker.class); System.out.println(worker02.toString()); &#125;&#125; 输出结果 12Worker&#123;name=&apos;老王&apos;, age=18&#125;Worker&#123;name=&apos;老张&apos;, age=28&#125; 2.7、bean的作用域scope属性， singleton（默认）：单例模式，一个Spring容器只有一个该对象 prototype：原型，一个Spring容器可以有多个该对象，每次从容器中get时，都会产生一个新对象 request、session、application：只能在web开发中使用 使用 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"worker01\" class=\"com.yang.demo.Worker\" p:name=\"老王\" p:age=\"18\" scope=\"singleton\"/&gt; &lt;bean id=\"worker02\" class=\"com.yang.demo.Worker\" c:name=\"老张\" c:age=\"28\" scope=\"prototype\"/&gt;&lt;/beans&gt; 测试 12345678910111213141516171819202122import com.yang.demo.Student;import com.yang.demo.Worker;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Worker w11 = context.getBean(\"worker01\", Worker.class); Worker w12 = context.getBean(\"worker01\", Worker.class); System.out.println(w11==w12); //true Worker w21 = context.getBean(\"worker02\", Worker.class); Worker w22 = context.getBean(\"worker02\", Worker.class); System.out.println(w21==w22); //false &#125;&#125; 2.8、bean的自动装配自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中寻找，并自动给bean装配属性 在Spring中有3种装配的方式 在xml中显式的配置（之前的那些都是显式的） 在Java中显式的配置 隐式的自动装配bean 2.8.1、byName和byType的自动装配autowire属性 byName ：自动在上下文中查找，和自己对象的set方法后面的值对应的bean id byType自动在上下文中查找，和自己对象的的属性的类型相同的bean（id可以与set方法的不同） byName ：需要保证所有bean id唯一，该bean id需要和自动注入·属性的set方法的后面部分一致 byType ：需要保证所有bean id唯一，该bean class需要和自动注入的属性的类型一致 2.8.2、注解实现自动配置3、代理模式为什么学习代理模式？ 代理模式是AOP的底层（Spring AOP，SpringMVC） 3.1、静态代理角色分析 抽象角色：一般使用接口或抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色。代理真实角色后，一般会做一些负数动作 客户：访问代理对象的人 代码步骤 1、接口 1234// 租房public interface Rent &#123; public void rent();&#125; 2、真实角色 1234567// 房东public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println(\"房东要出租房子！\"); &#125;&#125; 3、代理角色 1234567891011121314151617181920212223242526272829public class Proxy implements Rent&#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; @Override public void rent() &#123; seeHouse(); host.rent(); heTong(); fare(); &#125; public void seeHouse()&#123; System.out.println(\"中介带你看房!\"); &#125; public void heTong()&#123; System.out.println(\"中介带你签署合同!\"); &#125; public void fare()&#123; System.out.println(\"收钱!（中介费）\"); &#125;&#125; 4、客户端访问代理角色 12345678910public class Client &#123; public static void main(String[] args) &#123; // 房东要出租房子 Host host = new Host(); //代理帮房东出租房子，但是代理一帮要有一些附属操作 Proxy proxy = new Proxy(host); //客户无需面对房东，直接找中介租房即可 proxy.rent(); &#125;&#125; 5、输出结果 1234中介带你看房!房东要出租房子！中介带你签署合同!收钱!（中介费） 代理模式的好处 可以是真实角色的操作更加纯粹！无需去关注一些公共的任务 公共任务交给代理角色！实现了业务的分工 公共任务发生扩展时，方便几种管理 缺点：一个真实角色就会产生一个代理角色：代码量会翻倍，开发效率会变低 3.2、静态代理（加深理解）在不改变原有业务的情况下，想到要扩展业务，只需加上一个代理类，调用要扩展业务的类作为对象即可。这就是代理模式的优势 改动公司原有的代码，是大忌！ 横向开发 就是AOP 代码步骤 接口 1234567public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 真实角色（实现类） 123456789101112131415161718192021222324public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(\"添加了一个用户！\"); &#125; @Override public void delete() &#123; System.out.println(\"删除了一个用户！\"); &#125; @Override public void update() &#123; System.out.println(\"修改了一个用户！\"); &#125; @Override public void query() &#123; System.out.println(\"查询了一个用户！\"); &#125;&#125; 代理角色 12345678910111213141516171819202122232425262728293031323334353637public class UserServiceProxy implements UserService&#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; @Override public void add() &#123; log(\"add\"); userService.add(); &#125; @Override public void delete() &#123; log(\"delete\"); userService.delete(); &#125; @Override public void update() &#123; log(\"update\"); userService.update(); &#125; @Override public void query() &#123; log(\"query\"); userService.query(); &#125; // 加入新业务 public void log(String msg)&#123; System.out.println(\"【debug】使用了\"+msg+\"方法\"); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; UserServiceImpl userService = new UserServiceImpl(); // userService.add(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); &#125;&#125; 输出结果 12【debug】使用了add方法添加了一个用户！ 3.2、静态代理模式扩展性3.3、动态代理3.3.1、什么是动态代理动态代理能解决静态代理的缺点（只能代理固定的真实角色） 动态代理和静态代理的角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 3.3.2、动态代理的分类动态代理分为两大类：基于接口的动态代理 、基于类的动态代理 基于接口 —- JDK动态代理（我们在这里使用） 基于类 —- cglib java字节码实现 —- javassist 需要了解2个类：Proxy（代理）、invocationHandler（调用处理程序） 3.3.3、基于接口的动态代理（⭐）接口 1234// 租房public interface Rent &#123; public void rent();&#125; 真实角色 1234567// 房东public class Host implements Rent &#123; @Override public void rent() &#123; System.out.println(\"房东要出租房子！\"); &#125;&#125; 代理角色 123456789101112131415161718192021222324252627282930313233import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//动态代理的本质就是使用反射public class ProxyInvocationHandler implements InvocationHandler &#123; // 被代理的接口 private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; // 生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; // 处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 动态代理的本质就是使用反射 Object result = method.invoke(rent, args); return result; &#125;&#125; 客户端访问代理角色 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; // 真实角色：房东要出租房子 Host host = new Host(); // 代理角色 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //设置要代理的对象 pih.setRent(host); // 动态生成代理类 Rent proxy = (Rent) pih.getProxy(); proxy.rent(); &#125;&#125; 输出结果 1房东要出租房子！ 这个动态代理类代理的是Rent接口，可以代理实现Rent接口的所有实现类 接下来我们做一个通用的动态代理类 代理角色 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//动态代理的本质就是使用反射public class ProxyInvocationHandler implements InvocationHandler &#123; // 被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; // 动态生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // 处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // method.getName()就是指 “动态代理对象调用的方法名” log(method.getName()); // 动态代理的本质就是使用反射 Object result = method.invoke(target, args); return result; &#125; public void log(String msg)&#123; System.out.println(\"【debug】使用了\"+msg+\"方法\"); &#125;&#125; 客户端访问代理对象 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; // 真实角色： UserServiceImpl userService = new UserServiceImpl(); // 代理角色：还不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //设置要代理的对象 pih.setTarget(userService); // 动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.add(); proxy.delete(); &#125;&#125; 输出结果 1234【debug】使用了add方法添加了一个用户！【debug】使用了delete方法删除了一个用户！ 3.3. 4、动态代理的好处 可以是真实角色的操作更加纯粹！无需去关注一些公共的任务 公共任务交给代理角色！实现了业务的分工 公共任务发生扩展时，方便几种管理 一个动态代理类代理的是一个接口。一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 4、AOP 添加日志在各个方法前后，但是不得改变原有逻辑 12345678&lt;!-- 添加织入的包 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.1、方式一：Spring API接口（主要是API接口实现）接口 + 实现类 1234567891011121314151617181920212223242526272829303132333435363738package com.yang.service;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125;package com.yang.service;public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(\"添加了一个用户！\"); &#125; @Override public void delete() &#123; System.out.println(\"删除了一个用户！\"); &#125; @Override public void update() &#123; System.out.println(\"修改了一个用户！\"); &#125; @Override public void query() &#123; System.out.println(\"查询了一个用户！\"); &#125;&#125; 日志类 12345678910111213141516171819202122232425262728293031323334package com.yang.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;/* 前置日志类 */public class Log implements MethodBeforeAdvice &#123; // method:要执行的目标对象的方法 // args：参数 // target：目标对象 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + \"的\" +method.getName() + \"方法被执行了\"); &#125;&#125;package com.yang.log;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;/* 后置日志类 */public class AfterLog implements AfterReturningAdvice &#123; // returnValue：返回值 @Override public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(method.getName() + \"方法的执行结果：\" + returnValue); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.yang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.yang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.yang.log.AfterLog\"/&gt; &lt;!--方式1：使用原生Spring API接口--&gt; &lt;!-- 配置AOP（需要导入aop的约束）--&gt; &lt;aop:config&gt; &lt;!--切入点：expression 表达式，execution(要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.yang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 1234567891011121314import com.yang.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 注意：动态代理代理的式接口。不是实现类 UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); &#125;&#125; 输出结果 123com.yang.service.UserServiceImpl的add方法被执行了添加了一个用户！add方法的执行结果：null 关于execution表达式： https://blog.csdn.net/corbin_zhang/article/details/80576809 4.2、方式二：自定义类实现AOP（主要是切面定义）自定义切面类 1234567891011package com.yang.diy;public class DiyPointcut &#123; public void before()&#123; System.out.println(\"==== 方法执行前 ====\"); &#125; public void after()&#123; System.out.println(\"==== 方法执行后 ====\"); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.yang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.yang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.yang.log.AfterLog\"/&gt;&lt;!-- &amp;lt;!&amp;ndash;方式1：使用原生Spring API接口 织入&amp;ndash;&amp;gt; &amp;lt;!&amp;ndash; 配置AOP（需要导入aop的约束）&amp;ndash;&amp;gt; &lt;aop:config&gt; &amp;lt;!&amp;ndash;切入点：expression 表达式，execution(要执行的位置）&amp;ndash;&amp;gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.yang.service.UserServiceImpl.*(..))\"/&gt; &amp;lt;!&amp;ndash;执行环绕增加&amp;ndash;&amp;gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;--&gt; &lt;!-- 方式2：使用自定义类织入 --&gt; &lt;bean id=\"diy\" class=\"com.yang.diy.DiyPointcut\"/&gt; &lt;aop:config&gt; &lt;!--切面--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点 --&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.yang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 1234567891011121314import com.yang.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 注意：动态代理代理的式接口。不是实现类 UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); &#125;&#125; 输出结果 123==== 方法执行前 ====添加了一个用户！==== 方法执行后 ==== 4.3、方式三：使用注解实现AOP123456789101112131415161718192021222324252627282930313233343536package com.yang.diy;// 使用注解实现AOPimport org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.yang.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"---- 方法执行前 ----\"); &#125; @After(\"execution(* com.yang.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"---- 方法执行后 ----\"); &#125; // 在环绕增强中，可以给定一个参数，代表我们要获取处理切入的点 @Around(\"execution(* com.yang.service.UserServiceImpl.*(..))\") //ProceedingJoinPoint：连接点，可以获取切入点的信息 public void round(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(\"环绕前\"); Signature signature = jp.getSignature(); //获得签名 System.out.println(\"signature:\" +signature); Object proceed = jp.proceed(); //执行方法 System.out.println(proceed); System.out.println(\"环绕后\"); &#125;&#125; 配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.yang.service.UserServiceImpl\"/&gt; &lt;!-- 方式3--&gt; &lt;bean id=\"annotationPointCut\" class=\"com.yang.diy.AnnotationPointCut\"/&gt; &lt;!-- 开启注解支持 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试 1234567891011121314import com.yang.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 注意：动态代理代理的式接口。不是实现类 UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); &#125;&#125; 输出结果 1234567环绕前signature:void com.yang.service.UserService.add()---- 方法执行前 ----添加了一个用户！null环绕后---- 方法执行后 ---- 5、Spring 整合 Mybatis5.1、基本配置步骤 导入相关jar包 junit mybatis mysql数据库 spring-webmvc spring-jdbc aop织入 mybatis-spring 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring操作数据库，还需要一个spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合包 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- maven静态资源过滤问题 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 5.2、回忆Mybatis的流程 5.3、整合步骤 applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource：使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 这里使用Spring提供的jdbc --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--绑定mybatis的配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/yang/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionTemplate：就是我们使用的sqlSession--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!-- 使用构造器注入SqlSessionFactory--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"userMapper\" class=\"com.yang.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--别名--&gt; &lt;typeAliases&gt; &lt;package name=\"com.yang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--设置--&gt;&lt;/configuration&gt; 接口实现类 123456789101112131415public class UserMapperImpl implements UserMapper &#123; // 我们所有的操作。都使用sqlSession来执行 // 现在使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125;","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://cometorbityh.github.io/categories/SSM框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SSM框架","slug":"SSM框架","permalink":"https://cometorbityh.github.io/tags/SSM框架/"}]},{"title":"JAVA 面向对象3大特性 总结","slug":"JAVA-面向对象3大特性-总结","date":"2019-12-01T05:43:37.000Z","updated":"2019-12-01T16:36:07.729Z","comments":true,"path":"2019/12/01/JAVA-面向对象3大特性-总结/","link":"","permalink":"https://cometorbityh.github.io/2019/12/01/JAVA-面向对象3大特性-总结/","excerpt":"","text":"面向对象面向对象的三大特征：封装性，继承性，多态性 封装继承什么是继承？ 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力 继承是多态的前提，没有继承就没有多态 继承主要解决的问题：共性抽取 继承的3大特点单继承：Java语言是单继承的，一个类的直接父类只能有一个 多级继承：Java语言可以多级继承，子类有一个父类，父类也可以有父类 多子类：一个子类只能有一个父类，但一个父类可以有多个子类 继承的格式关键字：extends 123456789//父类格式public class 父类名称&#123; //... ...&#125;//子类格式public class 子类名称 extends 父类名称&#123; //... ...&#125; 继承中的子类在继承关系中，“子类就是一个父类”，子类可以被当成父类来看待。 例如：父类员工，子类讲师，那么“讲师就是一个员工”，二者之间关系：is-a 子类对象可以访问父类的方法，但父类对象无法访问子类的方法 子类的特征 子类拥有父类*非 private *的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，但是可以多重继承， 单继承就是一个子类只能继承一个父类， 多重继承就是，例如A类继承B类，B类继承C类， 所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 重写（override）重写：也称覆盖，是子类重写父类的方法，方法名和参数列表都一样，发生在继承关系中 重写的特点： 子类和父类的方法名和参数列表都一样 子类方法的返回值范围必须小于等于父类方法的返回值范围 子类方法的权限修饰符必须大于等于父类方法的权限修饰符（public &gt; protected &gt; default &gt; private） 备注：default不是关键字，而是什么都不写，留空 重载（overload）：重载构造方法，方法名一样但参数列表不一样，发生在构造方法中 继承中构造方法的关系子类每一个构造方法的第一条语句默认都是super()，即子类中所有的构造方法默认都会先执行父类的无参构造方法，而且一个子类构造不能调用多个父类构造（super只能有一个，在第一句） 也可以通过super关键字，实现子类的构造调用父类的重载构造，注意非子类构造方法，无法通过super调用父类构造方法 继承中成员变量的访问在父子类的继承关系当中，若成员变量重名，创建子类对象时，访问有2中方式 子类对象 . 成员变量 – &gt; 子类的成员变量 子类对象 . 父类的成员方法 —&gt;父类的成员方法 1访问成员变量的原则：就近原则 访问局部变量：直接写成员变量 访问本类的成员变量：this.成员变量 访问父类的成员变量：super.成员变量 this与supersuper关键字的三种用法（访问父类内容） 在子类的成员方法中，访问父类的成员变量 在子类的成员方法中，访问父类的成员方法 在子类的构造方法中，访问父类的构造方法 this关键字的三种方法（访问本类内容） 在本类的成员方法中，访问本类的成员变量 在本类的成员方法中，访问本类的另一成员方法 在本类的构造方法中，访问本类的另一构造方法（注意this(...)必须是构造方法的第一句，那么this与super就不能共存） 抽象抽象方法：加上abstract关键字，没有方法体（去掉大括号，直接分号结束） 抽象类：抽象方法所在的类，必须是抽象类，在class前加上abstract即可 抽象类可以有抽象方法，也可以有普通方法，可以有构造方法 抽象类和抽象方法的使用 抽象类【无法直接创建】抽象对象 必须使用子类【继承】抽象类 抽象类的子类必须【覆盖】抽象父类的【所有抽象方法】 创建子类对象进行使用 注意事项 抽象类不能创建对象，只能创建其非抽象类子类的对象 抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中不一定包含抽象方法，但是包含抽象方法的类一定是抽象类 抽象类的子类，一定要覆盖抽象类中的所有抽象方法，否则会编译报错，除非子类也是抽象类 接口（Interface）生活中，USB接口随处可见。电脑的，机箱的，打印机的….，他们的接口都是一样的。是每一个USB厂商都默认遵守的规范。因此我们可以说： 接口是一种通用的规范标准 接口是多个类的公共规范 接口是一种引用数据类型，其中最重要的内容是，抽象方法 总结 接口 接口没有静态代码块、构造方法 接口有 JDK7：常量、抽象方法 JDK8：默认方法、静态方法 JDK9：私有方法 实现类与接口 一个类只能继承一个父类，但是可以实现多个接口 如果实现类实现的多个接口中，存在重复的抽象方法（A接口和B接口都有），那么只需要重写一次即可 如果实现类实现的多个接口中，存在重复的默认方法（A接口和B接口都有），那么实现类一定要对冲突的默认方法重写 如果实现类没有重写所有接口的所有方法，那么就必须是一个抽象类 如果一个类，直接父类的方法和接口的默认方法产生冲突，优先用父类的方法 类与类之间是单继承的，类与接口之间是多实现的，接口与接口之间是多继承的 接口的格式123public interface 接口名称&#123; //接口内容&#125; 注意：接口编译生成的字节码文件依然是：.java--&gt; .class，而不是.interface 接口中的内容Java 7 的接口内容：常量，抽象方法 Java 8 的接口内容：常量，抽象方法，默认方法，静态方法 Java 9 的接口内容：常量，抽象方法，默认方法，静态方法，私有方法 抽象方法（⭐）抽象方法格式：public abstract 返回值类型 方法名（参数列表）; 接口的抽象方法，修饰父必须是2个固定关键字：public abstract，可省略 实现类接口无法直接使用，需要创建“实现类”来“实现”接口 实现类格式：public class 实现类名称 implements 接口名称{ //.... } 接口的实现类必须覆盖（实现）接口中所有的抽象方法，再创建实现类对象来使用 如果实现类没有覆盖所有的抽象方法，那么这个实现类必须是抽象类 默认方法默认方法：Java 8 开始，接口允许定义默认方法 格式：public default 返回值类型 方法名称(参数列表){ 方法体 } 应用：解决接口升级的问题 假设一个接口有3个抽象方法，有3个实现类，这3个实现类都重写了这3个方法。 现在有新的抽象方法加入，也就是说，这个接口现在有 4个抽象方法，因此3个实现类都必须重写这个新的抽象方法（否则会报错），这样带来的结果就是很麻烦，要一个一个去重写。 此时我们可以将这个抽象方法换成默认方法，默认方法的特点就是：实现类不用去重写，这样就避免了接口升级时，实现类不得不重写抽象方法的问题了。 静态方法静态方法：Java 8 开始，接口允许定义静态方法 格式：public static 返回值类型 方法名称(参数列表){ 方法体 } 无法通过接口实现类对象去调用接口当中的静态方法 通过接口名称直接调用接口的静态方法 私有方法私有方法：Java 9 开始，接口允许定义私有方法。 普通私有方法：解决多个默认方法之间重复代码问题 格式：private 返回值类型 方法名称(参数列表){ 方法体 } 静态私有方法：解决多个静态方法之间重复代码问题 格式：private static 返回值类型 方法名称(参数列表){ 方法体 } 假设有1个接口，有2个默认方法，其中出现了代码重复，因此我们在用一个默认方法将这些重复代码提取出来。但是这样，问题来了，默认方法是可以被实现类访问到的，我们不应该把这个方法面向实现类，而是应该私有化。 Java 9 开始，接口允许定义私有方法。 （由于我使用的JDK1.8 ，因此无法实际操作，这里只是做个演示） 常量常量格式：public static final 数据类型 常量名称=数据值; 接口的常量，修饰符必须是3个固定关键字：public static final，可省略， 注意： 接口中的常量，必须进行赋值，一旦赋值，就不可以修改了 常量名一般大写，用下划线进行分隔 多态什么是多态？ 多态指的是同一个方法调用，由于对象不同可能会有不同的行为。 多态的要点： 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法 格式父类名称 对象名 = new 子类名称（）; 接口名称 对象名 = new 实现类名称（）; 多态的作用 消除类型之间的耦合关系 如何理解？ 没有多态，那么等号左边是啥右边就得是啥，这就叫耦合，有了多态，左边是父类（或者接口），右边是子类（或实现类），我只管调用接口里面的方法就是了，至于你实现类怎么去实现，那是你的事，你要修改一下实现，你只管去把实现类换掉，我这边一行代码都不用变，这就解耦了 多态的好处1)可替换性2)可扩充性3)接口性4)灵活性 访问成员变量的方式直接通过对象名称访问成员变量：多态与属性无关，父类引用无法访问子类的属性，只能访问父类的属性 间接通过成员方法访问成员变量：多态与方法有关，父类引用可以访问子类重写的方法 访问子类成员方法的规则使用多态方式调用方法：首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 对象的向上转型其实就是多态写法 父类名称 对象名 = new 子类名称（）; 含义：右侧创建一个子类对象，把它当成父类来看待 例如：Animal animal = new Cat(); 创建了一只猫，把它当成动物看待 注意：向上转型一定是安全的，从小范围转到大范围 eg：double num=100； //正确，int —&gt; double，自动类型转换 弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的方法 解决方案：用对象的向下转型还原 对象的向下转型 + instanceof其实是一个还原动作 子类名称 对象名= (子类名称)父类对象; 含义：将父类对象还原成为本来的子类对象 例如： Animal animal = new Cat(); //猫 向上转型为 动物 Cat cat = (Cat) animal; // 本来是猫，被当成动物，现在又还原成猫了 如果一只猫向上转型为动物，而动物又向下转型为狗，那在运行时就会报异常ClassCastException，此时该怎么解决？ 解决：使用instanceof关键字判断 A instanceof B:判断A是否是B类的实例 final关键字 对于类和方法，abstract和final关键字不能同时使用，因为矛盾 final修饰一个类当final修饰一个类时，这个类就不能有子类（太监类、最终类） 一个类如果是最终类，那么其中的所有成员方法都无法进行覆盖重写（没有子类） 在JDK中，被设计为 final 类的有 String、System 等 final修饰一个方法当final修饰一个方法时，这个方法就是最终方法，也就是不能被覆盖重写 final修饰一个局部变量当final修饰一个局部变量时，这个变量就不能更改，一次赋值终身不变 final修饰一个成员变量当final修饰一个局部变量时，这个变量就不能更改 由于成员变量有默认值，所以用了final必须手动赋值 当用final来修饰对象时，不能改变对象的引用，但是可以修改对象的属性值。 权限修饰符 public protected （default） private 同一个类 YES YES YES YES 同一个包 YES YES YES NO 不同包子类 YES YES NO NO 不同包非子类 YES NO NO NO 内部类内部类的权限修饰符规则外部类：public / （default） 成员内部类：public / protected / （default）/private 局部内部类：什么都不能写 成员内部类定义在类内部的类，就叫成员内部类 定义的格式123456修饰符 class 外部类名称&#123; 修饰符 class 成员内部类名称&#123; // ... &#125; // ...&#125; 注意：内用外，随意访问，外用内，需要内部类对象 创建内部类对象 间接方法：使用外部类的成员方法调用内部类 直接方法：外部类名称.内部类名称 内部类对象名 = new 外部类名称().new 内部类名称 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Body &#123; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody()&#123; System.out.println(\"外部类的方法...\"); //创建内部类对象，调用内部类方法 new Heart().beat(); &#125; //内部类 public class Heart&#123; public void beat()&#123; // 内部类访问外部类成员变量 System.out.println(\"心脏跳动...\" + name); &#125; &#125;&#125;public class BodyDemo &#123; public static void main(String[] args) &#123; Body body = new Body(); // 方法一：间接调用 // 使用外部类·成员方法调用内部类 body.methodBody(); System.out.println(\"===========================\"); //方法二：直接调用 Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125;---------- 控制台输出 -------------心脏跳动...null===========================心脏跳动...null 重名变量的调用内部类调用： 内部类的成员方法的局部变量：局部变量名 内部类的成员变量：this . 成员变量名 外部类的成员变量：外部类名称. this. 外部类成员变量名 12345678910111213public class Outer &#123; int num = 1; public class Inner&#123; int num = 2; public void method()&#123; int num = 3; System.out.println(num); // 1 System.out.println(this.num); // 2 System.out.println(Outer.this.num); // 3 &#125; &#125;&#125; 局部内部类（匿名内部类）定义在一个方法内部的类，叫做局部内部类 局部：当前所属方法才能用它，方法之外的都无法使用 格式 12345678修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称（参数列表）&#123; class 局部内部类名称&#123; // ... &#125; &#125; // ...&#125; 1234567891011121314151617181920212223public class Outer &#123; public void methodOuter()&#123; class Inner&#123; int num = 2; public void methodInner()&#123; System.out.println(num); &#125; &#125; // 创建局部内部类对象，调用其方法 Inner inner = new Inner(); inner.methodInner(); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; Outer outer = new Outer(); outer.methodOuter(); &#125;&#125; ##匿名内部类（⭐） 如果接口的实现类（或父类的子类）只需要用一次 这种情况下，可以省略实现类（或子类）的定义，二改为使用【匿名内部类】 定义的格式123接口名称 对象名 = new 接口名称()&#123; // 覆盖重写接口的所有抽象方法&#125; 注意：匿名内部类在【创建对象】时，只能使用一次。","categories":[],"tags":[]},{"title":"Mybatis 基础","slug":"Mybatis-基础","date":"2019-11-30T06:42:09.000Z","updated":"2019-11-30T16:43:54.626Z","comments":true,"path":"2019/11/30/Mybatis-基础/","link":"","permalink":"https://cometorbityh.github.io/2019/11/30/Mybatis-基础/","excerpt":"","text":"概念介绍 第一条语句(1) 新建数据库、Javabean类 (2) 编写全局配置文件mybatis-config.xml 数据源 注册sql映射文件 (3) 编写sql映射文件，配置了每一个SQL。以及sql的封装规则等 (4) 将sql映射文件注册在全局配置文件中（Mapper文件要和Java代码相互联系，因此需要配置到全局配置文件中） (5) 编写测试类 根据全局配置文件得到SqlSessionFactory 使用SqlSessionFactory得到sqlSession对象， 使用sqlSession对象来执行增删改查，一个sqlSession就是代表和数据库的一次会话，用完关闭 使用sql的唯一标识来告诉Mybatis执行那个sql，sql都是保存在sql映射文件中 新建一张数据表，并添加数据 123456create table tb1_employee( id INT(11) PRIMARY KEY AUTO_INCREMENT, last_name VARCHAR(255), gender CHAR(1), email VARCHAR(255)) 全局项目结构 新建javabean类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mybatis.bean;public class Employee &#123; private Integer id; private String lastName; private String email; private String gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"Employee&#123;\" + \"id=\" + id + \", lastName='\" + lastName + '\\'' + \", email='\" + email + '\\'' + \", gender='\" + gender + '\\'' + '&#125;'; &#125;&#125; 新建sql映射文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间 id:唯一标识 resultType:返回值类型 #&#123;id&#125;：从传递过来的参数中取出id值 --&gt;&lt;mapper namespace=\"com.mybatis.EmployeeMapper\"&gt; &lt;select id=\"selectEmp\" resultType=\"com.mybatis.bean.Employee\"&gt; select id,last_name lastName,email,gender from tb1_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 新建全局配置文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置数据源 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将写好的sql映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"EmployeeMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 新建测试类 1234567891011121314151617181920212223242526272829303132333435363738package com.mybatis.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import com.mybatis.bean.Employee;class MybatisTest &#123; @Test public void test() throws IOException &#123; // 1. 根据全局配置文件创建一个sqlSessionFactory对象（工厂对象） String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取sqlSession实例，能直接执行已经映射的sql语句 SqlSession openSession = sqlSessionFactory.openSession(); try &#123; // 2个参数： // sql的唯一标识：sql映射文件的名称空间.唯一标识 // 执行sql要用的参数 Employee employee = openSession.selectOne(\"com.mybatis.EmployeeMapper.selectEmp\",1); System.out.println(employee); &#125;finally&#123; openSession.close(); //关闭sqlSession &#125; &#125;&#125; 第一条语句（改进）但是测试类那样书写太麻烦，因此我们可以使用接口的代理对象来执行这些操作。 项目结构： 新建接口 1234567package com.mybatis.dao;import com.mybatis.bean.Employee;public interface EmployeeMapper &#123; public Employee getEmpById(Integer id);&#125; 修改sql映射文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间,指定相关接口的全限定类名，接口和映射文件动态绑定 id:唯一标识 resultType:返回值类型 #&#123;id&#125;：从传递过来的参数中取出id值 --&gt;&lt;mapper namespace=\"com.mybatis.dao.EmployeeMapper\"&gt; &lt;select id=\"getEmpById\" resultType=\"com.mybatis.bean.Employee\"&gt; select id,last_name lastName,email,gender from tb1_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 修改测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.mybatis.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import com.mybatis.bean.Employee;import com.mybatis.dao.EmployeeMapper;class MybatisTest &#123; // 将创建SqlSessionFactory单独封装成一个方法，避免重复代码 public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void test() throws IOException &#123; /* * String resource = \"mybatis-config.xml\"; InputStream inputStream = * Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory * = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 2. 获取sqlSession实例，能直接执行已经映射的sql语句 SqlSession openSession = sqlSessionFactory.openSession(); try &#123; Employee employee = openSession.selectOne(\"com.mybatis.EmployeeMapper.selectEmp\",1); System.out.println(employee); &#125;finally&#123; openSession.close(); &#125; &#125; @Test public void Test01() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 获取sqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); try &#123; // 获取接口的实现类对象 // 问:这个接口没有实现类啊？ // 答:mybatis会为接口自动创建一个代理对象，代理对象去执行增删改查操作 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); Employee employee = mapper.getEmpById(1); System.out.println(mapper.getClass()); //class com.sun.proxy.$Proxy8【代理对象】 System.out.println(employee); &#125;finally &#123; openSession.close(); &#125; &#125;&#125; 总结 接口式编程 原生： Dao（接口） ====&gt; DaoImpl（对应的实现类） mybatis: Mapper（接口） ====&gt; xxMapper.xml（对应的映射文件） Mapper接口 Mapper接口没有实现类，但是将接口和映射文件绑定之后，mybatis接口会为这个接口生成一个代理对象 SqlSession SqlSession代表和数据库的一次会话，用完必须关闭 SqlSession和Connection一样都是非线程安全的（不要作为共享的成员变量），因此每次使用完都应该去获取新的对象。 两个重要的配置文件 mybatis的全局配置i文件，包含数据库连接池信息，事务管理器信息，映射文件的位置信息，系统运行环境信息等等 sql映射文件，保存了每一个sql语句的映射信息。mybatis就是使用映射文件将sql抽取出来，因此是半自动的。 MyBatis全局配置文件 约束文件：定义了特定文件的语法规则 properties标签：引入外部properties配置文件的内容 resource 属性：引入类路径下的资源 url 属性：引入网络路径或磁盘路径下的资源 environments标签：配置多种环境 default 属性：指定使用某种环境，如果配置多种环境，当用到了某一环境，修改default可以快速切换环境 environment：配置一个具体的环境信息，必需有2个标签。id是当前环境的唯一表示 transactionManager标签：事务管理器 type 属性：事务管理器类型： JDBC（JdbcTransactionFactory）|MANAGED（JdbcTransactionFactory） dataSource：数据源 POOLED | UNPOOLED | JNDI settings标签：包含很多设置项 setting子标签：设置某一设置项 name 属性：设置项名 value属性：设置项取值 mapUnderscoreToCamelCase：是否开启驼峰命名规则，默认值为false 如数据库中为last_name,Bean中为lastName，那么会自动将 last_name 转为 lastName，这样的话，不用在 sql 语句中定义别名就可以设置对应的值了。 typeAliases标签：别名处理器，可以为Java类起别名，默认别名就是类名小写 typeAlias子标签：为某个类起别名 package子标签：为某个包下的所有类批量起别名 在批量起别名的情况下，为了防止冲突，也可以使用@Alias注解为某个类型指定新的别名 typeHander标签：类型处理器 plugins标签：插件 mappers标签：将sql映射注册到全局配置中 mapper标签：注册一个映射 resource属性：引用类路径下的sql映射文件 url：引用网络路径或磁盘路径下的sql映射文件 class属性：引用（注册）接口 有映射文件时，映射文件要与接口在同一目录下，映射文件名必须和接口同名 没有sql映射文件时，所有的sql都是利用注解写在接口上 package标签：批量注册映射，注意：接口和sql文件应该在一个包下（同名包也行） name：某个包的名字 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 引入外部properties配置文件的内容 --&gt; &lt;properties resource=\"dbconfig.properties\"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;!-- 起别名 --&gt; &lt;typeAliases&gt; &lt;!-- 为单个类起别名 --&gt; &lt;!-- &lt;typeAlias type=\"com.mybatis.bean.Employee\" alias=\"emp\"/&gt; --&gt; &lt;!-- 批量起别名 --&gt; &lt;package name=\"com.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将写好的sql映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/EmployeeMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; MyBatis映射文件 1. 增删改查映射接口 EmployeeMapper.java 12345678910111213package com.mybatis.dao;import com.mybatis.bean.Employee;public interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void addEmp(Employee employee); public void updateEmp(Employee employee); public void deleteEmpById(Integer id);&#125; 映射文件 EmployeeMapper.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间,指定相关接口的全限定类名，接口和映射文件动态绑定 id:唯一标识 resultType:返回值类型 #&#123;id&#125;：从传递过来的参数中取出id值 --&gt;&lt;mapper namespace=\"com.mybatis.dao.EmployeeMapper\"&gt; &lt;select id=\"getEmpById\" resultType=\"com.mybatis.bean.Employee\"&gt; select * from tb1_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"addEmp\"&gt; insert into tb1_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;update id=\"updateEmp\"&gt; update tb1_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=\"deleteEmpById\"&gt; delete from tb1_employee where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试类 MybatisTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mybatis.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import com.mybatis.bean.Employee;import com.mybatis.dao.EmployeeMapper;class MybatisTest &#123; // 将创建SqlSessionFactory单独封装成一个方法，避免重复代码 public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void Test02() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 获取sqlSession对象(不会自动提交数据，也就无法修改数据库的数据，因此要手动提交) SqlSession openSession = sqlSessionFactory.openSession(); try &#123; // 获取接口的实现类对象 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); // 测试添加 //Employee employee = new Employee(null,\"jerry\",\"jerry@qq.com\",\"1\"); //mapper.addEmp(employee); // 测试更新 //Employee employee = new Employee(1,\"jerry\",\"jerry@qq.com\",\"0\"); //mapper.updateEmp(employee); // 测试删除 mapper.deleteEmpById(2); // 手动提交数据 openSession.commit(); &#125;finally &#123; openSession.close(); &#125; &#125;&#125; mybatis允许增删改直接定义一下类型返回值 Integer、Long、Boolean、void 在做增删改查操作时，我们需要手动提交数据 手动提交：sqlSessionFactory.openSession(); 自动提交：sqlSessionFactory.openSession(true); 2. insertinsert标签的属性 id：唯一标识 parameterType：参数类型，可以省略 获取自增主键的值（2个标签） useGeneratedKeys=&quot;true&quot;：使用自增主键获取主键值策略 mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGeneratedKeys() keyProperty：指定主键属性。mybatis获取到主键值后，将这个值封装给指定的主键属性 3. 参数处理参数个数单个参数：mybatis不会做特殊处理，#{参数值}，即可取出参数值 多个参数：mybatis会做特殊处理，多个参数会被封装成一个map key:param1，param2，…，paramN，或者参数的索引也行（0，1，…，N） value：传入的参数值 使用#{}从map中取出key对应的参数值 因此，使用其他参数会报错。如果不想使用param1这种格式，只想用属性值来传值，该怎么做呢？我们可以使用命名参数来做。 命名参数：明确指定封装参数时map的key，如@Param(&quot;id&quot;) 在映射接口的方法的参数前，加入@Param注解 多个参数会被封装成一个map，此时： key：使用@Param注解指定的值 value：参数值 使用#{指定key}从map中取出key对应的参数值 使用@Param注解前： 运行报错 1234&gt; Cause: org.apache.ibatis.binding.BindingException: &gt; Parameter 'id' not found.&gt; Available parameters are [arg1, arg0, param1, param2]&gt; 使用@Param注解后： POJO 但是如果参数多了，这么写也很麻烦，因此我们一般直接传入pojo（bean类）： 如果多个参数刚好是我们业务逻辑的数据模型（bean的属性值），可以直接传入pojo 使用#{属性值}，取出传入的pojo的属性值 Map 如果多个参数不是业务模型中的数据，没有对应的pojo，并且不经常使用，为了方便，我们可以直接传入map（因为最后也要封装成map，干脆直接用map） TO 如果多个参数不是业务模型中的数据，并且经常使用，推荐来编写一个TO（Transfer Object）数据传输对象 思考 public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName); 取值：id—&gt;#{id/param1} lastName—&gt;#{param2} public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp); 取值：id—&gt;#{param1} lastName—&gt;#{param2.lastName/e.lastName} 特别注意：若传入的参数类型是Collection（List、Set）类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中。 key：Collection用collection，如果是List既可以用collection也可以用list，数组用array public Employee getEmpById(List&lt;Integer&gt; ids); 取值：取出第一个id的值： #{list[0]} 参数值的获取{}：可以获取map中的值或者pojo对象属性的值； ${}：可以获取map中的值或者pojo对象属性的值； sql语句：select * from tbl_employee where id=${id} and last_name=#{lastName} 控制台：Preparing: select * from tbl_employee where id=2 and last_name=? 区别： {}:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}:取出的值直接拼装在sql语句中；会有安全问题；` 大多情况下，我们去参数的值都应该去使用#{}； 原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序。。。；按照年份分表拆分select * from ${year}_salary where xxx; select * from tbl_employee order by ${f_name} ${order} { }更丰富的用法： 规定参数的一些规则：javaType、 jdbcType、 mode（存储过程）、 numericScale、resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）； jdbcType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理; 由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；两种办法1、#{email,jdbcType=OTHER};2、jdbcTypeForNull=NULL &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt; select如果返回值是集合（List...），那么映射文件中对应的resultType要写集合中的元素类型 返回值是Map，key为列名，value为对应值","categories":[],"tags":[]},{"title":"JQuery 基础","slug":"JQuery-基础","date":"2019-11-30T03:19:53.000Z","updated":"2019-11-30T06:37:23.000Z","comments":true,"path":"2019/11/30/JQuery-基础/","link":"","permalink":"https://cometorbityh.github.io/2019/11/30/JQuery-基础/","excerpt":"","text":"初识jQuery什么是jQuery?jQuery是一款优秀的JavaScript库，主要用途是： 查询（js+Query） 简化原生JS操作，使用jQuery能让我们对HTML文档遍历和操作、事件处理、东湖处理以及Ajax变得更加简单 为什么要用jQuery？ 强大的选择器：方便快速查找DOM元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; div&#123; width: 100px; height: 100px; border: 1px solid #000; &#125;&lt;/style&gt;&lt;body&gt;&lt;script src=\"static/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function (ev) &#123; // 1.利用原生JS查找DOM元素 var div1 = document.getElementsByTagName(\"div\")[0]; var div2 = document.getElementsByClassName(\"box1\")[0]; var div3 = document.getElementById(\"box2\"); console.log(div1); console.log(div2); console.log(div3); // 2.利用原生的JS修改背景颜色 div1.style.backgroundColor = \"red\"; div2.style.backgroundColor = \"blue\"; div3.style.backgroundColor = \"yellow\"; &#125; //利用jQuery查找DOM元素 修改背景颜色 $(function()&#123; var $div1 = $(\"div\"); var $div2 = $(\".box1\"); var $div3 = $(\"#box2\"); console.log($div1); console.log($div2); console.log($div3); $div1.css(&#123; background:\"red\", width:\"200px\", height:\"200px\" &#125;); $div2.css(&#123; background:\"blue\" &#125;); $div3.css(&#123; background:\"yellow\" &#125;); &#125;);&lt;/script&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=\"box1\"&gt;&lt;/div&gt;&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器兼容 1.x：兼容ie678 2.x：不兼容ie678 3.x：不兼容ie678 如何使用？ 下载jQuery库 引入jQuery库 编写jQuery代码 jQuery入口函数jQuery和js的加载模式（入口函数） JS和jQuery入口函数的加载模式不同 原生JS会等到DOM元素加载完毕，并且图片也加载完毕才会执行 jQuery会得等到DOM元素加载完毕，但不会等到图片也加载完毕就会执行 JS若编写了多个入口函数，后面编写的会覆盖前面编写的 jQuery若编写了多个入口函数，后面编写的不会覆盖前面编写的 jQuery入口函数的四种写法 12345678910111213141516&lt;script src=\"static/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; // 1 &#125;); jQuery(document).ready(function () &#123; // 2 &#125;); $(function () &#123; // 推荐写法 // 3 &#125;); jQuery(function () &#123; // 4 &#125;); &lt;/script&gt; jQuery冲突问题 核心函数$();：就代表jQuery的核心函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; div&#123; width: 100px; height: 100px; border: 1px solid #000; &#125; &lt;/style&gt; &lt;script src=\"static/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 1.接收一个函数 $(function () &#123; alert(\"hello comet!\"); // 2.接收一个字符串 // 2.1 接收一个字符串选择器 // 返回一个jQuery对象，对象中保存了找到的DOM元素 var $box1 = $(\".box1\"); var $box2 = $(\"#box2\"); console.log($box1); console.log($box2); // 2.2 接收一个代码片段 // 返回一个jQuery对象，对象中保存了创建的DOM元素 var $p = $(\"&lt;p&gt;我是段落&lt;/p&gt;\"); console.log($p); $box2.append($p); //拼接在$box1上 // 3.接收一个DOM元素 // 会被包装成一个jQuery对象返回给我们 var span = document.getElementsByTagName(\"span\")[0]; console.log(\"span\",span); var $span = $(span); console.log($span); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 传递函数传递选择器传递DOM对象传递HTML","categories":[],"tags":[]},{"title":"JS 基础","slug":"JS-基础","date":"2019-11-29T07:13:17.000Z","updated":"2019-11-29T15:15:30.099Z","comments":true,"path":"2019/11/29/JS-基础/","link":"","permalink":"https://cometorbityh.github.io/2019/11/29/JS-基础/","excerpt":"","text":"01_数据类型分类 基本(值)类型 String: 任意字符串 Number: 任意的数字 boolean: true/false undefined: undefined null: null 对象(引用)类型 Object: 任意对象（内部数据无序） Function: 一种特别的对象(可以执行) Array: 一种特别的对象(数值下标, 内部数据是有序的) 判断 typeof: 返回数据类型的字符串表达（引号内的是字符串） 可以判断: undefined/ number/ string / boolean / function 不能判断: null与object object与array null,array,object的typeof都是object，但是function的typeof是function instanceof: 判断对象的具体类型，A instanceof B表示A是否是B这个类型的实例 === 可以判断: undefined, null 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=\"text/javascript\"&gt; /** * 1. 使用typeof判断数据类型 */ var a; console.log(a, a===undefined, typeof a, typeof a === \"undefined\") //undefined true \"undefined\" true a=3; console.log(typeof a === \"number\"); //true a=\"nihao\"; console.log(typeof a === \"string\"); //true a=true;a console.log(typeof a === \"boolen\"); //true a=null; console.log(typeof a === \"null\"); //false,【null 的typeof是 \"object\"】 /** * 2.使用instanceof判断对象的类型 */ var b1 = &#123; b2: [1, 'abc', console.log], b3: function () &#123; console.log('b3') return function () &#123; return 'xfzhang' &#125; &#125; &#125; // 函数和数组都是一种Object对象 console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /** * 3.使用typeof判断对象的类型 */ console.log(typeof b1) // 'object' console.log(typeof b1.b2) // 'object' 【数组的typeof是object】 console.log(typeof b1.b3==='function') // true console.log(typeof b1.b2[2]==='function') // true console.log(b1.b2[2](4)) //4，【相当于是console.log(4)】 console.log(b1.b3()()) //xfzhang&lt;/script&gt; 问题 undefined与null的区别?⭐ undefined代表定义了未赋值 nulll定义了并赋值了, 只是值为null 什么时候给变量赋值为null呢? / 为什么null的typeof是object？ 初始赋值, 表明将要赋值为对象（还没想好，指向谁，先赋值为null吧） 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 123456//起始 var b = null // 初始赋值为null, 表明将要赋值为对象 //确定对象就赋值 b = ['atguigu', 12] //最后 b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 02_数据 变量 内存 什么是数据? 存储在内存中代表特定信息的’东东’, 本质上是0101… 数据的特点: 可传递, 可运算 一切皆数据 内存中所有操作的目标: 数据 算术运算 逻辑运算 赋值 运行函数 什么是内存? 内存条通电后产生的可储存数据的空间(临时的) 内存产生和死亡: 内存条(电路版)==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 全局变量/局部变量 堆: 对象 什么是变量? 可变化的量, 由变量名和变量值组成 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据 内存,数据, 变量三者之间的关系 内存用来存储数据的空间 变量是内存的标识 03_对象 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 为什么要用对象? 统一管理多个数据 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) 如何访问对象内部数据? .属性名: 编码简单, 有时不能用 [‘属性名’]: 编码麻烦, 能通用 什么时候必须使用[‘属性名’]的方式? 1. 属性名包含特殊字符: - 空格 2. 属性名不确定 04_函数-基础首先我们知道，函数是一种特殊的对象，那么他就需由对象的特点，也有自己的特点，因此函数比对象更加复杂 什么是函数? 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 为什么要用函数? 提高代码复用 便于阅读交流 如何定义函数? 函数声明 表达式 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 回调函数 回调函数的特点1). 你定义的2). 你没有调3). 但最终它执行了(在某个时刻或某个条件下) 常见的回调函数? dom事件回调函数 ==&gt;发生事件的dom元素 定时器回调函数 ===&gt;window ajax请求回调函数(后面讲) 生命周期回调函数(后面讲) 123456789101112131415&lt;body&gt; &lt;button id=\"btn\"&gt;测试点击事件&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById('btn').onclick = function () &#123; // dom事件回调函数 alert(this.innerHTML) &#125; //定时器 // 超时定时器 // 循环定时器 setTimeout(function () &#123; // 定时器回调函数 alert('到点了'+this) &#125;, 2000) &lt;/script&gt;&lt;/body&gt; LIFE 理解 全称: Immediately-Invoked Function Expression，立即调用（执行）函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; (function () &#123; //匿名函数自调用 var a = 3 console.log(a + 3) &#125;)() var a = 4 console.log(a) ;(function () &#123; var a = 1 function test () &#123; console.log(++a) &#125; window.$ = function () &#123; // 向外暴露一个全局函数 return &#123; test: test &#125; &#125; &#125;)() $().test() // 1. $是一个函数 2. $执行后返回的是一个对象&lt;/script&gt; 函数中的this this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435&lt;script type=\"text/javascript\"&gt; function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(\"red\"); //this是谁? window var p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, \"black\"); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1();&lt;/script&gt; 05_函数-高级原型 原型链原型（prototype） 显示原型与隐式原型 原型链 探索instanceof 执行上下文与执行上下文栈变量提升 函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象) 问题: 变量提升和函数提升是如何产生的? 执行上下文全局执行上下文函数执行上下文执行上下文栈问题","categories":[],"tags":[]},{"title":"JAVA 多线程：1","slug":"JAVA-多线程：1","date":"2019-11-26T12:21:27.000Z","updated":"2019-12-04T15:29:32.945Z","comments":true,"path":"2019/11/26/JAVA-多线程：1/","link":"","permalink":"https://cometorbityh.github.io/2019/11/26/JAVA-多线程：1/","excerpt":"","text":"多线程线程的创建 + 启动方式1：继承 java.lang.Thread 类，并覆盖run( ) 方法方式2：实现 java.lang.Runnble 接口，并实现run( )方法方式3：实现 Callable 接口，并实现call( )方法 tips：我们常写的main方法也是一个线程，称为”主线程“ 线程启动的步骤： 创建线程类，重写 run( ) 方法 创建线程对象 启动该线程，start( ) 方法（注意不是执行 run 方法） 方式一 继承Thread类123456789101112131415161718192021222324252627282930313233343536373839public class ThreadDemo extends Thread &#123; // 方法体，run()中写的是线程执行的代码，线程要完成的任务 @Override public void run() &#123; //由于继承了Thread类，可以直接用this调用线程的方法 while(true)&#123; System.out.println(\"当前线程名：\"+this.getName()+\",线程优先级：\"+this.getPriority()); &#125; &#125;&#125;public class demo&#123; public static void main(String[] args) &#123; //创建线程对象 ThreadDemo thread = new ThreadDemo(); //启动线程 thread.start(); // main线程 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\"，线程优先级：\"+Thread.currentThread().getPriority()); &#125; //设定主线程优先级 //Thread.currentThread().setPriority(Thread.MAX_PRIORITY); &#125;&#125;--------------------------当前线程名：main，线程优先级：5当前线程名：main，线程优先级：5当前线程名：main，线程优先级：5当前线程名：Thread-0,线程优先级：5当前线程名：Thread-0,线程优先级：5当前线程名：Thread-0,线程优先级：5...... Thread常用的方法 run() —— 线程体 start( ) —— 启动线程 currentThread( ) —— 获取当前线程 ** getName() —— 获取线程名称 ** setName() —— 设置线程名称 ** getPriority() —— 获取线程优先级 ** setPriority() —— 设置线程优先级 优先级级别越低，代表执行的几率越小，但不是没有 方式二 实现Runnable接口123456789101112131415161718192021222324252627282930public class RunnableDemo implements Runnable &#123; // 方法体，run()中写的是线程执行的代码，线程要完成的任务 @Override public void run() &#123; //由于继承了Thread类，可以直接用this调用线程的方法 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\",线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125;&#125;public class demo&#123; public static void main(String[] args) &#123; //创建线程对象 Runnable r = new RunnableDemo(); //这并不是个线程对象 Thread thread = new Thread(r); //这才是线程对象 //启动线程 thread.start(); // main线程 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\"，线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125;&#125; 2种定义线程类的方法的对比 Thread类 Runnable接口 1 编程相对简单 编程相对复杂 2 Thread是个类，因此线程类无法继承其他类 Runnable是个接口，因此线程类还可以继承其他类 3 多个线程共享同一个资源 更方便多个线程共享同一个资源 上述3的举例： 12345678910111213141516171819202122public class demo&#123; public static void main(String[] args) &#123; // 创建线程对象 Runnable r = new RunnableDemo(); // 多个Thread对象共用同一个RunnableDemo Thread thread1 = new Thread(r); Thread thread2 = new Thread(r); Thread thread3 = new Thread(r); // 启动线程 thread1.start(); thread2.start(); thread3.start(); // main线程 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\"，线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125;&#125; 这样，假如在线程类中售卖200张票。如果启动了3个对象，就相当于是3个窗口交替的在给你卖票，这样效率就特别快了。 匿名内部类在线程中的使用如果某个Runnable接口的实现类只使用一次，使用匿名内部类即可 多个Thread对象 12345678910111213141516171819202122232425262728293031public class demo1 &#123; public static void main(String[] args) &#123; // 创建线程对象 Runnable r = new Runnable()&#123; @Override public void run() &#123; while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\",线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125; &#125;; // 多个Thread对象共用同一个Runnable对象 Thread thread1 = new Thread(r); Thread thread2 = new Thread(r); Thread thread3 = new Thread(r); // 启动线程 thread1.start(); thread2.start(); thread3.start(); // main线程 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\"，线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125;&#125; 单个Thread对象 123456789101112131415161718192021222324public class demo1 &#123; public static void main(String[] args) &#123; // 创建线程对象 Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\",线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125; &#125;); // 启动线程 thread1.start(); // main线程 while(true)&#123; System.out.println(\"当前线程名：\"+Thread.currentThread().getName()+\"，线程优先级：\"+Thread.currentThread().getPriority()); &#125; &#125;&#125; 提取线程如果多定义几个线程类，但仅仅只是其中的名字不一样时，这是我们可以考虑用bean来封装一个通用类，这个类继承自Thread类，重写run（）方法，并且可以传入线程名和其他数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class RunnerThread extends Thread &#123; private String RunnerName; public RunnerThread() &#123; &#125; public RunnerThread(String runnerName) &#123; //指定运动员名字 RunnerName = runnerName; &#125; public RunnerThread(String name, String runnerName) &#123; //指定运动员名字 和 线程名字 super(name); RunnerName = runnerName; &#125; public String getRunnerName() &#123; return RunnerName; &#125; public void setRunnerName(String runnerName) &#123; RunnerName = runnerName; &#125; @Override public void run() &#123; super.run(); while (true)&#123; System.out.println(this.RunnerName + \"领先！TA的线程（赛道）是\"+this.getName()); &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; RunnerThread t1 = new RunnerThread(); t1.setRunnerName(\"刘翔\"); t1.setName(\"刘翔线程\"); Thread t2 = new RunnerThread(\"可达鸭\"); Thread t3 = new RunnerThread(\"姚明线程\",\"姚明\"); t1.start(); t2.start(); t3.start(); &#125;&#125;-------------------------------刘翔领先！TA的线程（赛道）是刘翔线程刘翔领先！TA的线程（赛道）是刘翔线程刘翔领先！TA的线程（赛道）是刘翔线程刘翔领先！TA的线程（赛道）是刘翔线程可达鸭领先！TA的线程（赛道）是Thread-1可达鸭领先！TA的线程（赛道）是Thread-1姚明领先！TA的线程（赛道）是姚明线程 方式三 实现Callable接口线程的生命周期CPU只有一个，必须抢占，若抢占不到，就要排队 就绪状态也称可运行状态，可以运行但是还【没得到资格】运行 线程控制的几个方法setName( ), setPriority( ) 可以在线程类中设定，也可以在start()之前设定 Java提供了一个线程调度器，来监控程序中启动后并进入就绪状态的所有线程，线程调度器会按照线程的优先级决定应调度哪个线程来执行。 线程优先级用数字表示，范围在[0,10] 注意：优先级低只是意味着获得调度的概率低，并不是绝对先调用优先级高后调用优先级低的线程 join( )：插队 作用：阻塞当前正在运行的线程，插入本线程，等本线程执行完毕后，再执行被阻塞的线程 简而言之：某个线程被本少爷中断了（插队了） 注意：join() 必须写在 start() 之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class RunnableDemo extends Thread &#123; @Override public void run() &#123; int i=0; while(i&lt;6)&#123; System.out.println(i+\" 从线程：\"+Thread.currentThread().getName()+\"---\"+Thread.currentThread().getPriority()); i++; &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; int i=0; while(i&lt;10)&#123; if(i==4)&#123; //另一个线程对象 Thread t1 = new RunnableDemo(); t1.setName(); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(i+\" 主线程：\"+ Thread.currentThread().getName() +\"---\" +Thread.currentThread().getPriority()); i++; &#125; &#125;&#125;--------------------------------0 主线程：main---51 主线程：main---52 主线程：main---53 主线程：main---50 从线程：我是被阻塞的线程---51 从线程：我是被阻塞的线程---52 从线程：我是被阻塞的线程---53 从线程：我是被阻塞的线程---54 从线程：我是被阻塞的线程---55 从线程：我是被阻塞的线程---54 主线程：main---55 主线程：main---56 主线程：main---57 主线程：main---58 主线程：main---59 主线程：main---5 sleep() 作用：阻塞当前线程，让当前线程进入阻塞状态（让出CPU执行权），时间一到，线程会进入就绪状态（并不是运行状态） 在被阻塞的时间内，就算CPU处于空闲，被sleep的线程也不会提前结束阻塞状态，也无法获取到CPU的执行权 应用 在多线程环境下，模拟线程的切换，让某些安全的问题得以充分的暴露 从线程每执行一次，就会sleep1毫秒，在这1毫秒内，主线程获取到主线程的执行权，在1毫秒内执行了很多次，等到1毫秒后，CPU的执行权又要受到争夺。也就是说，就算被阻塞的线程sleep之后，也不一定会立即得到CPU执行权，也是要重新抢占CPU的执行权。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RunnableDemo extends Thread &#123; @Override public void run() &#123; while(true)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"从线程：\"+Thread.currentThread().getName()+\"---\"+Thread.currentThread().getPriority()); &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; //另一个线程对象 Thread t1 = new RunnableDemo(); t1.setName(\"我是sleep的线程\"); t1.start(); while(true)&#123; System.out.println(\"主线程：\"+ Thread.currentThread().getName() +\"---\" +Thread.currentThread().getPriority()); &#125; &#125;&#125;------------------------------------主线程：main---5主线程：main---5主线程：main---5主线程：main---5从线程：我是sleep的线程---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5...... yield()：礼让field，原义屈服，投降，在此处翻译为“礼让”，礼让CPU。 使当前线程释放CPU，进入就绪状态，重新排队，抢占CPU执行权。 作用：让同优先级或更高级别的线程得到执行的机会。 1234567891011121314151617181920212223242526272829303132333435363738public class RunnableDemo extends Thread &#123; @Override public void run() &#123; while(true)&#123; Thread.yield(); System.out.println(\"从线程：\"+Thread.currentThread().getName()+\"---\"+Thread.currentThread().getPriority()); &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; //另一个线程对象 Thread t1 = new RunnableDemo(); t1.setName(\"我是sleep的线程\"); t1.start(); while(true)&#123; Thread.yield(); System.out.println(\"主线程：\"+ Thread.currentThread().getName() +\"---\" +Thread.currentThread().getPriority()); &#125; &#125;&#125;-------------------------------------主线程：main---5主线程：main---5主线程：main---5主线程：main---5从线程：我是sleep的线程---5主线程：main---5从线程：我是sleep的线程---5主线程：main---5从线程：我是sleep的线程---5主线程：main---5主线程：main---5 setDaemon(true)：后台线程/寄生线程从线程是在main方法中定义的，实际上当主线程执行完毕后，从线程还在执行， 123456789101112----主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5主线程：main---5从线程：我是从线程---5从线程：我是从线程---5从线程：我是从线程---5从线程：我是从线程---5 那么现在有一个需求，就是当主线程执行完毕后，从线程也不再执行（就好比寄生物一般，主体死亡，寄生物也跟着消失） 此时就要要到 Thread类的 setDaemon(true) 方法了 setDaemon(true) 作用：使当前线程变成后台线程（寄生线程），启动后台线程的线程结束时，后台线程也随之结束 注意：该方法也应该定义在start()方法之前，即只能在线程启动之前将其设定为后台线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RunnableDemo extends Thread &#123; @Override public void run() &#123; while(true)&#123; System.out.println(\"从线程：\"+Thread.currentThread().getName()+\"---\"+Thread.currentThread().getPriority()); &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; //另一个线程对象 Thread t1 = new RunnableDemo(); t1.setName(\"我是从线程\"); t1.setDaemon(true); t1.start(); int i=0; while(i&lt;6)&#123; System.out.println(\"主线程：\"+ Thread.currentThread().getName() +\"---\" +Thread.currentThread().getPriority()); i++; &#125; &#125;&#125;--------------------------------------主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5从线程：我是从线程---5从线程：我是从线程---5 可以看到结果，主线程执行完后，从线程也会渐渐的停止执行（多出的几次是误差，可忽略不计） interrupt()中断线程（软中断）：不直接中断线程，而是需要被中断线程自己处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RunnableDemo extends Thread &#123; @Override public void run() &#123; // 线程未被中断时，执行 while(!this.isInterrupted())&#123; System.out.println(\"从线程：\"+Thread.currentThread().getName()+\"---\"+Thread.currentThread().getPriority()); &#125; &#125;&#125;public class demo1 &#123; public static void main(String[] args) &#123; //另一个线程对象 Thread t1 = new RunnableDemo(); t1.setName(\"我是从线程\"); t1.setDaemon(true); t1.start(); int i=0; while(i&lt;6)&#123; System.out.println(\"主线程：\"+ Thread.currentThread().getName() +\"---\" +Thread.currentThread().getPriority()); i++; &#125; // 当主线程执行完毕时， 中断从线程 t1.interrupt(); &#125;&#125;---------------------------------主线程：main---5主线程：main---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5从线程：我是从线程---5主线程：main---5 //此时主线程执行完毕，中断从线程从线程：我是从线程---5 stop()*（不推荐使用）中断线程（硬中断）：直接结束线程 Java 多线程锁释放 (⭐) 问：Java多线程运行环境中，在哪些情况下会使对象锁释放？ 答：由于等待一个锁的线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不再需要锁的时候及时释放锁是很重要的。 在以下情况下，持有锁的线程会释放锁：（1）执行完同步代码块，就会释放锁。（synchronized）（2）在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。（exception）（3）在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进入对象的等待池。(wait) 除了以上情况以外，只要持有锁的线程还没有执行完同步代码块，就不会释放锁。在下面情况下，线程是不会释放锁的：（1）执行同步代码块的过程中，执行了Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。（2）在执行同步代码块的过程中，执行了Thread.yield()方法，当前线程放弃CPU，但不会释放锁。（3）在执行同步代码块的过程中，其他线程执行了当前线程对象的suspend()方法，当前线程被暂停，但不会释放锁。 线程同步当多个线程访问通过一个数据时，容易出现线程安全问题，需要让线程同步，保证数据安全 线程同步：当2个及2个以上的线程同时访问同一个资源时，需要某种方式来确保资源在某一个时刻只被一个线程使用 线程同步的实现方案 同步代码块 synchronized(obj){} 同步方法 private synchronized void XXX(){} 案例引导 需求：多用户同时操作统一账户取款，保证账户金额不出现错误 分析： 多个用户对同一个账户取款，因此开发一个账户类 多用户取款操作流程一样，因此开发一个取款线程类 每个用户对应一个线程对象，因为是多个用户对同一个账户取款，有共享资源（账户），因而使用Runnable接口实现。 思路：创建银行账户类Account，创建取款线程AccountRunnable，创建测试类TestAccount，让2个用户同时取款 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 账户类 */public class Account &#123; //余额 private Integer balance = 600; public Integer getBalance() &#123; return balance; &#125; //取款操作 public void withDraw(int money)&#123; this.balance = balance -money; &#125;&#125;public class AccountRunnable implements Runnable&#123; private Account account = new Account(); //取款操作 @Override public void run() &#123; // ... //核心操作 if(account.getBalance()&gt;=400)&#123; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; // ... &#125;&#125;public class AccountTest &#123; public static void main(String[] args) &#123; //创建2个线程 Runnable a = new AccountRunnable(); //账户线程 Thread thread1 = new Thread(a); thread1.setName(\"张三\"); Thread thread2 = new Thread(a); thread2.setName(\"张三妻子\"); //启动2个线程 thread1.start(); thread2.start(); &#125;&#125;------------------------------------张三取款成功，当前余额：200 //情况1张三妻子余额不足,取款失败！当前余额：200 张三妻子余额不足,取款失败！当前余额：200 //情况2张三取款成功，当前余额：200 乍一看好像有点问题，取款成功和失败的顺序有点不大对，那我们使用sleep来放大一下安全问题： 123456789101112131415161718192021222324252627282930313233public class AccountRunnable implements Runnable&#123; private Account account = new Account(); //取款操作 @Override public void run() &#123; // ... //核心操作 if(account.getBalance()&gt;=400)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; // ... &#125;&#125;------------------------------------张三妻子取款成功，当前余额：-200 //情况1张三取款成功，当前余额：-200张三妻子取款成功，当前余额：200 //情况2张三取款成功，当前余额：200 居然都有负数！！！那么发生上述的问题该如何解决？ 同步代码块synchronized（同步监视器）{同步代码块：可能出现安全隐患的代码} 同步监视器（锁）的要求： 必须是引用数据类型，不能是基本数据类型 在同步代码快中不能可以改变同步监视器的属性值，不能改变其引用（也就是说引用对象的属性值可以修改，但是不能将该引用指向其他对象） 若自己无法保证修改，可以给同步监视器加上final关键字，这样即使在同步代码块中也会编译报错来提示。 尽量不用String和Integer做同步监视器，若用了，要保证代码块中不对其操作 String a=”hello”做同步监视器时，代码块中String a=”nihao”，相当于是改变了其引用，涉及到了常量池的引用 Integer a=1做同步监视器时，代码块中Integer a = 11,而常量池中有[-128，127]的引用，实际上是指向了常量池中2对应的引用 一般使用共享资源做同步监视器就行了 也可以专门创建一个 没有任何业务含义的同步监视器 建议使用final修饰同步监视器 总结下：同步监视器（3点）：必须是引用类型，可修改属性值不可修改引用，建议使用final修饰 同步代码块的执行过程 线程1 获取到cpu，来到同步执行块，发现同步监视器open状态，需要先close，在执行其中的代码 （线程1看到锁是开的，先进入，再把锁锁上了，这样就它自己一个线程在里面了） 线程1在执行过程中，发生了线程切换（阻塞，就绪），线程1失去了cpu,但是没有开锁open，因此线程2也进入阻塞状态（线程1在屋子里，失去了cpu，但是线程2由于被锁在外面进不来，拿到cpu也无法使用，进入阻塞状态） 线程1再次获取到cpu，接着执行后续代码，等待同步代码块执行完毕，线程1释放锁open （线程1做好了，开锁出去了） 线程2 再次获取到cpu，来到同步代码块，发现同步监视器open转台，重复线程1的处理过程 （上锁、执行、开锁） 将可能出现安全隐患的代码加入到同步代码块中 由于本例中只用到一个if else，无法分离。因此全部加进入。正常项目不会只会将可能出现安全隐患的代码加进去。 12345678910111213141516171819202122232425262728293031323334public class AccountRunnable implements Runnable&#123; private Account account = new Account(); //取款操作 @Override public void run() &#123; // ... //核心操作 synchronized (account)&#123; if(account.getBalance()&gt;=400)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; &#125; // ... &#125;&#125;----------------------------------------------张三取款成功，当前余额：200张三妻子余额不足,取款失败！当前余额：200 同步代码块的优缺点优点：安全 缺点：效率低 可能出现死锁 其他多个代码块使用同一个同步监视器（锁），锁住一个代码块的同时，也锁住了所有使用该锁的所有代码块，其他线程无法访问其中的任何一个代码块。但是没有锁住使用其他同步监视器的代码块，其他线程有机会访问其他同步监视器的代码块 同步方法关键字：synchronized 注意：不要将 run 方法设置为同步方法，那样run方法就变成单线程的了。（并行/并发—–&gt;串行） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AccountRunnable implements Runnable&#123; private Account account = new Account(); //取款操作 @Override public synchronized void run() &#123; // ... //核心操作 withDraw(); // ... &#125; public synchronized void withDraw()&#123; if(account.getBalance()&gt;=400)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; &#125;&#125;public class AccountTest &#123; public static void main(String[] args) &#123; //创建2个线程 Runnable a = new AccountRunnable(); //账户线程 Thread thread1 = new Thread(a); thread1.setName(\"张三\"); Thread thread2 = new Thread(a); thread2.setName(\"张三妻子\"); //启动2个线程 thread1.start(); thread2.start(); &#125;&#125;-------------------------------------------------张三取款成功，当前余额：200张三妻子余额不足,取款失败！当前余额：200 同步代码块有自定义的同步监视器，那么同步方法有吗？ 有。同步方法的同步监视器是this,也就是当前的对象。 也就是说，一旦一个同步方法被锁定，所有的同步方法都会被锁定。效率低下 Lock锁JDK1.5提供了一个新的线程同步的方式。 java.util.concurrent.locks，我们需要用到并发包下的Locks的Lock接口 步骤：买锁 ---- 上锁 ---- 开锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.young.thread;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import static java.lang.Thread.sleep;public class AccountRunnable implements Runnable&#123; // 买锁 private Lock lock = new ReentrantLock(); private Account account = new Account(); //取款操作 @Override public synchronized void run() &#123; // ... //上锁 lock.lock(); //核心操作 if(account.getBalance()&gt;=400)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; //开锁 lock.unlock(); // ... &#125;&#125;-----------------------------张三取款成功，当前余额：200张三妻子余额不足,取款失败！当前余额：200 但这还是不够完整，若是同步代码发生异常，开锁的操作就不会执行，因此我们需要将 unlock() 加入 finally 来使开锁操作执行。 12345678910111213141516171819202122232425262728293031323334353637public class AccountRunnable implements Runnable&#123; // 买锁 private Lock lock = new ReentrantLock(); private Account account = new Account(); //取款操作 @Override public synchronized void run() &#123; // ... try&#123; //上锁 lock.lock(); //核心操作 if(account.getBalance()&gt;=400)&#123; try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.withDraw(400); System.out.println(Thread.currentThread().getName() + \"取款成功，当前余额：\" +account.getBalance()); &#125;else&#123; System.out.println(Thread.currentThread().getName() +\"余额不足,取款失败！当前余额：\" +account.getBalance()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //开锁 lock.unlock(); &#125; // ... &#125;&#125; 因此，这个lock的流程： Lock l = …; l.lock(); try { // access the resource protected by this lock } finally { l.unlock(); } Lock 和 synchronized 的区别Lock 是 JDK5 后新增的功能。与采用 synchronized 相比，Lock可提供多种锁方案（多个实现类）。更加灵活 Lock是显式锁（手动开启和关闭），synchronized是隐式锁 Lock只有代码块锁，synchronized有代码块锁和方法锁（lock只能锁代码，不能锁方法） 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（子类多） 3种同步方式的优先使用顺序Lock —- 同步代码块（已经进入线程体，分配了相应资源） —– 同步方法（在方法体之外，还得另外分配资源） 线程通信生产者和消费者问题 技能点：线程通信 wait() notify() notifyAll() Object类中的public方法 在上述例子中，要避免供过于求或供不应求。因此生产者和消费者之间要进行通信 分析： 生产者 —– 仓库（只能放一件商品） —– 消费者 生产和消费交替进行 生产者交替生成白色馒头和黄色玉米饼 注意： 线程通信的前提是线程同步，因此需要线程同步来保证安全性 生产者线程和消费者线程是2个不同的线程 本例与取款的例子不同：取款的2个线程对象是做相同的操作，而本例的2个线程对象一个做生产，一个做消费 生产者线程和消费者线程需要相互通信（还没有商品吗？没有，告诉生产者生产吧） 设计： 定义商品类 定义生产者线程 消费者线程 定义测试类（创建线程对象并启动） 发现问题 + 解决问题 第一个问题：实现相同锁 消费者获取到的产品名和产品颜色都是null 是因为他们获取到地不是同一个对象，因此要定义同一个对象，以参数的形式传递给生产者线程和消费者线程。 第二个问题：实现安全问题 当加入sleep方法后检查安全问题： 开始出现黄色馒头和白色玉米棒，这是因为没有线程同步，因此给生产者和消费者线程加上锁（同一把锁） 第三个问题：实现线程通信 生产者和消费者之间没有实现交替 调用同步监视器的wait()进行等待，调用同步监视器的notify()进行通知 注意wait()和notify()要写在同步的代码中，否则会报IllegalMonitorStateException 方法介绍 这些方法都是属于Object类的方法 wait():会进入【当前同步监控器】的【阻塞队列】，并【释放锁】。在其他线程调用此对象（同步监控器）的notify()或notifyAll()之前，都会处于线程等待状态（阻塞） 也就是说，当生产者发现仓库还有商品时，执行wait()进入了product的阻塞队列，并释放了锁，此时消费者抢占到CPU，拿到锁，进入了同步代码块，一看哟呵，有商品，因此没有进入wait()，而是直接消费商品，完后使用同一个监视器notify()通知（唤醒）处在阻塞队列的生产者，而后生产者继续执行未完的操作（不包括wait，因为wait已经执行完毕） wait(time):会进入当前同步监控器的阻塞队列time秒，并释放锁。过了time秒后，即使【没被唤醒】，也会【自己醒】来。 notify():通知（唤醒）在【此对象监视器】上等待的【一个】线程。 此时若所有线程都在此对象上等待，则会【随机】选择【唤醒其中一个】线程。 notifyAll():通知（唤醒）在【此对象监视器】上等待的【所有】线程。 被唤醒的线程将以常规的方式与该对象上主动同步的其他线程【进行竞争】 程序设计 (同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class Product &#123; private String name; private String color; // 商品标志 默认为没有商品 Boolean flag = false; public Product() &#123; &#125; public Product(String name, String color) &#123; this.name = name; this.color = color; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return \"Product&#123;\" + \"name='\" + name + '\\'' + \", color='\" + color + '\\'' + '&#125;'; &#125;&#125;======================================public class ProduceRunnable implements Runnable &#123; //private Product product = new Product(); private Product product = null; public ProduceRunnable(Product product) &#123; this.product = product; &#125; public Product getProduct() &#123; return product; &#125; public void setProduct(Product product) &#123; this.product = product; &#125; @Override public void run() &#123; int i=0; while(true)&#123; synchronized (product)&#123; // 如果仓库有了商品，就等待 if(product.flag)&#123; try &#123; product.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //生产商品并输出结果 if(i%2==0)&#123; product.setName(\"馒头\"); try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; product.setColor(\"白色\"); &#125;else &#123; product.setName(\"玉米棒\"); try &#123; sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; product.setColor(\"黄色\"); &#125; System.out.println(\"生产者在生产...\"+product.getColor() +product.getName()); // 改变商品状态（商品做好了） product.flag = true; // 通知消费者可以消费 product.notify(); &#125; i++; &#125; &#125;&#125;===================================public class ConsumeRunnable implements Runnable &#123; //private Product product = new Product(); private Product product = null; public ConsumeRunnable(Product product) &#123; this.product = product; &#125; public Product getProduct() &#123; return product; &#125; public void setProduct(Product product) &#123; this.product = product; &#125; @Override public void run() &#123; while (true)&#123; synchronized (product)&#123; //如若没有商品 ，就等待 if (!product.flag)&#123; try &#123; product.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //消费商品并输出结果 System.out.println(\"消费者在消费商品...\"+product.getColor()+product.getName()); //改变商品状态（没有商品了） product.flag = false; //通知生产者进行生产 product.notify(); &#125; &#125; &#125;&#125;===============================public class Test &#123; public static void main(String[] args) &#123; Product product = new Product(); // 创建线程对象 Runnable r1 = new ProduceRunnable(product); Thread productor = new Thread(r1); Runnable r2 = new ConsumeRunnable(product); Thread consumer = new Thread(r2); //启动线程 productor.start(); consumer.start(); &#125;&#125;=================================生产者在生产...白色馒头消费者在消费商品...白色馒头生产者在生产...黄色玉米棒消费者在消费商品...黄色玉米棒生产者在生产...白色馒头消费者在消费商品...白色馒头生产者在生产...黄色玉米棒消费者在消费商品...黄色玉米棒生产者在生产...白色馒头消费者在消费商品...白色馒头...... 程序设计 (同步方法)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class Product &#123; private String name; private String color; // 商品标志 默认为没有商品 Boolean flag = false; public Product() &#123; &#125; public Product(String name, String color) &#123; this.name = name; this.color = color; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return \"Product&#123;\" + \"name='\" + name + '\\'' + \", color='\" + color + '\\'' + '&#125;'; &#125; public synchronized void produce(String name,String color)&#123; //锁是this // 如果仓库有了商品，就等待 if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name; this.color = color; System.out.println(\"生产者在生产...\"+getColor() +getName()); // 改变商品状态（商品做好了） flag = true; // 通知消费者可以消费 notify(); &#125; public synchronized void consume()&#123; //锁是this//如若没有商品 ，就等待 if (!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //消费商品并输出结果 System.out.println(\"消费者在消费商品...\"+name+color); //改变商品状态（没有商品了） flag = false; //通知生产者进行生产 notify(); &#125;&#125;==============================public class ProduceRunnable implements Runnable &#123; //private Product product = new Product(); private Product product = null; public ProduceRunnable(Product product) &#123; this.product = product; &#125; public Product getProduct() &#123; return product; &#125; public void setProduct(Product product) &#123; this.product = product; &#125; @Override public void run() &#123; int i=0; while(true)&#123; if(i%2==0)&#123; product.produce(\"馒头\",\"白色\"); &#125;else&#123; product.produce(\"玉米棒\",\"黄色\"); &#125; i++; &#125; &#125;&#125; ============================== public class ConsumeRunnable implements Runnable &#123; //private Product product = new Product(); private Product product = null; public ConsumeRunnable(Product product) &#123; this.product = product; &#125; public Product getProduct() &#123; return product; &#125; public void setProduct(Product product) &#123; this.product = product; &#125; @Override public void run() &#123; while (true)&#123; product.consume(); &#125; &#125;&#125; ==============================生产者在生产...黄色玉米棒消费者在消费商品...玉米棒黄色生产者在生产...白色馒头消费者在消费商品...馒头白色生产者在生产...黄色玉米棒消费者在消费商品...玉米棒黄色生产者在生产...白色馒头消费者在消费商品...馒头白色生产者在生产...黄色玉米棒消费者在消费商品...玉米棒黄色 更完整的线程生命周期 3种阻塞状态的区别 sleep 和 yield 的区别 sleep 与 wait 的异同相同点：sleep和wait抛出的异常相同，都可以指定时间 线程组线程组介绍如果一个线程没有指定线程组，有 默认线程组（main） 顶级线程组：system 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 创建线程对象 Thread thread = new ThreadDemo(); System.out.println(thread.getName()); //Thread-0 System.out.println(thread.getThreadGroup().getName()); //main System.out.println(thread.getThreadGroup().getParent().getName()); //system System.out.println(thread.getThreadGroup().getParent().getParent()); //null &#125;&#125; 线程组的使用线程组作用：统一管理线程组中的线程 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) &#123; // 创建线程组group。名为 赵四线程组 ThreadGroup group = new ThreadGroup(\"赵四线程组\"); // 创建线程对象,线程名为 赵四线程 所属线程组是 group Thread thread = new ThreadDemo(group,\"赵四线程\"); Thread thread2 = new ThreadDemo(group,\"王五线程\"); System.out.println(thread.getName()); // 赵四线程 System.out.println(thread.getThreadGroup().getName()); // 赵四线程组 System.out.println(thread.getThreadGroup().getParent()); // java.lang.ThreadGroup[name=main,maxpri=10] System.out.println(thread.getThreadGroup().getParent().getName()); // main System.out.println(thread.getThreadGroup().getParent().getParent()); // system // 开启线程 thread.start(); thread2.start(); // 作用：统一管理 group.setDaemon(true); //后台线程 group.setMaxPriority(8); //最高优先级：8 // 线程组中活跃的线程数（前提：必须启动线程） System.out.println(group.activeCount()); //2 &#125;&#125; 线程池线程池概述前提 创建和销毁对象是非常耗费时间的 创建对象：需要分配内存等资源 销毁对象：垃圾回收器再后台一直跟踪并销毁（无需程序员操作） 对于经常创建和销毁对象的资源，比如并发情况下的线程，对性能的影响很大 思路：创建好多个线程（堆内存内），放入线程池中，使用时直接获取引用，不使用时放回线程池中。可以避免频繁创建销毁，实现重复利用 生活案例：共享单车 技术案例：线程池、数据库连接池 JDK1.5起，提供了【内置线程池】，我们可以【直接拿来使用】 线程池的好处 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 提高线程的可管理性：避免线程无限制创建，从而消耗系统资源，降低系统稳定性。甚至内存移除或者CPU耗尽 线程池的应用场合 需要大量的线程，并且完成任务的时间短（节省创建销毁的时间） 对性能要求苛刻 接受突发性的大量请求 线程池实例 使用线程池完成大量的没有返回值的Callable任务命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.reflect.Executable;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;// 使用线程池完成大量的没有返回值的Callable任务命令public class TestThreadPool1 &#123; public static void main(String[] args) &#123; // 创建线程池(这些线程池都有线程，直接使用即可) //创建线程池，该线程池中只有一个线程 ExecutorService pool = Executors.newSingleThreadExecutor(); //创建线程池，该线程池中线程的数量是固定的 ExecutorService pool2 = Executors.newFixedThreadPool(10); //创建线程池，该线程池中线程的数量是动态可变的 ExecutorService pool3 = Executors.newCachedThreadPool(); // 使用线程池 for (int i=0;i&lt;20;i++)&#123; int n=i; //注意JDK1.7需要加上final,1.8不用 Runnable runnable = new Runnable()&#123; @Override public void run() &#123; System.out.println(\"线程开始\"+n); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程结束\"+n); &#125; &#125;; //注意该步骤不是创建线程对象 //使用线程对象（提交一个任务到线程池中） pool.execute(runnable); //花费了60秒（线程池只有一个线程，进出20次花费60秒左右） //pool2.execute(runnable); //花费了6秒（线程池有10个线程，进出2次花费6秒左右） //pool3.execute(runnable); //花费了3秒（线程池的线程数量可变，进出1次花费3秒左右） &#125; //关闭线程池 pool.shutdown(); &#125;&#125; 使用线程池完成大量的有返回值的Callable任务命令 使用get方法时，必须得等待线程执行完毕才能得到返回值，一个3秒20个就60秒，效率很低。 因此我们需要创建了一个ArrayList 【保存每个任务的执行结果】 ，将future对象加入到集合中，在遍历时进行获得返回值，这样就不会等待线程执行完毕才能获得返回值。只要3秒效率更高 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.concurrent.*;// 使用线程池完成大量的有返回值的Callable任务命令public class TestThreadPool2 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; /** * 创建线程池(这些线程池都有线程，直接使用即可) */ //创建线程池，该线程池中线程的数量是动态可变的 ExecutorService pool = Executors.newCachedThreadPool(); /** * 使用线程池 */ List&lt;Future&gt; futureList = new ArrayList&lt;Future&gt;(); for (int i=0;i&lt;20;i++)&#123; // 创建一个任务 Callable&lt;Integer&gt; task = new MyCallable(); // 使用线程池执行该任务 执行完成后得到的结果最终会保存在 Future&lt;Integer&gt;里面 Future&lt;Integer&gt; future = pool.submit(task); /*// 得到返回值 int result = future.get(); //必须等线程执行完毕后才能得到返回值，之前再次阻塞 System.out.println(result);*/ // 加入到集合中 futureList.add(future); &#125; // 获取线程的执行结果 for (Future&lt;Integer&gt; f:futureList)&#123; int result = f.get(); System.out.print(result + “ ”); &#125; /** * 关闭线程池 */ pool.shutdown(); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; Thread.sleep(3000); return new Random().nextInt(10); //返回一个10以内的随机整数 &#125;&#125;--------------------------7 7 2 6 3 8 8 4 6 1 7 6 5 5 6 7 9 7 3 3 多线程的继承结构 线程池的参数","categories":[],"tags":[]},{"title":"数据库","slug":"数据库","date":"2019-11-25T12:23:38.000Z","updated":"2019-11-26T15:19:20.648Z","comments":true,"path":"2019/11/25/数据库/","link":"","permalink":"https://cometorbityh.github.io/2019/11/25/数据库/","excerpt":"","text":"数据库介绍 数据库 —– DataBase —– DB 什么是数据库？ 用于存储和管理数据的仓库。 数据库的特点 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 —&gt; SQL SQL什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */SQL分类 DDL ( Data Definition Language ) 数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML ( Data Manipulation Language ) 数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL ( Data Query Language ) 数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL ( Data Control Language ) 数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DQL1234567891011121314151617181920=========建表==========CREATE TABLE student (id int, -- 编号name varchar(20), -- 姓名age int, -- 年龄sex varchar(5), -- 性别address varchar(100), -- 地址math int, -- 数学english int -- 英语);INSERT INTO student(id,NAME,age,sex,address,math,english) VALUES (1,'马云',55,'男','杭州',66,78), (2,'马化腾',45,'女','深圳',98,87), (3,'马景涛',55,'男','香港',56,77), (4,'柳岩',20,'女','湖南',76,65), (5,'柳青',20,'男','湖南',86,NULL), (6,'刘德华',57,'男','香港',99,99), (7,'马德',22,'女','香港',99,99), (8,'德玛西亚',18,'男','南京',56,65); DML约束约束 —–&gt; 对表中数据进行限定，从而保证数据的正确性、有效性和完整性 (1) 非空约束（not null）定义某列的数据不能为空 1234567891011-- 创建表时添加非空约束CREATE TABLE table1( id INT, name VAECHAR(20) NOT NULL );-- 创建表后删除非空约束ALTER TABLE table1 MODIFY name VARCHAR(20);-- 创建表后添加非空约束ALTER TABLE table1 MODIFY name VARCHAR(20) NOT NULL; (2) 唯一约束（unique）注意：MYSQL中唯一约束限定的列的值可以有多个NULL 1234567891011-- 创建表时添加唯一约束CREATE TABLE table1( id INT, phone VAECHAR(20) UNIQUE );-- 创建表后删除唯一约束（也称唯一索引）ALTER TABLE table1 DROP INDEX phone;-- 创建表后添加唯一约束ALTER TABLE table1 MODIFY phone VARCHAR(20) UNIQUE; (3) 主键约束（primary key）主键 = 非空 + 唯一 一张表中只能由一个字段是主键 主键就是表中记录的唯一标识 1234567891011-- 创建表时添加主键约束CREATE TABLE STU( id INT PRIMARY KEY, name VARCHAR(20));-- 删除主键(因为一张表只有一个主键 因此不必声明具体字段名)ALTER TABLE stu DROP PRIMARY KEY;-- 创建表后添加主键ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长 某一列时数值类型的，可以使用 auto_increment 来完成自动增长，这样添加数据时可无需指定该字段 1234567891011121314151617-- 创建表时添加主键约束(自动增长)CREATE TABLE stu( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));-- 添加数据INSERT INTO stu VALUES(NULL,qqq); -- 不指定自动增长的字段INSERT INTO stu VALUES(10,sss); -- 可以自己指定自增的字段INSERT INTO stu VALUES(NULL,sss); -- 注意该条数据中自增的字段为11 与上一条插入的数据有关-- 删除自增ALTER TABLE stu MODIFY id INT;-- 创建表后添加自增ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; (4) 外键约束（foreign key）首先创建一张表，观察表中数据会发现：这个表的数据有些冗余，而且增加和删除数据都很麻烦 1234567891011121314CREATE TABLE emp (id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(30),age INT,dep_name VARCHAR(30),dep_location VARCHAR(30));-- 添加数据INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('张三', 20, '研发部', '广州');INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('李四', 21, '研发部', '广州');INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('王五', 20, '研发部', '广州');INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('老王', 20, '销售部', '深圳');INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('大王', 22, '销售部', '深圳');INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES ('小王', 18, '销售部', '深圳'); 那我们如何解决呢？这里可以把这张数据表拆分成2张表， 1234567891011121314151617181920212223-- 创建部门表（主表）create table department(id int primary key auto_increment,dep_name varchar(20),dep_location varchar(20));-- 创建员工表（从表）create table employee(id int primary key auto_increment,name varchar(20),age int,dep_id int -- 外键对应主表的主键)-- 添加数据insert into department values(null, '研发部','广州'),(null, '销售部', '深圳');INSERT INTO employee (NAME, age, dep_id) VALUES ('张三', 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('李四', 21, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('王五', 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('老王', 20, 2);INSERT INTO employee (NAME, age, dep_id) VALUES ('大王', 22, 2);INSERT INTO employee (NAME, age, dep_id) VALUES ('小王', 18, 2); 现在这2张表是好看了，但是他们之间还是没有关系啊！ 没事，我们可以使用一个外键约束来关联这2张表 创建表时添加外键约束 CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) 123456789101112131415161718192021222324-- 创建部门表（主表）create table department(id int primary key auto_increment,dep_name varchar(20),dep_location varchar(20));-- 创建员工表（从表）create table employee(id int primary key auto_increment,name varchar(20),age int,dep_id int, -- 外键对应主表的主键CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) -- 外键约束);-- 添加数据insert into department values(null, '研发部','广州'),(null, '销售部', '深圳');INSERT INTO employee (NAME, age, dep_id) VALUES ('张三', 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('李四', 21, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('王五', 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES ('老王', 20, 2);INSERT INTO employee (NAME, age, dep_id) VALUES ('大王', 22, 2);INSERT INTO employee (NAME, age, dep_id) VALUES ('小王', 18, 2); 删除外键约束 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 创建表后添加外键约束 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) (5) 级联操作级联更新当我们想修改主表的数值怎么办？由于从表的外键绑定着主表的数值，我们必须先修改从表中的数据，才能再修改主表中的数据 但是一个一个修改太麻烦了，有什么方法能够快速删除这些数据呢？ 方法1（逐表修改） 将从表中 dep_id = 1 更换成 dep_id = NULL 1UPDATE employee SET dep_id = NULL WHERE dep_id = 1; 修改主表数据，再更换从表数据 UPDATE employee SET dep_id = 4 WHERE dep_id IS NULL; 方法2（级联操作） 重新修改外键，并在其后添加ON UPDATE CASCADE 12ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk; -- 删除外键ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE; -- 重新添加外键 修改主表的数据时，从表的外键数据也会随之修改 级联删除（谨慎使用！）那么我们是否可以：删除主表的数据时，从表的相关外键数据也随之删除呢？ 重新修改外键，并在其后添加ON DELETE CASCADE 12ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk; -- 删除外键ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE ON DELETE CASCADE; -- 重新添加外键 删除主表的数据时，从表的外键数据也会随之删除（注意：是整条删除！） 数据库的设计多表之间的关系(1) 一对一 * 如：人 &lt;—–&gt; 身份证 || 一个人对应一个身份证，一个身份证对应一个人 实现方式：在任意一张表中添加唯一外键，指向另一个表的主键，但一般情况下可以合成这2张表为一张表 (2) 一对多 / 多对一 如；部门 &lt;—–&gt; 员工 || 一个部门有多个员工，一个员工对应一个部门 实现方式：在多的一方建立外键，指向多的一方的主键 (3) 多对多 如：学生 &lt;—–&gt; 课程 || 一个学生可选多门课程，一个课程可被多个学生选择 实现方式：新建中间表，中间表至少包含2个字段，这2个字段作为中间表的外键，分别指向两张表的主键 案例– 创建旅游线路分类表 tab_category – cid 旅游线路分类主键，自动增长 – cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- 创建旅游线路表 tab_route/*rid 旅游线路主键，自动增长rname 旅游线路名称非空，唯一，字符串 100price 价格rdate 上架时间，日期类型cid 外键，所属分类*/CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid));/*创建用户表 tab_useruid 用户主键，自增长username 用户名长度 100，唯一，非空password 密码长度 30，非空name 真实姓名长度 100birthday 生日sex 性别，定长字符串 1telephone 手机号，字符串 11email 邮箱，字符串长度 100*/CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100));/*创建收藏表 tab_favoriterid 旅游线路 id，外键date 收藏时间uid 用户 id，外键rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次*/CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid)); 数据库的设计准则——范式设计数据库时，需要遵循的一些规范 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式， 各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式： 第一范式（1NF）、 第二范式（2NF）、 第三范式（3NF）、 巴斯-科德 范式（BCNF）、 第四范式(4NF） 第五范式（5NF，又称完美范式）。 如果要遵循后边的范式要求，必须先遵循前边的所有范式要求 (1) 第一范式（1NF）每一列都是不可分割的原子数据项 存在的问题： 1.存在非常严重的数据冗余(重复)：姓名、系名、系主任 2.数据添加存在问题：添加新开设的系和系主任时，数据不合法 3.数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。 (2) 第二范式（2NF）​ 在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） ​ 首先要介绍几个概念： 函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A例如：学号–&gt;姓名。 （学号，课程名称） –&gt; 分数 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。例如：（学号，课程名称） –&gt; 分数 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。例如：（学号，课程名称） – &gt; 姓名 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A例如：学号–&gt;系名，系名–&gt;系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码例如：该表中码为：（学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 本例中， ​ 码属性组（学号，课程名称）， ​ 分数完全依赖于码， ​ 而姓名、系名和系主任则部分依赖于码（只需学号就可确定）； 而2NF的任务就是消除部分依赖 那么如何消除？方法就是拆分表格 依然存在的问题： ​ 2.数据添加存在问题：添加新开设的系和系主任时，数据不合法​ 3.数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。 (3) 第三范式（3NF）​ 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） ​ 本例中的传递依赖是：学号 – &gt; 系名 –&gt; 系主任 此时添加数据和删除数据就都合法了。 DQL单表查询– (1) 基础查询 SELECT FROM,DISTINCT , IFNULL, AS 查询 student 表所有字段 select * from student; 查询 NAME 和 age 两列 select NAME,age from student; 查询地址（去除重复后的结果集） select DISTINCT address from student; 计算分数之和（新列） select name, math, english,math+english from student; 若有null参与运算，则结果为null，显然不合理，这里应该用到： IFNULL（字段名，字段值）：如果字段名的默认值为null，那么该值就替换为字段值 SELECT name,math,english,math+IFNULL(english,0) FROM student; 起别名（接上例）（as 可省略） SELECT name as 姓名,math as 数学,english as 英语,math+IFNULL(english,0) as 总分 FROM student; – (2) 条件查询 WHERE，BETWEEN AND， IN，IS NULL， AND，OR，NOT 查询 age等于20 的人 SELECT name,age FROM student WHERE age=20; 查询 age不等于20 的人 SELECT name,age FROM student WHERE age!=20; SELECT name,age FROM student WHERE age&lt;&gt;20; 查询 age在[20,30] 范围的人 SELECT name,age FROM student WHERE age&gt;=20 AND age&lt;=30; SELECT name,age FROM student WHERE age BETWEEN 20 AND 30; 查询 age等于22 或 18 或 25 的人 SELECT name,age FROM student WHERE age=22 OR age=18 OR age=25; SELECT name,age FROM student WHERE age IN(18,22,25); 查询 English 缺考的人（=null）和未缺考的人 SELECT name,english FROM student WHERE english IS NULL; SELECT name,english FROM student WHERE english IS NOT NULL; LIKE （模糊查询） 占位符 _：单个任意字符%：多个任意字符 查询姓名中包含马的人 SELECT name FROM student WHERE name LIKE &#39;%马%&#39;; 查询姓名是3个字的人 SELECT name FROM student WHERE name LIKE &#39;___&#39;; – (3) 排序查询 ORDER BY ASC / DESC（默认升序） 按照 math 升序排序 SELECT name,math,english FROM student ORDER BY math asc; 按照 math 升序排序，若 math 一样，则按照 english 升序排序 SELECT name,math,english FROM student ORDER BY math asc,english asc; – (4) 计算列（聚合函数） COUNT，MAX，MIN，SUM，AVG 注意：聚合函数不计算null值 查询总人数 SELECT COUNT(name),COUNT(IFNULL(english,0)) FROM student; 查询 math 的最大值和最小值 SELECT MAX(math),MIN(math) FROM student; 查询 english 的总和 以及 english 的平均值 SELECT SUM(english),AVG(english) FROM student; – (5) 分组查询 GROUP BY，HAVING（分组之后查询的字段为：分组字段、聚合函数) where 和 having 的区别？ where 在分组之前进行限定，having 在分组之后进行限定 where后不能根聚合函数，having后可以更聚合函数 按照性别分组，查询不同性别的 english 的平均分，人数（分数低于70的人不参与分组） SELECT sex,AVG(english),COUNT(id) FROM student WHERE english&gt;70 GROUP BY sex 根据上述分组，只显示大于2人的分组 SELECT sex,AVG(english),COUNT(id) FROM student WHERE english&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2; – (6) 分页查询 LIMIT x,y —– 从 x 开始显示 y 条记录 每页显示3条记录 SELECT * FROM student LIMIT 0,3; SELECT * FROM student LIMIT 3,3; SELECT * FROM student LIMIT 6,3; 多表查询先创建2张表：部门表 + 员工表 1234567891011121314151617181920212223-- 创建部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部');-- 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键));INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1); 多表查询涉及到了笛卡尔积： 笛卡尔积 有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 多表查询的分类：内连接查询 + 外连接查询 (1) 内连接查询 使用内连接查询需要的数据： 查询哪些字段( select … ) 从哪些表中查询数据 ( from… ) 条件是什么( where… ) 隐式内连接：使用 where 条件消除无用数据 1234567891011121314151617-- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别。部门表的名称 -- 方式1 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 方式2 SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 显式内连接： 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 123-- 查询所有员工信息和对应的部门信息SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; ​ (2) 外连接查询 左外连接：查询的是左表所有数据以及其交集部分。 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接：查询的是右表所有数据以及其交集部分。 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件; 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; (3) 子查询（嵌套查询） 概念：查询中嵌套查询，称嵌套查询为子查询。 1234567891011-- 查询工资最高的员工信息# 普通方法-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于9000的SELECT * FROM emp WHERE emp.`salary` = 9000;# 子查询方法-- 一条sql就完成这个操作。子查询SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询不同情况 1. 子查询的结果是**单行单列**的：子查询可以作为条件，使用**运算符**去判断。 运算符： &gt; &gt;= &lt; &lt;= = 12-- 查询员工工资小于平均工资的人SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是**多行单列**的：子查询可以作为条件，使用**运算符in**来判断 12345-- 查询'财务部'和'市场部'所有的员工信息SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'); 3. 子查询的结果是**多行多列**的：子查询可以作为一张**虚拟表**参与查询 123456-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息-- 子查询SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2WHERE t1.id = t2.dept_id;-- 普通内连接SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; '2011-11-11';数据库的备份和还原 命令行： 语法： 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件 source 文件路径 图形化工具： 事务概念 + 步骤事务：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作步骤： 开启事务： start transaction; 回滚：rollback; 提交：commit; 先创建一张表： 1234567CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000); 模拟转账出错： 12345-- 1. 张三账户 -500UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';-- 2. 李四账户 +500（多打了一行字，导致出错，下条没执行）多打了一行字UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi'; 使用事务解决： 123456789101112131415161718-- 先恢复金额UPDATE account SET balance = 1000;-- 0. 开启事务START TRANSACTION;-- 1. 张三账户 -500UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';-- 2. 李四账户 +500（多打了一行字，导致出错）多打了一行字UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi'; -- 发现执行没有问题，提交事务COMMIT; -- 发现出问题了，回滚事务ROLLBACK; 事务提交的两种方式自动提交：一条DML(增删改)语句会自动提交一次事务。（mysql就是自动提交的） 手动提交：需要先开启事务，再提交 （若只开启事务没有提交，则下次重新打开图形界面时会恢复成之之前的数据） （上述例子就是手动提交的） MySQL数据库中事务默认自动提交，Oracle 数据库默认是手动提交事务 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit = 0; 事务的四大特征（⭐） 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别（⭐） 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在的问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted：读未提交（对方事务未提交，我方事务就可读取到修改） 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （对方事务提交后，我方事务才能读取到修改）（Oracle默认） 产生的问题：不可重复读、幻读 repeatable read：可重复读 （对方和我方事务都提交后，我方事务才能读取到修改）（MySQL默认） 产生的问题：幻读 serializable：串行化（锁表的操作，只能有一个事务在运行，相当于java的同步锁） 可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别：select @@tx_isolation; 数据库设置隔离级别：set global transaction isolation level 级别字符串;（修改隔离级别后要重启） 案例演示： 1234567891011121314-- 查询隔离级别select @@tx_isolation;-- 设置隔离级别set global transaction isolation level read uncommitted;-- 开启事务start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2;-- 事务提交commit;-- 事务回滚rollback;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cometorbityh.github.io/categories/数据库/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://cometorbityh.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"https://cometorbityh.github.io/tags/数据库/"}]},{"title":"JAVA 集合：Collections","slug":"JAVA-集合：Collections","date":"2019-11-24T15:48:11.000Z","updated":"2019-11-24T16:03:44.653Z","comments":true,"path":"2019/11/24/JAVA-集合：Collections/","link":"","permalink":"https://cometorbityh.github.io/2019/11/24/JAVA-集合：Collections/","excerpt":"","text":"Collections123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"AAA\"); list.add(\"DDD\"); // addAll()后面可跟可变参数 Collections.addAll(list,\"CCC\",\"BBB\"); System.out.println(list); // 二分查找 int index = Collections.binarySearch(list, \"BBB\"); System.out.println(index); // 打乱 Collections.shuffle(list); System.out.println(list); int index1 = Collections.binarySearch(list, \"BBB\"); System.out.println(index1); // 反转 Collections.reverse(list); System.out.println(list); int index2 = Collections.binarySearch(list, \"BBB\"); System.out.println(index2); // 排序 Collections.sort(list); System.out.println(list); int index3 = Collections.binarySearch(list, \"BBB\"); System.out.println(index3); &#125;---------------------------------------------[AAA, DDD, CCC, BBB][DDD, CCC, AAA, BBB][BBB, AAA, CCC, DDD][AAA, BBB, CCC, DDD]","categories":[],"tags":[]},{"title":"IDEA 快捷键：逐步更新","slug":"IDEA-快捷键：逐步更新","date":"2019-11-23T06:29:39.000Z","updated":"2019-11-23T06:57:16.773Z","comments":true,"path":"2019/11/23/IDEA-快捷键：逐步更新/","link":"","permalink":"https://cometorbityh.github.io/2019/11/23/IDEA-快捷键：逐步更新/","excerpt":"","text":"191123 查看源码的继承关系：Ctrl+H随意进入源码的一个类，按住Ctrl+H可以查看该类的继承关系 查看类的所有方法：Alt + 7","categories":[],"tags":[]},{"title":"JAVA 集合：Map接口概述","slug":"JAVA-集合：Map接口概述","date":"2019-11-23T06:17:08.000Z","updated":"2019-11-24T14:49:20.711Z","comments":true,"path":"2019/11/23/JAVA-集合：Map接口概述/","link":"","permalink":"https://cometorbityh.github.io/2019/11/23/JAVA-集合：Map接口概述/","excerpt":"","text":"Map接口java.util.Map 按照&lt;键，值&gt;对的形式存储数据，是双列集合 如身份证（&lt;身份证号，名字&gt;），QQ（&lt;QQ号，网名&gt;）这种一一对应的关系，称为“映射” Map就是用来存储这种映射对象的集合。 HashMap的key无法重复，但是可以为null Map接口的继承体系 Map接口的常用方法由于Map是一个接口，因此我们使用HashMap类来测试Map接口的常用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.young.map;public class Person &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Person() &#123; &#125; public Person(Integer id, String name) &#123; this.id = id; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Person)) return false; Person person = (Person) o; if (id != null ? !id.equals(person.id) : person.id != null) return false; return name != null ? name.equals(person.name) : person.name == null; &#125; @Override public int hashCode() &#123; int result = id != null ? id.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.young.map;import java.util.*;public class MapDemo &#123; public static void main(String[] args) &#123; Map&lt;String,Person&gt; persons = new HashMap&lt;String,Person&gt;(); persons.put(\"01\",new Person(01,\"刘备\")); persons.put(\"02\",new Person(02,\"关羽\")); persons.put(\"03\",new Person(03,\"张飞\")); persons.put(\"04\",new Person(01,\"赵云\")); persons.put(\"04\",new Person(01,\"诸葛\")); System.out.println(persons.size()); // 4 Person p04 = persons.get(\"04\"); System.out.println(p04); // Person&#123;id=1, name='诸葛'&#125; System.out.println(\"移除：\"+persons.remove(\"04\").getName()); // 移除：诸葛 System.out.println(persons.size()); // 3 //persons.clear(); //System.out.println(persons.size()); // o String num = \"01\"; if(persons.containsKey(num))&#123; System.out.println(persons.get(num).getName()+ \"已存在！\"); //刘备已存在！ &#125;else&#123; System.out.println(persons.get(num).getName()+ \"不存在！\"); &#125; /* 原本是根据equals和hashCode方法同时相等才算相等 * 但这不符合现实的规则，因此我们重写了这2个方法 * 使得只要对象内容一样就算一致！*/ if(persons.containsValue(new Person(02,\"关羽\")))&#123; System.out.println(\"存在！\"); // 存在！ &#125;else&#123; System.out.println(\"不存在！\"); &#125; /*--------------------------------------------*/ Set&lt;String&gt; keys = persons.keySet(); // 迭代key for(String key:keys)&#123; System.out.printf(\"%s %s \", key, persons.get(key).getName()); //01 刘备 02 关羽 03 张飞 &#125; System.out.println(); //迭代key（迭代器） Iterator&lt;String&gt; iterator = keys.iterator(); while(iterator.hasNext())&#123; String key = iterator.next(); String name = persons.get(key).getName(); System.out.printf(\"%s %s \", key, name); //01 刘备 02 关羽 03 张飞 &#125; //迭代value Collection&lt;Person&gt; values = persons.values(); for (Person p:values)&#123; System.out.print(p + \" \"); // Person&#123;id=1, name='刘备'&#125; Person&#123;id=2, name='关羽'&#125; Person&#123;id=3, name='张飞'&#125; &#125; System.out.println(); Set&lt;Map.Entry&lt;String, Person&gt;&gt; entries = persons.entrySet(); //迭代 Entry&lt;key,value&gt; for (Map.Entry&lt;String, Person&gt; entry:entries)&#123; String key = entry.getKey(); Person value = entry.getValue(); System.out.printf(\"%s---%s \",key,value); // 01---Person&#123;id=1, name='刘备'&#125; 02---Person&#123;id=2, name='关羽'&#125; 03---Person&#123;id=3, name='张飞'&#125; &#125; System.out.println(); //迭代 Entry&lt;key,value&gt;（迭代器） Iterator&lt;Map.Entry&lt;String, Person&gt;&gt; iterator1 = entries.iterator(); while(iterator1.hasNext())&#123; Map.Entry&lt;String, Person&gt; ent = iterator1.next(); String key = ent.getKey(); Person value = ent.getValue(); System.out.printf(\"%s---%s \",key,value); // 01---Person&#123;id=1, name='刘备'&#125; 02---Person&#123;id=2, name='关羽'&#125; 03---Person&#123;id=3, name='张飞'&#125; &#125; &#125;&#125; HashMapHashMap是Map接口的子类 Hash：音译为哈希，实际翻译为散列，杂凑 Hash算法可将一个数据转换成一个标志，该标志和原数据的每个字节都有十分紧密的关系 Hash算法很难找到逆向规律 Hash算法没有一个固定的公式，只要符合散列思想的算法都可以称为Hash算法 典型的Hash算法：MD5 SHA-1 Hash碰撞（hash冲突） Hash算法可以算出几乎唯一的hashCode，若出现重复的hashCode，则称之为 “哈希碰撞” 或 “哈希冲突” HashMap的数据结构 底层：散列表（哈希表），是基于快速存取的角度设计的，也是一种典型的“空间换时间”的做法。 源码分析在线HashMap图解操作： https://www.cs.usfca.edu/~galles/visualization/OpenHash.html 构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 空参构造方法public HashMap() &#123; // 负载因子赋值 0.75f this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;//自定义容量的构造方法public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; //自定义容量&lt;0 抛异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // 自定义容量 &gt; 最大容量(2^30) if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 负载因子&lt;0 或 负载因子为空 抛异常 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; // 把传入的自定义容量强行转化为2^n-1 this.threshold = tableSizeFor(initialCapacity);&#125;// 把传入的自定义容量强行转化为2^n-1static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; //传入的集合大小 int s = m.size(); if (s &gt; 0) &#123; //判断Node&lt;K,V&gt;[] table 即线性表数组是否为null if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125;/* 获取key的hash值 */static final int hash(Object key) &#123; int h; // key的hash值 异或 key的hash值的高16位 //目的：提高hashcode的随机性 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;例如：某个key对象的hashcode为 1101 1001，数组容量为16，最大下标为15（0000 1111），真实实例为32位，此处仅用8位来举例 1101 1001 hash值 0000 1101 hash值右移四位 ---------- 异或（^） ----&gt; key的hash值 1101 0100 0000 1111 数组大小-1（16-1）---------- 与（&amp;） ----&gt; 该node最终存储在数组的位置 0000 0100 最终存储的位置 put 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;/* table:当前的数组（全局变量） tab：当前的数组（局部变量）*/final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 若table数组为空 或 长度为0 if ((tab = table) == null || (n = tab.length) == 0) // 初始化table，并且获取数组长度n n = (tab = resize()).length; // 用hash和（数组长度-1）进行与运算（本质就是取余运算），算出put的数据应该插在数组的哪个位置 // 那为什么不直接用取余？ 因为与运算的速度更快，因此使用与运算的目的就是优化计算速度 // 若p=tab[i]为空，即p链表为null if ((p = tab[i = (n - 1) &amp; hash]) == null) // 将put进来的数据放到tab[i]中 tab[i] = newNode(hash, key, value, null); // 若p=tab[i]不为空，就是数组上该位置有元素了 else &#123; Node&lt;K,V&gt; e; K k; // 若tab[i]上的元素和put进来的hash值和键都相等（2个对象指向的地址一致，但是值不同） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 把p=tab[i]的值保存在e中，等待旧值换成新值 e = p; // 若p=tab[i]是树节点 else if (p instanceof TreeNode) // 调用红黑树的插入逻辑 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 若是链表插入元素 else &#123; for (int binCount = 0; ; ++binCount) &#123; // 若p=tab[i]指向的下一个元素e为null if ((e = p.next) == null) &#123; // p=tab[i]的下一个元素就是put进来的数据 p.next = newNode(hash, key, value, null); // 若当前链表节点的数量&gt; 树结构的阈值（默认8） if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //树化：转换成红黑树结构（红黑树可以优化查询性能） treeifyBin(tab, hash); break; &#125; // 若当前链表包含要插入的值e=p.next，结束遍历，等待新值覆盖旧值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //p=tab[i+1]，为了遍历 p = e; &#125; &#125; // 判断插入的值是否存在hashmap中，若是则替换成新值 if (e != null) &#123; // existing mapping for key // 保存e的旧值 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) // 将e的旧值替换为新值（覆盖） e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //修改次数+1 ++modCount; //若当前数组大小 &gt; 阈值 if (++size &gt; threshold) //扩容 resize(); afterNodeInsertion(evict); return null; &#125; 是拿size的大小和threshold进行比较来决定是否需要扩容 loadFactor负载因子是可以大于1的，因为构造函数没有限制，而且从结构上看size的大小是可以大于数组长度的（由于树节点和链表节点的存在）。 扩容：resize() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126final Node&lt;K,V&gt;[] resize() &#123; //旧数组 Node&lt;K,V&gt;[] oldTab = table; //旧数组容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; // newCap：初始化新数组的容量 // newThr：初始化新数组的阈值 int newCap, newThr = 0; /*--------------------1.新容量和阀值的计算---------------------*/ /* 使用不同的构造方法初始化数组时，其容量和阈值不相同，因此以下对不同的情况进行初始化 */ // 情况1：若旧数组有容量 if (oldCap &gt; 0) &#123; // 当容量达到最大值时，无法扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 当新容量（2倍旧容量）&lt; 最大容量 并且 旧容量 &gt;= 默认容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 新阈值 = 2 * 旧阈值 newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 情况2：若旧阈值 &gt; 0 （使用自定义容量的构造方法创建的数组的初始化） else if (oldThr &gt; 0) // initial capacity was placed in threshold //新容量 = 旧阈值 newCap = oldThr; // 情况3：若旧数组无容量（使用无参构造方法创建的数组的初始化） else &#123; // zero initial threshold signifies using defaults // 初始化新容量 = 16 newCap = DEFAULT_INITIAL_CAPACITY; // 初始化新阈值 = 负载因子 * 初始容量 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 当新阈值为0时给新阈值赋值（上述情况2没有新阈值） if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // threshold就是新阈值 threshold = newThr; /*--------------------2.扩容---------------------*/ /* 对数组进行扩容，扩容时注意： 由于元素位置时有hashcode计算得出的，当数组长度发生变化时， 各个元素的位置也可能随机发生变化，因此要重新对元素进行定位 */ @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) //创建一个新数组，长度为新容量 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //重新对元素位置进行定位 if (oldTab != null) &#123; //遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 若旧数组的该位置上有数据，先保存在e中，再将旧数组的该位置进行清空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 当该元素的next指针没有值时（没有指向下一个） if (e.next == null) // 重新计算位置，位置下标为 ：旧数组元素的hash值 &amp; (新数组容量-1) newTab[e.hash &amp; (newCap - 1)] = e; // 当该元素的next指针有值时（指向了树节点，e本身也是树节点） else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 当该元素的next指针有值时（指向链表的下一个元素） else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 遍历链表 将链表节点按照顺序进行分组（2组） do &#123; next = e.next; // 如果原有元素再扩容后，还在原位置 if ((e.hash &amp; oldCap) == 0) &#123; //旧链表数据添加在一组 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 如果原有元素再扩容后，不在原位置（位置发生变化，放在其他位置了） else &#123; //新链表数据添加在一组 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //把还在以前位置的元素链起来 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //把不再以前位置的元素放在新的位置 if (hiTail != null) &#123; hiTail.next = null; //新的位置 = 原位置J + 原容量 newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; //返回扩容后的数组 return newTab; &#125; 删除：remove（） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 如果存在key则删除并返回value，如果不存在则返回nullpublic V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;// 删除指定key并返回nodefinal Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 当前数组不能为空 &amp;&amp; 数组长度不能为0 &amp;&amp; 要删除的元素不能为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // hash没有冲突时（就在数组上，单个元素的桶节点） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // hash有冲突时（不只是1个元素在同一位置，在链表或红黑树上） else if ((e = p.next) != null) &#123; // 如果该节点是树的桶节点 if (p instanceof TreeNode) // 定位要删除的元素 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 如果该节点是链表 else &#123; do &#123; // 遍历下一个链表节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; // 定位要删除的元素 node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 拿到要删除的元素node if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 如果node是树的桶节点，删除该节点，并调整红黑树使得保持平衡 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // node在数组上（单个元素的桶节点） else if (node == p) tab[index] = node.next; // node在链表上（使数组上的元素指向 被删除节点的下一个元素） else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; remove方法删除键值对并不会将数组的大小缩小，按照不同类型的待删除的节点有不同的处理方式： 单元素桶节点：则将当前桶节点设置为null。 链表的桶节点：则断开被删除的键值对节点，然后重新连接 红黑树桶节点：删除键值对节点并调整树结构保持平衡，如果有必要则将红黑树缩减为链表 找到几篇文章，写的很好! https://blog.csdn.net/zjxxyz123/article/details/81111627 https://www.jianshu.com/p/e826d38d04d8 https://www.toutiao.com/i6693789706628366862/ LinkedHashMap LinkedHashMap 继承自HashMap，是基于 HashMap 和双向链表来实现的 HashMap 有一个不足之处就是在迭代元素时与插入顺序不一致。而大多数人都喜欢按顺序做某些事情，所以，LinkedHashMap 就是针对这一点对 HashMap 进行扩展，主要新增了「两种迭代方式」： 按插入顺序 - 保证迭代元素的顺序与插入顺序一致 按访问顺序 - 一种特殊的迭代顺序，从最近最少访问到最多访问的元素访问顺序，非常适合构建 LRU 缓存 HashMap 无序 而 LinkedHashMap 有序，可分为插入顺序（有序）和访问顺序两种 LinkedHashMap 存取数据，还是和HashMap一样使用Entry方式，双向链表只是为了保证顺序 LinkedHashMap 是线性不安全的 底层：双向链表 ​ 访问顺序：当访问一个链表的某个元素时，该元素会被移动到链表的最前面（置顶），这样子循环下去，排位越靠前的访问次数越多，越靠后的访问次数越少。这种思路也被称为“最近最少访问（LRU）” 作用领域：缓存，假定该缓存规定每条链表只能拥有10个元素，其中有1条有12个元素，那么根据排序来看，前面的元素都是最近访问的，越靠后的访问次数就越少，那被删除的这2条就是没有经常访问的了，价值不大，因此LinkedHashMap非常适用于缓存。 TreeMap 没有继承自HashMap 底层：红黑树 TreeMap的元素默认按照key的自然顺序进行排序 使用TreeMap的前提 key的类实现了Comparable接口 Integer：数组升序，实现了Comparable接口 String：按照字母表排序。实现了Comparable接口 若key的类没有实现Comparable接口，那么需要使用Comparator比较器 若即实现了Comparable接口，又使用Comparator，则Comparator的优先级更高 Set接口特点：无序 不可重复 通过阅读源码： HashSet底层实现就是HashMap的key集合 LinkedHashSet底层实现就是LinkedHashMap的key集合 TreeSet底层实现就是TreeMap的key集合 HashSet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 案例：消除重复元素 注意：必须重写 equals()、hashcode()，否则无法比较2个对象相同*/public class SetDemo &#123; public static void main(String[] args) &#123; List&lt;Book&gt; list = new ArrayList&lt;Book&gt;(); list.add(new Book(1001,\"java\",13)); list.add(new Book(1001,\"java\",13)); list.add(new Book(1002,\"java\",13)); list.add(new Book(1003,\"java\",13)); list.add(new Book(1003,\"java\",13)); System.out.println(list.size()); for(Book book:list)&#123; System.out.println(book); &#125; Set&lt;Book&gt; books = getBooks(list); System.out.println(books.size()); for(Book book:books)&#123; System.out.println(book); &#125; &#125; // 定义一个方法清除重复元素，返回一个没有重复元素元素的集合对象 public static Set&lt;Book&gt; getBooks(List&lt;Book&gt; list)&#123; if (list == null) &#123; throw new IllegalArgumentException(\"list is null!\"); &#125; Set&lt;Book&gt; set = new HashSet&lt;&gt;(list); return set; &#125;&#125;public class Book &#123; private Integer id; private String name; private Integer price; // 构造方法（有参、无参） // getter、setter // 重写 equals()、hashcode()、toString()&#125;-----------------------5Book&#123;id=1001, name='java', price=13&#125;Book&#123;id=1001, name='java', price=13&#125;Book&#123;id=1002, name='java', price=13&#125;Book&#123;id=1003, name='java', price=13&#125;Book&#123;id=1003, name='java', price=13&#125;3Book&#123;id=1003, name='java', price=13&#125;Book&#123;id=1001, name='java', price=13&#125;Book&#123;id=1002, name='java', price=13&#125; TreeSet底层：TreeMap 的 key 集合 特点：TreeSet 的元素默认按照 key 的自然顺序进行排序，不可重复 使用TreeSet的前提 key 的类实现了 Comparable 接口 Integer：数组升序，实现了 Comparable 接口 String：按照字母表排序。实现了 Comparable 接口 若 key 的类没有实现 Comparable 接口，那么需要使用 Comparator 比较器 若即实现了 Comparable 接口，又使用 Comparator，则 Comparator 的优先级更高 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 方法1：通过实现Comparable接口，并重写compareTo方法*/public class Emp implements Comparable&lt;Emp&gt; &#123; private Integer id; private String name; private Integer salary; // 构造方法（有参、无参） // getter、setter // 重写 equals()、hashcode()、toString() @Override public int compareTo(Emp o) &#123; return (int)this.salary - o.salary; &#125;&#125;public static void main(String[] args) &#123; TreeSet&lt;Emp&gt; emps = new TreeSet&lt;&gt;(); emps.add(new Emp(1001,\"AAA\",4000)); emps.add(new Emp(1002,\"BBB\",2900)); emps.add(new Emp(1003,\"CCC\",3800)); emps.add(new Emp(1004,\"DDD\",4500)); emps.add(new Emp(1005,\"EEE\",2800)); emps.add(new Emp(1006,\"FFF\",5000)); for (Emp emp:emps)&#123; System.out.println(emp); &#125;&#125;----------------------------------------------Emp&#123;id=1005, name='EEE', salary=2800&#125;Emp&#123;id=1002, name='BBB', salary=2900&#125;Emp&#123;id=1003, name='CCC', salary=3800&#125;Emp&#123;id=1001, name='AAA', salary=4000&#125;Emp&#123;id=1004, name='DDD', salary=4500&#125;Emp&#123;id=1006, name='FFF', salary=5000&#125;/* 方法2：通过新建Comparator对象，并重写compare方法*/public static void main(String[] args) &#123; TreeSet&lt;Emp&gt; emps = new TreeSet&lt;Emp&gt;(new Comparator&lt;Emp&gt;() &#123; @Override public int compare(Emp o1, Emp o2) &#123; // 降序 return (int)o2.getSalary()-o1.getSalary(); &#125; &#125;); emps.add(new Emp(1001,\"AAA\",4000)); emps.add(new Emp(1002,\"BBB\",2900)); emps.add(new Emp(1003,\"CCC\",3800)); emps.add(new Emp(1004,\"DDD\",4500)); emps.add(new Emp(1005,\"EEE\",2800)); emps.add(new Emp(1006,\"FFF\",5000)); for (Emp emp:emps)&#123; System.out.println(emp); &#125;&#125;----------------------------------------------Emp&#123;id=1006, name='FFF', salary=5000&#125;Emp&#123;id=1004, name='DDD', salary=4500&#125;Emp&#123;id=1001, name='AAA', salary=4000&#125;Emp&#123;id=1003, name='CCC', salary=3800&#125;Emp&#123;id=1002, name='BBB', salary=2900&#125;Emp&#123;id=1005, name='EEE', salary=2800&#125;","categories":[],"tags":[]},{"title":"JAVA 数据结构：栈+队列+数组+链表","slug":"JAVA-数据结构：栈-队列-数组-链表","date":"2019-11-22T09:20:10.000Z","updated":"2019-11-23T06:15:05.487Z","comments":true,"path":"2019/11/22/JAVA-数据结构：栈-队列-数组-链表/","link":"","permalink":"https://cometorbityh.github.io/2019/11/22/JAVA-数据结构：栈-队列-数组-链表/","excerpt":"","text":"数据结构计算机存储、组织数据的方式 数据结构可以编写出更优雅、更有效率的代码S 栈（Stack）特点：后进先出（弹夹、书箱） 查看源码，Stack类继承Vector，而Vector的底层是线程安全的数组。因此推断出Stack的底层也是数组 1class Stack&lt;E&gt; extends Vector&lt;E&gt;&#123;&#125; 入栈出栈操作123456789101112131415161718public class demo1 &#123; public static void main(String[] args) &#123; // 创建一个栈对象（后进先出） Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 压栈操作 push() stack.push(\"刘备\"); stack.push(\"关羽\"); stack.push(\"张飞\"); System.out.println(stack); // [刘备, 关羽, 张飞] //弹栈操作 pop() String s1 = stack.pop(); System.out.println(s1); //张飞 System.out.println(stack); // [刘备, 关羽] stack.pop(); stack.pop(); stack.pop(); //EmptyStackException,空栈异常 &#125;&#125; 队列（Queue）特点：先进先出 123456789101112131415public class demo1 &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.add(\"刘备\"); queue.add(\"关羽\"); queue.add(\"张飞\"); System.out.println(queue); String pop = queue.pop(); System.out.println(pop); queue.pop(); queue.pop(); queue.pop(); //NoSuchElementException &#125;&#125; 数组（Array）数组是有序的元素队列，是在内存中开辟了一段连续的空间，在此段空间存放元素 特点：长度固定，查询快，增删慢 为什么增删慢？ 因为数组是一个固定的长度，增加和删除的话，都要重新创建一个新数组，并将旧数组中还保留的元素都复制到新数组，还要考虑删除或增加中间元素时，后面元素都要往前挪或往后挪，之后垃圾系统会回收旧数组，因此数组增删元素效率很低。 稀疏数组链表 LinkedListsize() isEmpty() clear add(E e) add(int index,E e) E get(int index) remove(int index) 编写思路构建类LinkedList（底层：双向链表（Node）） 构造器（无参） 属性：size 内部类Node Node prev E e(data) Node next 声明第一节点（Node first) 声明最后节点（Node last） size():return size isEmpty()：return size==0 clear()：从头到尾遍历， 保存遍历节点 释放节点资源 node.prev=null; node.e=null; node.next=null; 通过保存节点找到下个节点 node=oldNode.next size置为0 first=null,last=null E get(int index) 判断index是否在范围内 ​ checkElementIndex(index) ​ index&gt;0&amp;&amp;index&lt;size（合理） ​ index&lt;0||index》=size（不合理） ​ 假如不可理抛异常 查找节点 Node node = node(index) 二分查找思路： index&lt;&lt;(Size-1) Node node = first(从左到右) for(int i=0;i&lt;index;i++){ node = node.next} Node node = last（从右到左） for(inr i=size-1;i&gt;index;i–){ node=node.prev} return node boolean add(E e):默认时添加到链表尾部 linkLast 将变量保存临时list–f 构建新节点，等着被添加 ​ Node newNode = new Node(last,e,null) 判断f是否为null ​ 若f为null,newNode就要作为第一个节点 first = newNode ​ 若f不为null last.next=newNode;newNode作为最后节点 last = newNode size++ return true add(int index,E e) 检测该下标能否被添加 index&gt;0 &amp;&amp; index&lt;=size index&lt;0 || index&gt;size 找到需要添加节点·下标 添加有3种情况 添加到末尾 if(index==size){linkLast(index)} else{ ​ 找到需要添加的节点下标 ​ Node node = node(index) ​ linkBefore(index,node) ​ Node pre = node.prev //前一个节点 ​ Node next = node.next //后一个节点 ​ Node newNode = Node(prev,e,next) //创建新节点 node.prev = newNode；找到的节点的前一个添加新节点 ​ if(prev == null){ //要添加到第一个节点（即头节点指向的节点） ​ first = newNode ​ } else{prev.next = newNode} } E remove(int index) 检测下标 找到需要删除的节点 ​ Node node = node(index) ​ Node prev = node.prev’ Node next = node.next if(prev==null) //要删除的节点是第一个 {first=next} //第二个就变成第一个 else{prev.next=next;node.prev = null } //前一个节点denext指针指向类删除的节点的下一个,并且清空被删除节点的prev if(next==null) //要删除的节点是最后一个 {last = prev; } //前一个就变成最后一个 else{next.prev=prev;node.next =null} //… node.e=null size–; return e; 有错误，等待订正！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219public class LinkedListDemo&lt;E&gt; &#123; private int size; //链表长度 private Node&lt;E&gt; first; //链表首节点 private Node&lt;E&gt; last; //链表尾节点 //构造方法 public LinkedListDemo()&#123; &#125; //内部类 Node private class Node&lt;E&gt;&#123; Node&lt;E&gt; prev; E e; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev, E e, Node&lt;E&gt; next) &#123; this.prev = prev; this.next = next; this.e = e; &#125; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; if(size==0)&#123; return true; &#125; return false; &#125; public void clear()&#123; for(Node&lt;E&gt; node=first;node!=null;)&#123; Node&lt;E&gt; nd = node; node.prev =null; node.e = null; node.next =null; node = nd.next; &#125; first = null; last = null; size=0; &#125; public E get(int index)&#123; //检查下标范围是否合法 checkElementIndex(index); //找到该下标所对应的节点 return node(index).e; &#125; // 找到下标对应节点 public Node&lt;E&gt; node(int index)&#123; //使用二分法遍历 if(index&lt;(size&gt;&gt;1))&#123; Node&lt;E&gt; node=first; for(int i=0;i&lt;index;i++)&#123; node = node.next; &#125; return node; &#125;else&#123; Node&lt;E&gt; node = last; for(int i=size-1;i&gt;index;i--)&#123; node=node.prev; &#125; return node; &#125; &#125; //检查下标 private void checkElementIndex(int index) &#123; if(!isExistIndex(index))&#123;throw new IndexOutOfBoundsException(\"下标不存在！\");&#125; &#125; //下标是否存在 private boolean isExistIndex(int index) &#123; return index &gt;=0 &amp;&amp; index &lt;size; &#125; //添加结点（默认添加到最后） public boolean add(E e)&#123; listLast(e); return true; &#125; //添加元素到链表最后 private void listLast(E e) &#123; //线保存原来最后一个结点的信息 Node&lt;E&gt; f = last; Node&lt;E&gt; newNode =new Node&lt;E&gt;(last,e,null); //创建新结点 if(f==null)&#123; //如果last是空的 first = newNode; //那么这个新节点就是第一个 &#125;else&#123; last.next= newNode; //原本链表的next指针指向新结点 &#125; last = newNode; //现在新结点就是最后一个结点 size++; //结点长度加一 &#125; public void add(int index,E e)&#123; //检查下标是否存在 checkPositionIndex(index); //判断添加的位置 if(index==size)&#123; //添加到尾部 listLast(e); &#125;else&#123; //添加到非尾部 Node&lt;E&gt; node = node(index); //查找到下标对应的结点 linkBefore(e,node); //添加到该节点之前 &#125; &#125; private void linkBefore(E e,Node&lt;E&gt; node) &#123; Node&lt;E&gt; prev = node.prev; //该结点的前一个 Node&lt;E&gt; next = node.next; //该结点的前一个 //创建要添加进来的新结点 Node&lt;E&gt; newNode = new Node&lt;E&gt;(prev,e,node); if(prev==null)&#123; //如果该结点时第一个 first=newNode; //那么新结点就是第一个 &#125;else &#123; //该节点不是第一个 prev.next=newNode; //那么前一个结点的next指针指向新结点 &#125; node.prev=newNode; size++; &#125; public E remove(int index)&#123; //检测下标是否存在 checkElementIndex(index); Node&lt;E&gt; node = node(index); //要删除的结点 Node prev = node.prev; //前一个结点 E e = node.e; Node next = node.next; //后一个结点 if(prev==null)&#123; //如果要清除的是第一个结点 first = next; //那第二个结点就编程第一个 &#125;else&#123; prev.next = next; node.prev =null; //清空该结点的prev指针 &#125; if(next ==null)&#123; //如果要清除的是最后一个结点 last = prev; &#125;else &#123; next.prev = prev; node.next = null; //清空该结点的next指针 &#125; node.e = null; //清空该结点的值 size--; return e; &#125; private void checkPositionIndex(int index) &#123; if(!isPositionIndex(index))&#123; throw new IndexOutOfBoundsException(\"下标不存在！\"); &#125; &#125; private boolean isPositionIndex(int index) &#123; return index&gt;=0 &amp;&amp; index&lt;=size; &#125;&#125;--------------------------------------------------public class test &#123; public static void main(String[] args) &#123; LinkedListDemo&lt;String&gt; l1 = new LinkedListDemo&lt;String&gt;(); l1.add(\"张三\"); l1.add(\"李四\"); l1.add(\"王五\"); System.out.println(l1.size()); for(int i=0;i&lt;l1.size();i++)&#123; System.out.print(l1.get(i)+ \" \"); &#125; System.out.println(); l1.add(2,\"赵玉\"); System.out.println(l1.size()); for(int i=0;i&lt;l1.size();i++)&#123; System.out.print(l1.get(i)+ \" \"); &#125; System.out.println(); l1.remove(3); System.out.println(l1.size()); for(int i=0;i&lt;l1.size();i++)&#123; System.out.print(l1.get(i)+ \" \"); &#125; System.out.println(); l1.clear(); System.out.println(l1.size()); &#125;&#125;--------------------------------------------------3张三 李四 王五 4张三 李四 赵玉 王五 3张三 李四 赵玉 0","categories":[],"tags":[]},{"title":"JAVA 集合-1","slug":"JAVA-集合-1","date":"2019-11-20T13:42:57.000Z","updated":"2019-11-24T15:12:44.662Z","comments":true,"path":"2019/11/20/JAVA-集合-1/","link":"","permalink":"https://cometorbityh.github.io/2019/11/20/JAVA-集合-1/","excerpt":"","text":"集合概述 简介集合——用来存储引用类型数据的容器，只能存储对象。 所有集合类都位于 java.util 包下，但支持多线程的集合类位于 java.util.concurrent 包下 分类 Collection集合（单列集合）：存储数据时单个存储 Map集合（双列集合）：存储数据时按键值对形式存储 集合与数组的区别与联系 数组长度固定，集合长度可变 数组元素可以是基本类型，也可以是对象，集合只能保存对象 集合底层是数组 集合框架 Java 集合类主要由两个根接口 Collection 和 Map 派生出来的，Collection 派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此 Java 集合大致也可分成 List、Set、Queue、Map 四种接口体系，（注意： Map 不是 Collection 的子接口）。 其中 List 代表了有序可重复集合，可直接根据元素的索引来访问； Set 代表无序不可重复集合，只能根据元素本身来访问； Queue 是队列集合； Map代表的是存储 key-value 对的集合，可根据元素的 key 来访问 value 。 图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。 Collection接口Collection 是一个接口，因此无法直接创建对象，所以使用它的实现类 ArrayList 来创建对象，进而用来举例。 常用方法（掌握10个）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static void main(String[] args) &#123; Collection&lt;String&gt; container = new ArrayList&lt;String&gt;(); Collection&lt;String&gt; container2 = new ArrayList&lt;String&gt;(); // add() remove() size() contains() container.add(\"东邪\"); container.add(\"西毒\"); container.add(\"南帝\"); container.add(\"北丐\"); container.add(\"中神通\"); System.out.println(container); // [东邪, 西毒, 南帝, 北丐, 中神通] container.remove(\"西毒\"); System.out.println(container); // [东邪, 南帝, 北丐, 中神通] System.out.println(container.size()); // 4 System.out.println(container.contains(\"西毒\")); // false container2.add(\"AAA\"); container2.add(\"BBB\"); // addAll() removeAll() containsAll() container.addAll(container2); System.out.println(container); //[东邪, 南帝, 北丐, 中神通, AAA, BBB] System.out.println(container.containsAll(container2)); //true container.removeAll(container2); System.out.println(container); //[东邪, 南帝, 北丐, 中神通] System.out.println(container.containsAll(container2)); //false // clear() isEmpty() container.clear(); System.out.println(container.isEmpty()); //true // 将集合转为数组，并遍历 // (1) 普通for循环 for (String c : container2)&#123; System.out.print(c + \" \"); //AAA BBB &#125; Object[] objects = container2.toArray(); for (int i=0;i&lt;objects.length;i++)&#123; System.out.print(objects[i] + \" \"); //AAA BBB &#125; // (2) 增强for循环 for (Object obj:objects)&#123; System.out.print(obj + \" \"); //AAA BBB &#125; // (3) 迭代器遍历 Iterator&lt;String&gt; ite = container2.iterator(); while (ite.hasNext())&#123; String next = ite.next(); if(\"BBB\".equals(next))&#123; ite.remove(); //删除BBB &#125; &#125; System.out.println(container2); //[AAA]&#125; 进阶方法（）⭐迭代器 Iterator 原理简介在上面代码中，遍历集合元素用到了迭代器。 Iterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合和数组中的元素。 注意：Iterator只能单向移动 。 1Iterator&lt;E&gt; iterator(); //Collection接口的iterator方法 方法 介绍 hasNext( ) 如果迭代器中还有元素，则返回 true next( ) 返回迭代器中的下一个元素 remove( ) 删除集合里上一次 next 方法返回的元素 集合与泛型前面发现，创建集合对象时加入了泛型，为什么需要泛型？我们先来看个例子： 12345678910111213List list = new ArrayList();list.add(\"My is none T\");list.add(100);for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); //取出Integer时，运行时出现异常，因此类型不安全 System.out.println(\"name:\" + name)；&#125; 如果不加泛型，List默认是Object，所以加一个String和Integer值是合法的，但是在取数据用的时候，忽略之前的兼容，会出现ClassCastException。 Collection 虽然可以存储各种对象，但是通常只存储同一类型的对象，例如String 因此在KDK5之后，加入了泛型，使我们在设计方法或类时支持泛型，在编译期进行语法检查，运行时擦除泛型 泛型是什么？泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 将数据类型作为参数进行传递，应用到方法、类或接口上。 泛型的好处 泛型的主要目标是提高 Java 程序的类型安全。 消除强制类型转换。避免类型转换的麻烦。储存的是什么类型，取出的就是什么类型 将运行期异常（ClassCastException） 提升到 编译期 （不加泛型时，编译时就可以看到黄色波浪线警告） 潜在的性能收益 泛型类 泛型方法格式： 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名（参数）{ } 特点：调用方法时，确定泛型的类型 1234567891011121314151617181920212223public class Container &#123; public &lt;E&gt; void insert(E e)&#123; System.out.println(e + \"---\" + e.getClass().getName()); &#125;&#125;----------------------------------------------------------- public class ContainerDemo &#123; public static void main(String[] args) &#123; Container container = new Container(); container.insert(\"你好\"); container.insert(11); container.insert(11.90); &#125;&#125;-----------------------------------------------------------你好---java.lang.String11---java.lang.Integer11.9---java.lang.Double 泛型接口格式 ： 修饰符 interface 接口名 &lt;代表泛型的变量&gt; {} 实现接口时旧确定泛型的类型。创建对象时只能创建该泛型类型的对象。这种方式适合确定性的。 12345678910111213141516171819202122232425262728293031public interface ContainerImpl &lt;E&gt; &#123; void insert(E e); E getinfo(int index);&#125;-----------------------------------------------------------public class Container implements ContainerImpl &lt;String&gt;&#123; @Override public void insert(String s) &#123; System.out.println(s + \"---\" + s.getClass().getName()); &#125; @Override public String getinfo(int index) &#123; return null; &#125;&#125;-----------------------------------------------------------public class ContainerDemo &#123; public static void main(String[] args) &#123; ContainerImpl&lt;String&gt; container = new Container(); container.insert(\"你好\"); //container.insert(11); //报错Error int无法转换为String //container.insert(11.90); //报错Error double无法转换为String &#125;&#125;-----------------------------------------------------------你好---java.lang.String 实现类不确定泛型的类型，直到创建对象时，才确定泛型的类型。这种方式更加灵活，适合范围较广的。 1234567891011121314151617181920212223242526272829303132public interface ContainerImpl &lt;E&gt; &#123; void insert(E e); E getinfo(int index);&#125;-----------------------------------------------------------public class Container&lt;E&gt; implements ContainerImpl &lt;E&gt;&#123; @Override public void insert(E e) &#123; System.out.println(e + \"---\" + e.getClass().getName()); &#125; @Override public E getinfo(int index) &#123; return null; &#125;&#125;-----------------------------------------------------------public class ContainerDemo &#123; public static void main(String[] args) &#123; ContainerImpl&lt;String&gt; container = new Container&lt;String&gt;(); container.insert(\"你好\"); Container&lt;Integer&gt; container2 = new Container&lt;&gt;(); container2.insert(11); &#125;&#125; 泛型的通配符当使用泛型类或接口时，传递的数据中泛型类型不确定，可以通过通配符 &lt;?&gt; 来确定 注意：泛型没有继承关系。如： Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种写法是错误的， ArrayList&lt;Object&gt;和 ArrayList&lt;String&gt;没有任何关系。 通配符的上下限那么有时候我们也不想让所有类都能作为泛型的类型怎么办？ 这时候，就要了解通配符的上下限了。 Java的泛型可以使用通配符指定一个泛型的上限和下限 上限：只能接收该类型及其子类 格式：类型名称 &lt;? extends 类&gt; 对象名称 下限；只能接收该类型及其父类 格式：类型名称 &lt;? super 类&gt; 对象名称 12345678910111213141516171819202122232425262728293031public class PairDemo &#123; public static void getNumber(Collection&lt;? extends Number&gt; collection) &#123; System.out.println(collection); &#125; public static void getString(Collection&lt;? super String&gt; collection) &#123; System.out.println(collection); &#125; public static void main(String[] args) &#123; Collection&lt;Integer&gt; c1 = new ArrayList&lt;Integer&gt;(); Collection&lt;Float&gt; c2 = new ArrayList&lt;Float&gt;(); Collection&lt;String&gt; c3 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; c4 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; c5 = new ArrayList&lt;Object&gt;(); // 测试上限 getNumber(c1); getNumber(c2); //getNumber(c3); //编译报错。String不是Number的子类 getNumber(c4); //getNumber(c5); //编译报错。Object不是Number的子类 // 测试下限 getString(c3); //getString(c4); //编译报错。Number不是String的父类 getString(c5); &#125;&#125; 案例统计一个数组中大于某个元素的个数","categories":[],"tags":[]},{"title":"JAVA 异常","slug":"JAVA-异常","date":"2019-11-20T10:52:27.000Z","updated":"2019-11-20T15:38:35.588Z","comments":true,"path":"2019/11/20/JAVA-异常/","link":"","permalink":"https://cometorbityh.github.io/2019/11/20/JAVA-异常/","excerpt":"","text":"Runtimejava.lang.RunTime 类代表Java程序的运行时环境 。 在每一个JVM进程里面都会存在有一个Runtime类的对象，这个类的主要功能是取得一些与运行时有关时环境的属性或者创建新的进程等操作。 Runtime只有一个对象，在其它类无法使用new关键字来创建Runtime对象，该对象我们称之为“”单例对象”。 同时Runtime的设计模式称之为单例模式，是23种设计模式的其中一种。 初识 单例模式从Runtime的源码来看 ，我们可以总结出单例模式的设计思路了： 创建一个私有的静态的对象（只加载一次） 构造器私有化（防止外部类创建对象） 写一个静态方法（可直接调用方法获得对象） 现在模仿Runtime类来创建一个单例对象 123456789101112131415161718public class Singleton &#123; // 1.创建一个私有的静态的对象 private static Singleton singleton = new Singleton(); // 2.构造器私有化 private Singleton()&#123;&#125;; // 3.写一个静态方法 public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); //true，证明是同一个对象 &#125;&#125; Runtime 常见方法 Process exec(String command) throws IOException 执行 可以打开应用 或执行命令 native long freeMemory() JVM虚拟机当前可用的内存，单位字节 native long totalMemory() 此电脑最多为JVM分配的内存，单位字节 native long maxMemory() JVM总内存，单位字节 native int availableProcessors() 获得JVM运行的可用核数 void gc() 释放掉垃圾空间 * GC（Garbage Collector）垃圾收集器，指的是释放无用的内存空间。 * GC 会由系统不定期进行自动的回收，或者调用Runtime类中的 gc() 方法 手动回收 异常异常的继承体系结构 异常的5个关键字throws：用在方法签名中，声明该方法可能抛出的异常 throw：抛出异常 try：将被监听的代码放在try代码块中 catch：捕获异常 finally:无论是否捕获到异常，都会执行其中的代码。主要用于回收在try块中打开的资源(如数据库连接、网络连接、磁盘文件) 只有finally块执行完成后。才会回来执行try块或catch块中的return或throw语句。若finally块中使用了return或throw等种植方法的语句，则不会跳回执行，直接停止。 123456789101112131415public static void main(String[] args) &#123; int result = divide(6,3); System.out.println(result); //finally... 2&#125;public static int divide(int a,int b)&#123; try &#123; int result = a/b; return result; &#125; catch (Exception e) &#123; e.printStackTrace(); return -1; &#125; finally &#123; System.out.println(\"finally...\"); &#125;&#125; 12345678910111213141516public static void main(String[] args) &#123; int result = divide(6,3); System.out.println(result); //finally... 66666&#125;public static int divide(int a,int b)&#123; try &#123; int result = a/b; return result; //未执行 &#125; catch (Exception e) &#123; e.printStackTrace(); throw new IllegalArgumentException(\"b can not be zero\"); //未执行 &#125; finally &#123; System.out.println(\"finally...\"); return 66666; &#125;&#125; JAVA中try、catch、finally带return的执行顺序总结转载自：https://www.cnblogs.com/pcheng/p/10968841.html 异常处理中，try、catch、finally的执行顺序，大家都知道是按顺序执行的。即， 如果try中没有异常，则顺序为try→finally， 如果try中有异常，则顺序为try→catch→finally。 但是当try、catch、finally中加入return之后，就会有几种不同的情况出现。 下面分别来说明一下。也可以跳到最后直接看总结。 一、try中带有return 123456789101112131415161718192021private int testReturn1() &#123; int i = 1; try &#123; i++; System.out.println(\"try:\" + i); return i; &#125; catch (Exception e) &#123; i++; System.out.println(\"catch:\" + i); &#125; finally &#123; i++; System.out.println(\"finally:\" + i); &#125; return i;&#125;-----------输出-------------try:2finally:32 因为当try中带有return时，会先执行return前的代码，然后暂时保存需要return的信息，再执行finally中的代码，最后再通过return返回之前保存的信息。所以，这里方法返回的值是try中计算后的2，而非finally中计算后的3。 但有一点需要注意，再看另外一个例子： 123456789101112131415161718192021private List&lt;Integer&gt; testReturn2() &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); try &#123; list.add(1); System.out.println(\"try:\" + list); return list; &#125; catch (Exception e) &#123; list.add(2); System.out.println(\"catch:\" + list); &#125; finally &#123; list.add(3); System.out.println(\"finally:\" + list); &#125; return list;&#125;-----------输出-------------try:[1]finally:[1, 3][1, 3] 看完这个例子，可能会发现问题，刚提到return时会临时保存需要返回的信息，不受finally中的影响，为什么这里会有变化？其实问题出在参数类型上，上一个例子用的是基本类型，这里用的引用类型。list里存的不是变量本身，而是变量的地址，所以当finally通过地址改变了变量，还是会影响方法返回值的。 二、catch中带有return 12345678910111213141516171819202122private int testReturn3() &#123; int i = 1; try &#123; i++; System.out.println(\"try:\" + i); int x = i / 0 ; &#125; catch (Exception e) &#123; i++; System.out.println(\"catch:\" + i); return i; &#125; finally &#123; i++; System.out.println(\"finally:\" + i); &#125; return i;&#125;-----------输出-------------try:2catch:3finally:43 catch中return与try中一样，会先执行return前的代码，然后暂时保存需要return的信息，再执行finally中的代码，最后再通过return返回之前保存的信息。所以，这里方法返回的值是try、catch中累积计算后的3，而非finally中计算后的4。 三、finally中带有return 12345678910111213141516171819202122private int testReturn4() &#123; int i = 1; try &#123; i++; System.out.println(\"try:\" + i); return i; &#125; catch (Exception e) &#123; i++; System.out.println(\"catch:\" + i); return i; &#125; finally &#123; i++; System.out.println(\"finally:\" + i); return i; &#125;&#125;-----------输出-------------try:2finally:33 当finally中有return的时候，try中的return会失效，在执行完finally的return之后，就不会再执行try中的return。这种写法，编译是可以编译通过的，但是编译器会给予警告，所以不推荐在finally中写return，这会破坏程序的完整性，而且一旦finally里出现异常，会导致catch中的异常被覆盖。 总结： 1、finally中的代码总会被执行。 2、当try、catch中有return时，也会执行finally。return的时候，要注意返回值的类型，是否受到finally中代码的影响。 3、finally中有return时，会直接在finally中退出，导致try、catch中的return失效。 异常分类运行时异常 编译异常 自定义异常日志框架 log4j 和 log4j2","categories":[],"tags":[]},{"title":"JAVA 日期相关类 概述","slug":"JAVA-日期相关类-概述","date":"2019-11-19T02:52:11.000Z","updated":"2019-12-01T17:01:39.784Z","comments":true,"path":"2019/11/19/JAVA-日期相关类-概述/","link":"","permalink":"https://cometorbityh.github.io/2019/11/19/JAVA-日期相关类-概述/","excerpt":"","text":"日期相关类Datejava.util.Date 123456789101112131415161718192021public static void main(String[] args) &#123; /** * Date():获取当前系统的日期和时间 */ Date date1 = new Date(); System.out.println(date1); //Mon Dec 02 00:40:12 CST 2019 /** * Date(Long date):毫秒值 ---&gt; Date日期（自1970年开始） */ Date date2 = new Date(0L); System.out.println(date2); //Thu Jan 01 08:00:00 CST 1970 /** * Long getTime():Date日期 ---&gt; 毫秒值（自1970年开始到现在） */ Date date3 = new Date(); System.out.println(date3.getTime()); //1575218690179 &#125; DateFormatjava.text.DateFormat 是日期/时间格式化子类的抽象类，其父类为java.text.Format. DateFormat可以完成日期和文本之间的转换（Date对象 &lt;—-&gt; String对象） 作用Date对象 —-&gt; String对象：格式化 Date对象 &lt;—- String对象：解析 成员方法String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串Date parse(String source) 把符合模式的字符串,解析为Date日期DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 子类SimpleDateFormatDateFormat是抽象类，需要用到子类：java.text.SimpleDateFormat，需要传入一个【自定义格式】来指定格式化或解析后的标准 构造方法SimpleDateFormat(String pattern)——用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 String pattern：传递指定的模式 模式（区分大小写）：y年，M月，d日，H时，m分，s秒 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) 1 DecimalFormatDecimalFormat可以对数字进行格式化 1234567891011121314151617public static void main(String[] args) &#123; double d = 3333333.666666; DecimalFormat df = new DecimalFormat(); System.out.println(df.format(d)); // 3,333,333.667 df.setGroupingSize(2); //每2位一个分隔符 df.setGroupingUsed(true); df.setMaximumFractionDigits(6); //设置小数部分最大位数（默认3位） df.setMinimumIntegerDigits(5); //设置整数部分最大位数 DecimalFormatSymbols dfs = df.getDecimalFormatSymbols(); dfs.setGroupingSeparator('-'); //设置分隔符 dfs.setDecimalSeparator('*'); //设置小数点 df.setDecimalFormatSymbols(dfs); String d1 = df.format(d); System.out.println(d1); //3-33-33-33*666666&#125; 2 BigInteger当我们定义一个数超出这个数的范围时会报错，但是我们却必须使用这个数值和类型时该怎么办？ Java中有一个类 java.math.BigInteger 可以表示任意长度，就是用来处理数值溢出问题。 12345678910111213public static void main(String[] args) &#123; System.out.println(Integer.MAX_VALUE); //2147483647 BigInteger bi1 = new BigInteger(\"2147483648\"); //超出Int范围 BigInteger bi2 = new BigInteger(\"1\"); System.out.println(\"bi1-bi2=\"+(bi1.subtract(bi2).intValue())); //此时结果范围在Integer之内 System.out.println(Long.MAX_VALUE); //9223372036854775807 BigInteger bi3 = new BigInteger(\"9223372036854775807\"); //超出Long范围 BigInteger bi4 = new BigInteger(\"1\"); System.out.println(\"bi3-bi4=\"+(bi3.subtract(bi4).longValue())); //此时结果范围在Long之内&#125; 3 BigDecimal用double进行数值计算时，会出现精度问题 123456789public static void main(String[] args) &#123; double d1=2; double d2=1.1; double d3=0.9; System.out.println(\"d1-d2=\"+(d1-d2)); //0.8999999999999999 System.out.println(\"d1-d3=\"+(d1-d3)); //1.1&#125; 因此我们在进行科学计算/财务计算时，一般使用另一个类：BigDecimal来表示任意精度，可以用来处理精度问题 123456789public static void main(String[] args) &#123; BigDecimal bd1 = new BigDecimal(\"2\"); BigDecimal bd2 = new BigDecimal(\"1.2\"); BigDecimal bd3 = new BigDecimal(\"1.1\"); System.out.println(\"bd1-bd2=\"+(bd1.subtract(bd2).doubleValue())); //减法 0.8 System.out.println(\"bd1-bd3=\"+(bd1.subtract(bd3).doubleValue())); //0.9&#125;","categories":[],"tags":[]},{"title":"JAVA Object:常见方法概述","slug":"JAVA-Object-常见方法概述","date":"2019-11-19T02:51:49.000Z","updated":"2019-11-19T12:35:48.216Z","comments":true,"path":"2019/11/19/JAVA-Object-常见方法概述/","link":"","permalink":"https://cometorbityh.github.io/2019/11/19/JAVA-Object-常见方法概述/","excerpt":"","text":"Object类java.lang.Object类是所有类的根，即所有类都直接或间接继承Object类，每个类都将Object当作超类。 所有的对象，数组都实现了 Object 的方法 native关键字：Java具体是由C写的代码，native可以调用这些代码协助完成源码编写。 getClass( ) 获得java.lang.Class对象，在反射时会用（该类用final修饰，不可重写） hashCode( ) hashSet集合确保对象唯一性 equals( ) 判断是否是同一个对象，默认比较引用的地址（可重写） toString( ) 代表这类字符串【格式：全限定类名@十六进制hashcode】（可重写） clone( ) 克隆对象（深拷贝 、 浅拷贝） finalize( ) gc回收对象时会调用的方法 notify( ) （多线程相关）线程等待唤醒机制 notifyAll( ) （多线程相关） wait( ) （多线程相关） clone( ) 克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝。 在Java中对象的克隆有深克隆和浅克隆之分。有这种区分的原因是Java中分为基本数据类型和引用数据类型，对于不同的数据类型在内存中的存储的区域是不同的。基本数据类型存储在栈中，引用数据类型存储在堆中。 clone的步骤： 对象的类实现Cloneable接口； 覆盖Object类的clone()方法 （覆盖clone()方法，访问修饰符设为public，默认是protected）； 在clone()方法中调用super.clone()； clone( ) 的浅拷贝 指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Address &#123; private String country; private String city; public Address() &#123; &#125; public Address(String country, String city) &#123; this.country = country; this.city = city; &#125; //getter , setter , toString()&#125;----------------------------------------------// 1. 实现Cloneable接口public class User implements Cloneable&#123; private Integer id; private String name; private Address address; public User() &#123; &#125; public User(Integer id, String name, Address address) &#123; this.id = id; this.name = name; this.address = address; &#125; // 2. 重写clone方法 @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; //getter , setter , toString()&#125;------------------------------------------------public class ObjDemo01 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Address address = new Address(\"中国\",\"北京\"); User u1 = new User(1,\"XiaoHei\",address); User u2 = (User)u1.clone(); System.out.println(u1 == u2); System.out.println(u1); System.out.println(u2); // 修改u1的Address的city属性 u1.getAddress().setCity(\"上海\"); System.out.println(u1 == u2); System.out.println(u1); System.out.println(u2); &#125;&#125;-----------------------------------------------------falseUser&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='北京'&#125;&#125;User&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='北京'&#125;&#125;falseUser&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='上海'&#125;&#125;User&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='上海'&#125;&#125; 可以看出，克隆前后的对象不相等，因为他们本来就不是同一个对象，因此不相等 但是当u1修改属性值时，为什么u2也跟着修改？ 原来，这2个对象的address都指向同一个引用，但这个address引用的内容发生变化时，这2个对象的address的值也就随之发生变化了，这就是浅拷贝。 那么如何使克隆后的对象不受影响呢？这就要用到深拷贝了 clone( ) 的深拷贝 不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 1. 实现Cloneable接口public class Address implements Cloneable&#123; private String country; private String city; public Address() &#123; &#125; public Address(String country, String city) &#123; this.country = country; this.city = city; &#125; // 2. clone方法 @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; //getter , setter , toString()&#125;----------------------------------------------// 1. 实现Cloneable接口public class User implements Cloneable&#123; private Integer id; private String name; private Address address; public User() &#123; &#125; public User(Integer id, String name, Address address) &#123; this.id = id; this.name = name; this.address = address; &#125; // 2. 重写clone方法 @Override protected Object clone() throws CloneNotSupportedException &#123; User user = (User)super.clone(); Address address = (Address) user.address.clone(); user.setAddress(address); return user; &#125; //getter , setter , toString()&#125;------------------------------------------------public class ObjDemo01 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Address address = new Address(\"中国\",\"北京\"); User u1 = new User(1,\"XiaoHei\",address); User u2 = (User)u1.clone(); System.out.println(u1 == u2); System.out.println(u1); System.out.println(u2); // 修改u1的Address的city属性 u1.getAddress().setCity(\"上海\"); System.out.println(u1 == u2); System.out.println(u1); System.out.println(u2); &#125;&#125;-----------------------------------------------------falseUser&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='北京'&#125;&#125;User&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='北京'&#125;&#125;falseUser&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='上海'&#125;&#125;User&#123;id=1, name='XiaoHei', address=Address&#123;country='中国', city='北京'&#125;&#125; 首先给Address类重写clone方法，然后修改User类中的clone方法，使其克隆User对象时同时克隆Address对象。 这样克隆后的对象就不会受到前对象修改数据时的影响了。","categories":[],"tags":[]},{"title":"JAVA String类","slug":"JAVA-String类","date":"2019-11-18T11:44:53.000Z","updated":"2019-11-24T15:10:28.195Z","comments":true,"path":"2019/11/18/JAVA-String类/","link":"","permalink":"https://cometorbityh.github.io/2019/11/18/JAVA-String类/","excerpt":"","text":"String使用String对象存储字符串创建String对象常见的3种方法： 123456789101112public static void main(String[] args) &#123; String str1 = \"abc\"; System.out.println(\"str1 = \" + str1); String str2 = new String(\"abc\"); System.out.println(\"str2 = \" + str2); char[] chs = &#123;'a','b','c'&#125;; String str3 = new String (chs); System.out.println(\"str3 = \" + str3);&#125; 凡是用“=”直接创建字符串对象的，都是保存在字符串常量池； 使用 new 关键字创建字符串对象的，保存的是指向栈内存对象的地址。 String类位于java.lang包下，是Java语言的核心类，提供了字符串的比较、查找、截取、大小写转换等操作； Java语言为“+”连接符（字符串连接符）以及对象转换为字符串提供了特殊的支持，字符串对象可以使用“+”连接其他对象。 String本质——char数组 根据上面的代码和源码，我们可以看出， String类被final关键字修饰，因此无法被继承，且其成员方法都默认是final方法。 在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。 String的本质就是一个char数组！！！ 由于有final的存在，该数组就是常量，通过初始化后，值就是不可变的了，也就证明了String的不可变性 String的不可变性不可变：一旦一个字符串被创建后。它的值就不能被修改了。 在这里有个疑惑，为什么是不可变的？String对象不是可以修改吗？ 案例： 12345678910public static void main(String[] args) &#123; String str1 = \"abc\"; System.out.println(\"str1 = \" + str1); str1 = \"def\"; System.out.println(\"str1 = \" + str1);&#125;--------控制台--------str1 = abcstr1 = def 不急，我们首先来看看这2个是同一对象嘛，案例 12345678910111213public static void main(String[] args) &#123; String str1 = \"abc\"; System.out.println(\"str1 = \" + str1); System.out.println(\"hashcode = \"+ str1.hashCode()); str1 = \"def\"; System.out.println(\"str1 = \" + str1); System.out.println(\"hashcode = \"+ str1.hashCode());&#125;--------控制台--------str1 = abchashcode = 96354str1 = defhashcode = 99333 可以看出，修改前后的2个String对象的hashcode不一样，这说明这2个不是同一个对象。 其实不是改变了，只是这个引用指向的对象不一样了。 这可能是巧合，我们在看一个案例： 123456789public static void main(String[] args) &#123; String str1 = \"abc\"; System.out.println(\"str1 = \" + str1); System.out.println(\"hashcode = \"+ str1.hashCode()); str1 = str1.concat(\"def\"); //等价于 str1 = str1 + \"def\"; System.out.println(\"str1 = \" + str1); System.out.println(\"hashcode = \"+ str1.hashCode());&#125; 可以看到，这2个对象的hashcode还是不同的，这是为什么呢？我们来看下concat方法的源码： 可以看出，concat方法的返回值是一个全新的String对象，原来String的底层源码也隐藏着这么一层复杂的逻辑。 因此说String对象具有不可变性。 String类常用的方法及使用 常见方法 作用 public toCharArray() 将String对象转换为char数组 public char charAt(int index) 获得char数组的对应下标的元素 public int compareTo(String anotherString) 比较2个字符串的字典顺序 public int compareToIgnoreCase(String anotherString) 比较2个字符串的字典顺序（忽略大小写） public String concat(String str) 增长字符串 public int indexOf(String str) 获得另一字符串第一次在本字符串出现的索引值（从前往后找），若不存在则返回-1 public int lastIndexOf(String str) 获得另一字符串第一次在本字符串出现的索引值（从后往前找），若不存在则返回-1 public boolean contains(CharSequence s) 判断是否包含该字符串 public boolean startsWith(String prefix) 判断该字符串是否以另一字符串开始的 public boolean endsWith(String suffix) 判断该字符串是否以另一字符串结尾的 public boolean equals(Object anObject) 判断2个字符串的值是否相等（String重写了equals方法） public int length() 获取该字符串的长度（注意与length属性的区别） public String[] split(String regex) 将字符串按照固定符号分割成一个字符串数组 public String toLowerCase() 将字符串转为小写 public String toUpperCase() 将字符串转为大写 public String trim() 去掉字符串的前后空格 public static String valueOf(int i) 把传入的数据转为字符串 public static String format(String format, Object… args) 格式化字符串 public String replace(CharSequence target, CharSequence replacement) 将所有的指定字符串替换为新字符串 public String substring(int beginIndex, int endIndex) 返回一个新字符串，他是此字符串的子字符串 [ begin,end ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package com.young.stringtest;import java.lang.reflect.Method;public class StringDemo01 &#123; public static void main(String[] args) &#123; method01(); method02(); method03(); method04(); method05(); method06(); method07(); method08(); method09(); method10(); method11(); method12(); method13(); &#125; /* toCharArray() charAt() */ public static void method01() &#123; String str1 = \"abc\"; char[] chars = str1.toCharArray(); System.out.println(chars[2]); //c char c = str1.charAt(1); System.out.println(c); //b &#125; /* compareTo(String str) */ public static void method02() &#123; /* * str1.compareTo(str2) * 长度不同，内容不同，比较的是2个字符串的第一个同位置但不同字符的字典顺序 * 长度不同，但前面所有内容都相同，则比较长度 * */ String str1 = \"abc\"; String str2 = \"def\"; int pos1 = str1.compareTo(str2); System.out.println(pos1); //-3，字典顺序a-97,d-100 String str3 = \"abc\"; String str4 = \"abcde\"; int pos2 = str3.compareTo(str4); System.out.println(pos2); //-2，比较长度 &#125; /* compareToIgnoreCase() */ public static void method03() &#123; String str1 = \"abc\"; String str2 = \"aBc\"; System.out.println(str1.compareTo(str2)); //32 System.out.println(str1.compareToIgnoreCase(str2)); //0 &#125; /* concat() */ public static void method04() &#123; String str1 = \"abc\"; String str2 = \"hello\"; str1 = str1.concat(str2); System.out.println(str1); //abchello &#125; /* contain() startsWith() endsWith() */ public static void method05() &#123; String str1 = \"hello123\"; String str2 = \"hello\"; System.out.println(str1.contains(str2)); //true System.out.println(str1.startsWith(\"hell\")); //true System.out.println(str1.startsWith(\"123\")); //false System.out.println(str1.endsWith(\"hello\")); //false System.out.println(str1.endsWith(\"123\")); //true &#125; /* indexOf() lastIndexOf() */ public static void method06() &#123; String str1 = \"hello123\"; String str2 = \"lo\"; System.out.println(str1.indexOf(str2)); //3 System.out.println(str1.lastIndexOf(str2)); //3 &#125; /* equals() */ public static void method07() &#123; String str1 = \"hello\"; //存放在字符串常量池 String str2 = \"hello\"; String str3 = new String(\"hello\"); //指向栈内存的对象的地址值 String str4 = new String(\"hello\"); //指向栈内存的对象的地址值 System.out.println(str1.equals(str2)); //true,比较内容，说明String重写equals方法 System.out.println(str1==str2); //true,比较地址值 System.out.println(str1.equals(str3)); //true,比较内容 System.out.println(str1==str3); //false,比较地址 System.out.println(str3.equals(str4)); //true,比较内容 System.out.println(str3==str4); //false,比较地址 &#125; /* length() length */ public static void method08() &#123; String str1 = \"helloWorld\"; System.out.println(str1.length()); //10 String[] strs = &#123;\"a\",\"b\",\"c\"&#125;; System.out.println(strs.length); //3 &#125; /* split()*/ public static void method09() &#123; String fruits = \"apple,banana,orange\"; String[] fruits1 = fruits.split(\",\"); for (String fruit: fruits1)&#123; System.out.print(fruit + \" \"); //apple banana orange &#125; System.out.println(); &#125; /* toLowerCase() toUpperCase() */ public static void method10() &#123; String str1 = \"AbcDeF\"; System.out.println(str1.toLowerCase()); //abcdef System.out.println(str1.toUpperCase()); //ABCDEF &#125; /* trim() */ public static void method11() &#123; String str1 = \" AbcDeF \"; String str2 = \" Abc DeF \"; System.out.println(str1.trim()); //AbcDeF System.out.println(str2.trim()); //Abc DeF &#125; /* valueOf() */ public static void method12() &#123; int i =2; System.out.println(String.valueOf(i)); //2 &#125; /* format() replace() substring() */ public static void method13() &#123; String str1 = String.format(\"Hello: %s,%s\",\"小明\",\"小红\"); //Hello: 小明,小红 System.out.println(str1); String str2 = \"大家好才是真的好\"; str2 = str2.replace(\"好\",\"坏\"); System.out.println(str2); //大家坏才是真的坏 String url = \"www.taobao.com\"; String url1 = url.substring(3); System.out.println(url1); //.taobao.com String url2 = url.substring(0,3); System.out.println(url2); //www String url3 = url.substring(url.indexOf(\".\")+1,10); System.out.println(url3); //taobao String url4 = url.substring(url.lastIndexOf(\".\")+1,14); System.out.println(url4); //com &#125;&#125; 字符串常量池在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池。 字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。 当执行String s1 = “AB”时，JVM首先会去字符串常量池中检查是否存在”AB”对象，如果不存在，则在字符串常量池中创建”AB”对象，并将”AB”对象的地址返回给s1；如果存在，则不创建任何对象，直接将字符串常量池中”AB”对象的地址返回给s1。 intern() 方法直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。 JDK1.7的改动： 将String常量池 从 Perm 区移动到了 Java Heap区 String.intern() 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。 小试牛刀123456789101112131415161718192021public static void main(String[] args) &#123; String s1 = \"AB\"; String s2 = new String(\"AB\"); String s3 = \"A\"; String s4 = \"B\"; String s5 = \"A\" + \"B\"; String s6 = s3 + s4; System.out.println(s1 == s2); //false System.out.println(s1 == s5); //true System.out.println(s1 == s6); //false System.out.println(s1 == s6.intern()); //true System.out.println(s2 == s2.intern()); //false&#125;------------------------------解析：真正理解此题目需要清楚以下三点1）直接使用双引号声明出来的String对象会直接存储在常量池中；2）String对象的intern方法会得到字符串对象在常量池中对应的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；3） 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c命令获得class文件对应的JVM字节码指令就可以看出来。————————————————原文链接：https://blog.csdn.net/ifwinds/article/details/80849184 StringBuffer + StringBuilder介绍StringBuffer 类称为字符串缓冲区，所表示的是一个字符序列，这个类必须使用new创建对象， 线程安全，效率低 和 String 类不同的是：StringBuffer 是一个可变的类 StringBuilder 类与StringBuffer 类兼容，但是线程不安全 12345678910111213141516171819202122232425package com.young.stringtest;import javafx.beans.binding.StringBinding;import javax.sound.midi.Soundbank;public class StringDemo02 &#123; public static void main(String[] args) &#123; StringBuffer stringBuffer = new StringBuffer(\"你好，\"); System.out.println(stringBuffer.hashCode()); //460141958 System.out.println(stringBuffer); //你好, stringBuffer.append(\"世界！\"); System.out.println(stringBuffer.hashCode()); //460141958 System.out.println(stringBuffer); //你好，世界！ StringBuilder stringBuilder = new StringBuilder(\"你好,\"); System.out.println(stringBuilder.hashCode()); //1163157884 System.out.println(stringBuilder); //你好, stringBuilder.append(\"未来！\"); System.out.println(stringBuilder.hashCode()); //1163157884 System.out.println(stringBuilder); //你好,未来！ &#125;&#125; 使用123456789101112131415161718192021222324252627282930313233343536373839package com.young.stringtest;import javafx.beans.binding.StringBinding;public class StringDemo02 &#123; public static void main(String[] args) &#123; /* String拼接字符串 */ long begin = System.currentTimeMillis(); String str = \"hello\"; for(int i=0;i&lt;50000;i++)&#123; str =str + i; &#125; long end = System.currentTimeMillis(); System.out.println(\"String cost time:\" + (end - begin)); //String cost time:8463 /* StringBuffer拼接字符串 */ begin = System.currentTimeMillis(); StringBuffer stringBuffer = new StringBuffer(); for(int i=0;i&lt;50000;i++)&#123; stringBuffer.append(i); &#125; end = System.currentTimeMillis(); System.out.println(\"StringBuffer cost time:\" + (end - begin)); //StringBuffer cost time:3 /* StringBuilder拼接字符串 */ begin = System.currentTimeMillis(); StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;50000;i++)&#123; stringBuilder.append(i); &#125; end = System.currentTimeMillis(); System.out.println(\"StringBuilder cost time:\" + (end - begin)); //StringBuilder cost time:1 &#125;&#125; 从数据看，String花费的时间远远多于StringBuffer和StringBuilder。 区别查看源码： 可以看出， StringBuffer对象在进行append时， ​ 加入了同步锁，这样保证了线程安全，但是带来的代价就是多线程时效率不高。 ​ 并且append()返回的还是原来的对象，因此StringBuffer从始至终都是一个对象，其实这是StringBuffer在进行扩容的操作。 StringBuilder对象在进行append时， ​ 没有加入同步锁，这样无法保证了线程安全，但是好处就是多线程时效率高。 ​ 并且append()返回的还是原来的对象，因此StringBuilder从始至终都是一个对象，其实这是StringBuilder在进行扩容的操作。 因此相对于String来说，StringBuffer和StringBuilder的性能要好很多，因为它们始终只有一个对象，而String是保存在字符串常量池中，可能会保存非常多的对象，十分影响性能。 三者区别 String类不可变，对象一旦被创建，其值便不可被修改，可以使用new关键字或 = 创建对象 StringBuffer类是可变的，对象创建后可修改，线程安全，效率低，必须使用new关键字创建对象 StringBuilder类是可变的，对象创建后可修改，线程不安全，效率高，必须使用new关键字创建对象 执行效率：StringBuilder &gt; StringBuffer &gt; String 案例将一个数字字符串转换成逗号分隔的数字串，（从右向左，每3位数一个逗号） 1234567891011121314public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print(\"请输入数字：\"); String nums = input.next(); StringBuffer str = new StringBuffer(nums); for(int i=str.length()-3;i&gt;0;i=i-3)&#123; str.insert(i,','); &#125; System.out.println(str);&#125;------------------请输入数字：12345678901,234,567,890 8种基本数据类型的包装类型 基本数据类型 包装类型 int Integer short Short long Long float Float double Double char Character boolean Boolean byte Byte 使用这8个包装类，能够把某一种基本数据类型的变量转换为引用类型，这样就==可以使用类中的方法==，进行更多操作。 装箱与拆箱 装箱：将基本数据类型包装成对应的包装类型 拆箱：将包装类型拆开成对应的基本数据类型 自动拆装箱JDK1.5之后，可以进行自动拆装箱的操作了。 1234567891011public static void main(String[] args) &#123; //装箱 Integer var1 = new Integer(10); //拆箱 int var2 = var1.intValue(); //自动装箱 Integer var3 = 12; //自动拆箱 int var4 = var3;&#125; ⭐使用常量池在自动拆装箱的过程中，Java使用到了常量池。 需要注意的是：只有数值是byte范围内（也就是[-128,127]）的时候，才使用到常量池，否则都是分配新的内存空间 12345678910111213141516171819202122232425public static void main(String[] args) &#123; //手动装箱 Integer i3 = new Integer(11); Integer i4 = new Integer(11); System.out.println(i3 == i4); //false //自动装箱 Integer i1 = 11; Integer i2 = 11; System.out.println(i1 == i2); //true Integer i5 = 128; //超出byte范围，将分配新的内存空间 Integer i6 = 128; System.out.println(i5 == i6); //false Integer i7 = -128; Integer i8 = -128; System.out.println(i7 == i8); //true Integer i9 = -129; Integer i10 = -129; System.out.println(i9 == i10); //false&#125;","categories":[],"tags":[]},{"title":"CET6 CORE (1)","slug":"CET6-CORE-1","date":"2019-11-18T09:44:19.000Z","updated":"2019-11-20T05:25:50.596Z","comments":true,"path":"2019/11/18/CET6-CORE-1/","link":"","permalink":"https://cometorbityh.github.io/2019/11/18/CET6-CORE-1/","excerpt":"","text":"decline 下降 衰退 拒接绝 refuse fuse-流，往回流，婉拒[一般程度] reject 拒绝[严重程度] ject-扔 往回扔 derive form 源自于 river小何向下流，即源自于 &gt; stem from源自于 stem根，根茎originate form源自于 origin名词-起源 original 形容词- 原始的 deviate from 脱离 偏离 vi-路 count数数 计算 vi-重要 有影响 有作用 money count 钱重要 matter动词-重要 有影响 有关系 名词-东西 事情 discount 动词-打折 名词-打折 80% discount打二折 account动词-记账，算账，记录 名词-账目 账户 bank account银行账户accountant会计师counter 名词- 计算器 计数器 柜台 形容词-相反的 相对的 副词-相反地 相对地 动词-反对OTC over the counter非处方药，在柜台可以卖到的药counterbalance 动词和名词-制衡 graduate名词-毕业生 &gt; graduate from 从，，，毕业 candidate 名词-候选人 fluctuate 动词-波动 &gt; flu-流动flu流感fluent 流利的，流畅的fluid液体 流体&gt;&gt;solid 名词固体 东形容词-RP牢固的 稳固的 可靠的 &gt;influence 影响[潜在的，内心的影响]&gt;&gt;affect 影响 fact-做 去做 &gt;influential 形容词-有影响力的 有权势的名词-有影响里的人 有权势的人indefinite 不明确的 不确定的in-加加在形容词前表示否定 加在其他词前表示进入fin-限制define限定 限制 下定义definition 限定 限制 定义definite 确定的 明确的definitely 一定 肯定finite 有限的infinite无限的 indicate 暗示 表明 在心里说&gt;dic说predict 预言 预测prediction 预测dictate 口述 口授 命令 支配 我说你写就是命令dictation 口述 口授 命令 支配dictator 发号施令者吗 独裁者 major 形容词-主要的 重大的 大部分的 名词-专业 动词-主修 专攻majority 大部分the majority of 大部分的minor 名词辅修专业 动词辅修 形容词 次要的 小部分的minority 名词小部分的 少数民族the minority of 少部分的 potential形容词 有潜力的 有潜能的 潜在的 名词潜力潜能develop your potential 开发潜能 十五选十 名词ly=形容词 形容词+ly=副词 instantaneously 立即地=immediatelysimultaneously 同时地=at the same timecautiouslycaution 名词小心谨慎 动词警告=warmcautious形容词 小心的 谨慎的 =carefulparticularly特别 尤其=especially =in particularspecially 特殊地 permanently 形容词 永恒的 永久的 constantly持续的 永恒的 不变的 名词常量恒量variable 变量vary 动词变化 very 非常vary form，，，to，，，从。。变化到。。。various变化的variable 能变的 可变的 名词变量 variation 名词变化variety 名词变化 种类a variety of 各种各样的=all kind of =all sorts ofoccasionally偶尔地 偶然地occasion 名词 时机 场合occur 发生 stimulate 动词刺激激励stimulation名词刺激激励激inspire鼓舞motivate 形容词 移动的 运动的 名词动机motivate 使有动机 激励 激发motivate somebody to do something激励某人做某事motion 名词移动 运动motor 摩托车 tract-拖，拉 abstract a. 抽象的 v. 提取，抽取，抽出，拔出n. 摘要 abstract definition 抽象的定义 【反】 concrete a. 具体的n.混凝土 tractor n. 拖拉机 attract v. 吸引 attraction n. 吸引 attractive a. 有吸引力的 -ity …的性质 personality n. 个性，名人 humanity n. 人性，文科 the humanities = the arts 文科（总称）the science 理科 authority n. 权威性，权威，政府当局 the authorities = the government 政府当局 sensitivity n. 敏感性 sense v. 感觉 n.感觉 sensible a. 可感觉到的，能感觉到的；明智的 sensitive a. 敏感的 credibility n. 可信性，可靠性 credit n.信用（credit card 信用卡） credible a.可信的，有信用的 【同】 rely on 依赖，可靠reliable a. 可靠的reliability n.可靠性 eligibillity n.有资格性 eligiable a.有资格的 feasibility n.可行性 feasible a.可行的 sum-摘，拿 assume v.假设 assumption n.假设 presume v.假设 presumption n.假设 sess-坐 assess v.评估 assessment n.评估 asset n.资产，财产 【同】 wealth= property n. 财产，所有权Intellectual property 知识产权Intellectual a.有知识的 n.知识分子intelligent a.聪明的，智慧的，智能的intelligence n.聪明 智慧 智能 情报（information）*CIA 美国中央情报局 central Intelligence Agency AI artificial a . 人工的 人造的 虚伪的 矫揉造作的 【反】natural 自然的knowledge access v . 接近 靠近n . 通道 途径 have access to… 由途径得到/接触 … accessible a . 可接近的 可靠近的 可得到的 process n. 工艺 工序； 过程v . 加工 处理 microprocessor 微型处理器chip n . 薯片 芯片 micro- 微小的formula n. 功时 formulate v. 用公式表示；系统阐述，系统化说明 十五选十 confidentially ad . 秘密地 机密地 confidently ad. 自信地 mysteriously ad . 神秘地 mystery n . 神秘 mysterious a . 神秘的 radically 根本地 radical a. 根本的 ，根本性的 （changes）；激进的 彻底的 separately ad . 分开地 分别地 separate a. 分开的v. 分开 分别separate from… 与 …分开 frequently 经常地 frequent 经常的 frequency n. 经常 频率 consequently 因此（so， hence，thus， therefore， as a result），结果是 consequent 因此的 consequence n . 结果（result）后果 as a consequence因此 economically ad. 经济地 节俭地 节约地 economic a . 经济的 经济学的 economy n. 经济 节俭 节约 economics n . 经济学 economist n. 经济学家 economical a. 经济的 节俭的 successively 连续地 successful 成功的 successfully 成功地 successive 连续的 sensible sensitive considerate a. 考虑周到的（thoughtful） 体贴的 considerable a. 值得考虑的 相当多的 相当大的 optimistic a. 乐观的 optimism 乐观主义optimist 乐观主义者 pessimistic a. 悲观的 … socialism 社会主义socialist 社会主义者capitalism 资本主义capitalist资本家capital首要的重大的communism 共产主义communist共产主义者common 共同CCP 中国共产党 China communist Party industry n. 工业 行业 勤奋 勉励 industrious a. 勤奋的 勉励的=hardworking spoil v . 溺爱 宠坏；毁坏 破坏（warm） green house effect 温室效应Low- carbon life 低碳生活 underestimate v 低估 estimate v. n. 估计 overestimate 高估 value n 价值 价值观v 估值 估价 珍惜 重视life value生活价值观 undervalue v 低估 rate n.率 速度 价格 费用 等级jobless rate 失业率at the rate/speed of 以…的速度the first class / rate第一等v 评估 评分 评级 评价overrate 高估underrate 低估 distribute 分配 分发 分散 分销 tribe 部落tribute 贡品 进贡 颂扬 歌功颂德distributionattribute …to…将。。。归功于/归因于。。contribute 动。贡献 投稿contributioncooperation名词 合作coworker名词 同事 合伙人 divide v 分开 除 divorce v n 离婚 exhibition 名词 展览 exhibit 动词 展览 展示 collect 动词收集 collection 名词手机 集合collective 形容 收集的 集体的 共同的collectivism 集体主义individual 个人的 名词 个人个体individualism 个人主义material 物质的 名词 物质 材料materialism 物质主义 唯物主义ideal 理想的 完美的ideal wife理想妻子idealism 理想主义 完美主义 唯心主义maoism毛泽东思想Taoism道家思想the policy of reform and opening up 改革开放政策reform = revolution 改革revolutionary革命的cause名词 原因 理由 事业 动词 引起造成revolutionary cause革命事业education cause 教育事业 except 除了。。。exception 名词 例外exceptional 例外的 杰出的 弱智的 异常的exceptional children 特殊儿童（智障）disabled children 残疾儿童Negro黑鬼 option 名词 选择 选项 opt 名词选择optional可选的 可选择的optional courses选修课compulsory 强制的 必须的 义务的compulsory education 义务教育compulsory courses 必修课 expense 名词 花费 费用expensive 昂贵的excessive 过分的 过多的excess 名词 过多 过分 过多形容词 过多的 过量的 过分的expose 动词暴露曝光expose…to…将。。。曝光给…pose名词姿势 动词摆放（put）compose 动词组成 构成 作文 作曲 作图impose impose…on…将什么施加于/强加于。。。do not impose your ideas on me! amazing 惊讶的（好的一面） launch 动词 发动 发起 发射launch a campaign 发起战役 neglect 动词 忽视（ignore） overlook 动词 俯视 俯瞰 忽视 忽略 normal 正常的 标准的 师范的norm 名词 标准 规范 准则abnormal 不正常的 表态的 abuse 动词 滥用 虐待 abandon 动词 放弃=give upquit 动词 放弃 辞职 assign 动词 分配（任务）assignment 作业 任务sign名词 标记标志 征兆 迹象 动词 签名resign resign from this job/company从这个工作/公司辞职 treasure 名词 财宝 财富 动词 珍惜 重视=value dramatic 形容词 戏剧性的 剧烈的 急剧的drama 名词 戏剧dramatically 戏剧性地 急剧地 剧烈地fierce 激烈的 sharp 锋利的 急剧地 剧烈地sharply 副词 maintain 动词维修 维持 声称认为somebody maintains that。。。sustain 动词 维持 持续sustainable 可维持的 可持续的sustainable development 可持续发展 persist 彻底的persistent坚持的 坚持不懈的persistence 名词 坚持 坚持不懈nothing in this world can take the place of persistencepersist in doing something insist in doing something 内心的愿望 range 范围 幅度 山脉a range of 一系列的动词 range from … to …范围从…到 … rover 漫步者 rank 动词名词 排名 排列 resolve 动词 解决 决定 下决心resolve this problem resolution 解决方案 决定 决心 决议settle 动词 定居 解决 settle this problem solve 解决 溶解solution 解决方案 溶液 refine 动词 提炼 精炼refinement 名词 提炼 精炼government 名词 政府govern 动词 管理 统治 支配governor 统治者 总督 州长 省长 step名词 步伐 步子 oversstep 动词 逾越 additional 额外的 增加的add 动词 增加 补充说addition 增加 额外in addition 此外in addition to + 名词 除了…之外 psychological 心里的 心理学的psychology 心理学 affect 动词 影响 打动 感动affection 名词 影响 爱情 柔情 affectionate 形容词 柔情似水的 含情脉脉的effect 名词 影响 效果 动词做出来 完成 实现have an effect on = affecteffective 有影响的 有效果的take effective measures to do somethinig perfect 完美的imperfect infect 动词 感染 传染 infection 名词 传染 感染infectious 感染的 传染的 assimilate 动词 同化 similar 相似 accompany 动词 陪伴company 公司 伙伴 cultivate 动词 栽培 培养cultivate the spirit of innovation 培养创新精神cultivate the sense of cooperation 培养合作意识cultivate the optimistic spirit 动词 栽培 培养cultivate the spirit of innovation 培养创新精神cultivate the sense of cooperation 培养合作意识cultivate the spirit of optimism innovation 创新novel 小说 新颖的 新奇的innovate 动词 创新innovative 形容词 创新的 创新性的 translate 动词 翻译（笔译）； 转变 转化translationinterpret 动词 翻译（口译）解释说明interpretation affiliate 动词 隶属于 附属于 名词 分公司 附属机构 circle 名词 圆圈 圈子the circle of friends 朋友圈circulate 动词 循环 流通circulation enthusiastic 热情的 热心的enthusiasm 热情 热心 identify 动词 确定 辨别identity 名词 身份 ID card 身份证 notify 通知 告知note 注意 知道 笔记 告知 quality 名词 质量 品质qualify 使有资格qualification 名词 资格 品质certificate 名词 证书 文凭 penalty punishment 名词 惩罚//penalize = punish 动词 惩罚 rewarding 有回报的reward 名词 汇报 simplifying simple 简单的 simplify 动词 简化 suspend 动词 暂停 中止 吊销suspending overwhelming 压倒性的 不知所措的overwhelm 动词 压倒 使不知所措overwhelmed 不知所措的 被压倒的 appealing 有吸引力的appeal to 吸引 呼吁 上诉 soar 动词 飞涨soaring rocket 火箭 动词 剧增 猛涨 飞涨 apply apply to应用于 适用于 apply for 申请application 申请 应用 适用supply 供应 equivalent equ+value 等价的 名词 等价物 等同物equal 相等的 shift 动词 名词 转换 换挡 amount 名词 总量 数量amount to 总量达… 等同于… character 性格 特点 特征characteristic 有特色的 有特征的 有特点的 fresh 新鲜的 有活力的refresh 动词 使重新焕发活力refreshed 焕发活力的 vital 有活力的 有生命力的 生死攸关的 至关重要的 （important significant） essential 本质的 精华的 至关重要的 必不可少的 essence 名词 精华 本质 tiny 微小的 casual 放松的 休闲的 随意的casual wear 休闲装 total 总的 名词 总数 总值 vulnerable 脆弱的 易受伤害的 be ~ to … 易受 。。。上海的vulnerability 脆弱性 易受伤害性 弱点 avoidable 可避免的avoid 避免unavoidable 不可避免的 intention 名词 打算 意图 目的intend 动词 打算 企图intend to do something 打算做某事tend to ,,,趋向于 往往会 detection 名词 侦察 侦测detect 侦察 侦探detector 名词 探测器detective 侦探 tension 紧张tense 紧张的 documented 有记录的document 文件 文献 文献记录 determined 决定的 下决心的 坚定的determine 决心 决定 坚定 shared 共享的 共同的share 共享 分享 train 名词 火车 串 动词 培训 训练a train of 一串trained 被培训的 被训练的 accustomed 习惯的accustom 动词 使其习惯 specialized 专门的 专业化的special 特殊的 专业的 专门的specialist 专家 专业人员specialize 使 专门 使专门化 使 专业化 maximum 最大值minimum 最小值 principal 校长 负责人 主要的 首要的principle 原则 in principle在原则上 provoke 动词 挑衅 激怒 激发 激起evoke动词 呼唤 唤起provoking 发人深思的 = thoughtfar-reaching 形容词 影响深远的 意义深远的 basis 基础base。。。on… 使。。。基于。。。be based on 基于 monitor 班长 监视器 显示器 动词 检测 监视 symbol 象征symbolize动词 使象征 象征 = representrepresent动词代表=stand for art 艺术artist 跟上 赶上 =catch up with = keep up with = keep pace with = follow prevalent 流行的 普遍的 普及的popular popularize 使流行 使普及 component 组成成分 构成成分 形容词 组成的 构成的 consistent 连续的 连贯的 一致的 object 物理 目标 动词 反对=oppose（oppose to doing something反对做某事）objection 反对objective 客观的 名词 目标 reject 拒绝 approaching approach 动词 接近 靠近 处理 探讨（问题）名词 方法 途径 underlying underline 下划线 动词 在…之下划线 强调 重视underlie 动词 位于…之下 构成….的基础underlying 在下面的 潜在的underlying trend潜在的趋势 visualizing visualize 动词 设想 想象visual 视觉的visual effect视觉效果 vision 名词事业 景象 风景 远见visible 可看得见的 可视 的 明显的invisible surrounding 环绕的 围绕的 环绕 围绕round surround 动词 环绕 围绕 surroundings 周围的环境 attach 动词 粘贴 衣服touch 触摸detach v. 脱离 分离detach from…与。。。相分离 contact 动词 接触 联系 contend 动词 竞争 争论 声称tend to 趋向于 往往会 contract v . 收缩 缩短 签合同 订契约 n . 合同 契约 conduct 指挥 带领 引领 进行 n . 行为 运行duct-引导introduce 介绍 引入 引进introduction 介绍 引导conductor n . 指挥家 乘务员 导体 contest v. + n . 测试 检测 测验 比赛 continuous 连续的 继续的continue endurance endure v . 使持续 使忍受 foster v . 养育 培养 cultivate v . 栽培 培养foster the spirit innovation 配演创新精神 improve v. 改善 改进 提高improvement n . with the improving of living standard of people,more and more people can afford travelling abroad intrinsic a . 本质的intrinsically ad . 本质地 本质上地 relatively relate v.联系 叙述 讲述relation n . 联系 关系 叙述 讲述relationship n . 关系relative a. 相联系的 相关的 相对的relatively ad . 相关地 相对地 相互联系地absolutely 绝对地 完全地 similarly ad . 相似地 virtually previously ad. 以前地prensently ad . 现在地 目前地laterly 后来later后来 increasingly 越来越…+形容词 increasingly small 越来越小 patiently patient病人 耐心的 briefly ad . 简洁地 简要地 experience v . 经历 n . 经验 explore 探索 graduate v . 毕业graduate from … 从 …毕业violate v . 违反 违背violation n . 违反 违背violent a. 暴力的violence n . 暴力 operate v . 操作 做手术operation n . 操作 cooperation n . 合作 promote v . 推动 促进 推销 促销 晋升 升职remote control 遥控motion n . 移动 运动promotion n . worsen v . 使糟糕 恶化worse a . 糟糕的 widen v . 加宽 扩宽 weaken v . 弱化 削弱 strengthen v . 强化strong a . 强壮的strength n . 强壮 力量 强势 circumstance 处境under no circumstances 在任何情况下都不（放在句首要倒装）under no circumstances should we pollute the environment under no circumstances will I give up loving you cover v . 封面 覆该 支付 报道（an event）recover v . 恢复 复苏 = revive v . 复活 复苏 rare a . 稀少的 稀有的 rare bird 稀有的鸟 与众不同地人 特立独行的人rarely ad. 稀有的 稀少地 几乎不=hardly realistic a . 现实的 真实的 reality n . 现实 site n . 地点 点website n . 网站 站点","categories":[],"tags":[]},{"title":"191017-JAVA-IO流(3)-其他流","slug":"191017-JAVA-IO流-3-其他流","date":"2019-11-17T07:44:02.000Z","updated":"2019-11-17T09:10:58.171Z","comments":true,"path":"2019/11/17/191017-JAVA-IO流-3-其他流/","link":"","permalink":"https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/","excerpt":"","text":"昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 缓冲流 缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1 - 字节缓冲流1.1 - 字节缓冲输出流java.io.BufferedOutputStream extends OutputStream BufferedOutputStream:字节缓冲输出流 继承自父类的共性成员方法: - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 - public abstract void write(int b) ：将指定的字节输出流。1.1.1 - 构造方法 BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 参数:OutputStream out:字节输出流 我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率 int size:指定缓冲流内部缓冲区的大小,不指定默认 1.1.2 - 使用步骤(重点)​ 1.创建FileOutputStream对象,构造方法中绑定要输出的目的地​ 2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率​ 3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中​ 4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中(不做此步骤，数据无法成功写入)​ 5.释放资源(会先调用flush方法刷新数据,第4部可以省略) 123456789101112public static void main(String[] args) throws IOException &#123; //1.创建FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 BufferedOutputStream bos = new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 bos.write(\"我把数据写入到内部缓冲区中\".getBytes()); //4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 bos.flush(); //5.释放资源(会先调用flush方法刷新数据,第4部可以省略) bos.close(); &#125; 1.2 - 字节缓冲输入流java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 1234继承自父类的成员方法: int read()从输入流中读取数据的下一个字节。 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 void close() 关闭此输入流并释放与该流关联的所有系统资源。 1.2.1 - 构造方法​ BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。​ BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。​ 参数:​ InputStream in:字节输入流​ 我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率​ int size:指定缓冲流内部缓冲区的大小,不指定默认 1.2.2 - 使用步骤(重点)​ 1.创建FileInputStream对象,构造方法中绑定要读取的数据源​ 2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率​ 3.使用BufferedInputStream对象中的方法read,读取文件​ 4.释放资源 1234567891011121314151617181920212223public static void main(String[] args) throws IOException &#123; //1.创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 BufferedInputStream bis = new BufferedInputStream(fis); //3.使用BufferedInputStream对象中的方法read,读取文件 //int read()从输入流中读取数据的下一个字节。 /*int len = 0;//记录每次读取到的字节 while((len = bis.read())!=-1)&#123; System.out.println(len); &#125;*/ //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes =new byte[1024];//存储每次读取的数据 int len = 0; //记录每次读取的有效字节个数 while((len = bis.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //4.释放资源 bis.close(); &#125; 1.3 - 文件复制与之前的IO流一样的步骤，这次加入下效率测试，从结果可见，缓存流的读写速度比普通IO流快很多。 普通IO流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 文件复制练习:一读一写 明确: 数据源: c:\\\\1.jpg 数据的目的地: d:\\\\1.jpg 文件复制的步骤: 1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 3.使用字节输入流对象中的方法read读取文件 4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 5.释放资源 文件的大小:780,831 字节 一次读写一个字节:6043毫秒 使用数组缓冲读取多个字节,写入多个字节:10毫秒 */public class Demo01CopyFile &#123; public static void main(String[] args) throws IOException &#123; long s = System.currentTimeMillis(); //1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"c:\\\\1.jpg\"); //2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"d:\\\\1.jpg\"); //一次读取一个字节写入一个字节的方式 //3.使用字节输入流对象中的方法read读取文件 /*int len = 0; while((len = fis.read())!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); &#125;*/ //使用数组缓冲读取多个字节,写入多个字节 byte[] bytes = new byte[1024]; //3.使用字节输入流对象中的方法read读取文件 int len = 0;//每次读取的有效字节个数 while((len = fis.read(bytes))!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(bytes,0,len); &#125; //5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了) fos.close(); fis.close(); long e = System.currentTimeMillis(); System.out.println(\"复制文件共耗时:\"+(e-s)+\"毫秒\"); &#125;&#125; 缓存流 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 文件复制练习:一读一写 明确: 数据源: c:\\\\1.jpg 数据的目的地: d:\\\\1.jpg 文件复制的步骤: 1.创建字节缓冲输入流对象,构造方法中传递字节输入流 2.创建字节缓冲输出流对象,构造方法中传递字节输出流 3.使用字节缓冲输入流对象中的方法read,读取文件 4.使用字节缓冲输出流中的方法write,把读取的数据写入到内部缓冲区中 5.释放资源(会先把缓冲区中的数据,刷新到文件中) 文件的大小:780,831 字节 一次读写一个字节:32毫秒 使用数组缓冲读取多个字节,写入多个字节:5毫秒 */public class Demo02CopyFile &#123; public static void main(String[] args) throws IOException &#123; long s = System.currentTimeMillis(); //1.创建字节缓冲输入流对象,构造方法中传递字节输入流 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"c:\\\\1.jpg\")); //2.创建字节缓冲输出流对象,构造方法中传递字节输出流 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"d:\\\\1.jpg\")); //3.使用字节缓冲输入流对象中的方法read,读取文件 //一次读取一个字节写入一个字节的方式 /*int len = 0; while((len = bis.read())!=-1)&#123; bos.write(len); &#125;*/ //使用数组缓冲读取多个字节,写入多个字节 byte[] bytes = new byte[1024]; int len = 0; while((len = bis.read(bytes))!=-1)&#123; bos.write(bytes,0,len); &#125; bos.close(); bis.close(); long e = System.currentTimeMillis(); System.out.println(\"复制文件共耗时:\"+(e-s)+\"毫秒\"); &#125;&#125; 2 - 字符缓冲流2.1 - 字符缓冲输出流java.io.BufferedWriter extends Writer BufferedWriter:字符缓冲输出流 继承自父类的共性成员方法: - void write(int c) 写入单个字符。 - void write(char[] cbuf)写入字符数组。 - abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 - void write(String str)写入字符串。 - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 - void flush()刷新该流的缓冲。 - void close() 关闭此流，但要先刷新它。 2.1.1 - 构造方法:​ BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。​ BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。​ 参数:​ Writer out:字符输出流​ 我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率​ int sz:指定缓冲区的大小,不写默认大小 2.1.2 - 特有的成员方法​ void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符​ 换行:换行符号​ windows:\\r\\n​ linux:/n​ mac:/r 2.1.3 - 使用步骤​ 1.创建字符缓冲输出流对象,构造方法中传递字符输出流​ 2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中​ 3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中​ 4.释放资源 123456789101112131415public static void main(String[] args) throws IOException &#123; //System.out.println(); //1.创建字符缓冲输出流对象,构造方法中传递字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\c.txt\")); //2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 for (int i = 0; i &lt;10 ; i++) &#123; bw.write(\"传智播客\"); //bw.write(\"\\r\\n\"); bw.newLine(); &#125; //3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 bw.flush(); //4.释放资源 bw.close(); &#125; 2.2 - 字符缓冲输入流java.io.BufferedReader extends Reader BufferedReader:字符缓冲输入流 继承自父类的共性成员方法: int read() 读取单个字符并返回。 int read(char[] cbuf)一次读取多个字符,将字符读入数组。 void close() 关闭该流并释放与之关联的所有资源。 2.2.1 - 构造方法:​ BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。​ BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。​ 参数:​ Reader in:字符输入流​ 我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率 2.2.2 - 特有的成员方法​ String readLine() 读取一个文本行。读取一行数据​ 行的终止符号:通过下列字符之一即可认为某行已终止：换行 (‘\\n’)、回车 (‘\\r’) 或回车后直接跟着换行(\\r\\n)。​ 返回值:​ 包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 2.2.3 - 使用步骤​ 1.创建字符缓冲输入流对象,构造方法中传递字符输入流​ 2.使用字符缓冲输入流对象中的方法read/readLine读取文本​ 3.释放资源 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException &#123; //1.创建字符缓冲输入流对象,构造方法中传递字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\c.txt\")); //2.使用字符缓冲输入流对象中的方法read/readLine读取文本 /*String line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line);*/ /* 发下以上读取是一个重复的过程,所以可以使用循环优化 不知道文件中有多少行数据,所以使用while循环 while的结束条件,读取到null结束 */ String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; //3.释放资源 br.close(); &#125; 2.3 - 练习：文本排序练习: ​ 将in.txt的文本内容排序后写入到out.txt ​ 对文本的内容进行排序​ 按照(1,2,3….)顺序排序​ 分析:​ 1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本​ 2.创建字符缓冲输入流对象,构造方法中绑定字符输入流​ 3.创建字符缓冲输出流对象,构造方法中绑定字符输出流​ 4.使用字符缓冲输入流中的方法readline,逐行读取文本​ 5.对读取到的文本进行切割,获取行中的序号和文本内容​ 6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)​ 7.遍历HashMap集合,获取每一个键值对​ 8.把每一个键值对,拼接为一个文本行​ 9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中​ 10.释放资源 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException &#123; //1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); //2.创建字符缓冲输入流对象,构造方法中绑定字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\in.txt\")); //3.创建字符缓冲输出流对象,构造方法中绑定字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\out.txt\")); //4.使用字符缓冲输入流中的方法readline,逐行读取文本 String line; while((line = br.readLine())!=null)&#123; //5.对读取到的文本进行切割,获取行中的序号和文本内容 String[] arr = line.split(\"\\\\.\"); //6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..) map.put(arr[0],arr[1]); &#125; //7.遍历HashMap集合,获取每一个键值对 for(String key : map.keySet())&#123; String value = map.get(key); //8.把每一个键值对,拼接为一个文本行 line = key + \".\" + value; //9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中 bw.write(line); bw.newLine();//写换行 &#125; //10.释放资源 bw.close(); br.close(); &#125; #转换流 1 - 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码问题（乱码）在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112/* FileReader可以读取IDE默认编码格式(UTF-8)的文件 FileReader读取系统默认编码(中文GBK)会产生乱码��� */public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(\"10_IO\\\\我是GBK格式的文本.txt\"); int len = 0; while((len = fr.read())!=-1)&#123; System.out.print((char)len); &#125; fr.close(); &#125; 那么如何读取GBK编码的文件呢？ 2 - InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 java.io.InputStreamReader extends Reader InputStreamReader:是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码:把看不懂的变成能看懂的) 继承自父类的共性成员方法: int read() 读取单个字符并返回。 int read(char[] cbuf)一次读取多个字符,将字符读入数组。 void close() 关闭该流并释放与之关联的所有资源。 2.1 - 构造方法​ InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。​ InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。​ 参数:​ InputStream in:字节输入流,用来读取文件中保存的字节​ String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8 2.2 - 使用步骤​ 1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称​ 2.使用InputStreamReader对象中的方法read读取文件​ 3.释放资源 注意事项: 构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码 1234567891011121314151617181920212223242526272829303132/* 使用InputStreamReader读取GBK格式的文件 */ private static void read_gbk() throws IOException &#123; //1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称 //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"10_IO\\\\gbk.txt\"),\"UTF-8\");//??? InputStreamReader isr = new InputStreamReader(new FileInputStream(\"10_IO\\\\gbk.txt\"),\"GBK\");//你好 //2.使用InputStreamReader对象中的方法read读取文件 int len = 0; while((len = isr.read())!=-1)&#123; System.out.println((char)len); &#125; //3.释放资源 isr.close(); &#125; /* 使用InputStreamReader读取UTF-8格式的文件 */ private static void read_utf_8() throws IOException &#123; //1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称 //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"10_IO\\\\utf_8.txt\"),\"UTF-8\"); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"10_IO\\\\utf_8.txt\"));//不指定默认使用UTF-8 //2.使用InputStreamReader对象中的方法read读取文件 int len = 0; while((len = isr.read())!=-1)&#123; System.out.println((char)len); &#125; //3.释放资源 isr.close(); &#125; 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 3 - OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 java.io.OutputStreamWriter extends Writer OutputStreamWriter: 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码:把能看懂的变成看不懂) 继续自父类的共性成员方法: - void write(int c) 写入单个字符。 - void write(char[] cbuf)写入字符数组。 - abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 - void write(String str)写入字符串。 - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 - void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 3.1 - 构造方法​ OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。​ OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。​ 参数: OutputStream out:字节输出流,可以用来写转换之后的字节到文件中 String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8 3.2 - 使用步骤​ 1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称​ 2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)​ 3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)​ 4.释放资源 12345678910111213141516171819202122232425262728/* 使用转换流OutputStreamWriter写GBK格式的文件*/private static void write_gbk() throws IOException &#123; //1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"10_IO\\\\gbk.txt\"),\"GBK\"); //2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码) osw.write(\"你好\"); //3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) osw.flush(); //4.释放资源 osw.close();&#125;/* 使用转换流OutputStreamWriter写UTF-8格式的文件*/private static void write_utf_8() throws IOException &#123; //1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称 //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"10_IO\\\\utf_8.txt\"),\"utf-8\"); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"10_IO\\\\utf_8.txt\"));//不指定默认使用UTF-8 //2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码) osw.write(\"你好\"); //3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) osw.flush(); //4.释放资源 osw.close();&#125; 4 - 练习 ：转换文件编码 练习：转换文件编码 将GBK编码的文本文件，转换为UTF-8编码的文本文件。 分析: 1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK 2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8 3.使用InputStreamReader对象中的方法read读取文件 4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中 5.释放资源 123456789101112131415public static void main(String[] args) throws IOException &#123; //1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK InputStreamReader isr = new InputStreamReader(new FileInputStream(\"10_IO\\\\我是GBK格式的文本.txt\"),\"GBK\"); //2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"10_IO\\\\我是utf_8格式的文件.txt\"),\"UTF-8\"); //3.使用InputStreamReader对象中的方法read读取文件 int len = 0; while((len = isr.read())!=-1)&#123; //4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中 osw.write(len); &#125; //5.释放资源 osw.close(); isr.close(); &#125; 序列化流1 - 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 2 - ObjectOutputStream类java.io.ObjectOutputStream extends OutputStream ObjectOutputStream:对象的序列化流 作用:把对象以流的方式写入到文件中保存 2.1 - 构造方法​ ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。​ 参数:​ OutputStream out:字节输出流 2.2 - 特有的成员方法​ void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。 2.3 - 使用步骤​ 1.创建ObjectOutputStream对象,构造方法中传递字节输出流​ 2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中​ 3.释放资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.itheima.demo04.ObjectStream;import java.io.Serializable;/* 序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 Serializable接口也叫标记型接口 要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记 当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记 有:就可以序列化和反序列化 没有:就会抛出 NotSerializableException异常 去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意 static关键字:静态关键字 静态优先于非静态加载到内存中(静态优先于对象进入到内存中) 被static修饰的成员变量不能被序列化的,序列化的都是对象 private static int age; oos.writeObject(new Person(\"小美女\",18)); Object o = ois.readObject(); Person&#123;name='小美女', age=0&#125; transient关键字:瞬态关键字 被transient修饰成员变量,不能被序列化 private transient int age; oos.writeObject(new Person(\"小美女\",18)); Object o = ois.readObject(); Person&#123;name='小美女', age=0&#125; */public class Person implements Serializable&#123; private static final long serialVersionUID = 1L; private String name; //private static int age; //private transient int age; public int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 12345678public static void main(String[] args) throws IOException &#123; //1.创建ObjectOutputStream对象,构造方法中传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"10_IO\\\\person.txt\")); //2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中 oos.writeObject(new Person(\"小美女\",18)); //3.释放资源 oos.close(); &#125; 3 - ObjectInputStream类java.io.ObjectInputStream extends InputStreamObjectInputStream:对象的反序列化流作用:把文件中保存的对象,以流的方式读取出来使用 3.1 - 构造方法​ ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。​ 参数:​ InputStream in:字节输入流 3.2 - 特有的成员方法​ Object readObject() 从 ObjectInputStream 读取对象。 3.3 - 使用步骤​ 1.创建ObjectInputStream对象,构造方法中传递字节输入流​ 2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件​ 3.释放资源​ 4.使用读取出来的对象(打印) readObject方法声明抛出了ClassNotFoundException(class文件找不到异常) 当不存在对象的class文件时抛出此异常 反序列化的前提: 1.类必须实现Serializable 2.必须存在类对应的class文件 123456789101112public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.创建ObjectInputStream对象,构造方法中传递字节输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10_IO\\\\person.txt\")); //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 Object o = ois.readObject(); //3.释放资源 ois.close(); //4.使用读取出来的对象(打印) System.out.println(o); Person p = (Person)o; System.out.println(p.getName()+p.getAge()); &#125; 4 - 练习：序列化集合 当我们想在文件中保存多个对象的时候 可以把多个对象存储到一个集合中 对集合进序列化和反序列化 分析: 1.定义一个存储Person对象的ArrayList集合 2.往ArrayList集合中存储Person对象 3.创建一个序列化流ObjectOutputStream对象 4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化 5.创建一个反序列化ObjectInputStream对象 6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合 7.把Object类型的集合转换为ArrayList类型 8.遍历ArrayList集合 9.释放资源123456789101112131415161718192021public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.定义一个存储Person对象的ArrayList集合 ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); //2.往ArrayList集合中存储Person对象 list.add(new Person(\"张三\",18)); list.add(new Person(\"李四\",19)); list.add(new Person(\"王五\",20)); //3.创建一个序列化流ObjectOutputStream对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"10_IO\\\\list.txt\")); //4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化 oos.writeObject(list); //5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10_IO\\\\list.txt\")); //6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合 Object o = ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o; //8.遍历ArrayList集合 for (Person p : list2) &#123; System.out.println(p); &#125; 打印流java.io.PrintStream:打印流 PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 PrintStream特点: 1.只负责数据的输出,不负责数据的读取 2.与其他输出流不同，PrintStream 永远不会抛出 IOException 3.有特有的方法,print,println void print(任意类型的值) void println(任意类型的值并换行) ## 1 - 构造方法: ​ PrintStream(File file):输出的目的地是一个文件​ PrintStream(OutputStream out):输出的目的地是一个字节输出流​ PrintStream(String fileName) :输出的目的地是一个文件路径​ PrintStream extends OutputStream​ 继承自父类的成员方法: - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 - public abstract void write(int b) ：将指定的字节输出流。 注意: ​ 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a ​ 如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;971234567891011121314151617public static void main(String[] args) throws FileNotFoundException &#123; //System.out.println(\"HelloWorld\"); //创建打印流PrintStream对象,构造方法中绑定要输出的目的地 PrintStream ps = new PrintStream(\"10_IO\\\\print.txt\"); //如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a ps.write(97); //如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97 ps.println(97); ps.println(8.8); ps.println('a'); ps.println(\"HelloWorld\"); ps.println(true); //释放资源 ps.close(); &#125; 可以改变输出语句的目的地(打印流的流向) 输出语句,默认在控制台输出 使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地 static void setOut(PrintStream out) 重新分配“标准”输出流。 123456789public static void main(String[] args) throws FileNotFoundException &#123; System.out.println(\"我是在控制台输出\"); PrintStream ps = new PrintStream(\"10_IO\\\\目的地是打印流.txt\"); System.setOut(ps);//把输出语句的目的地改变为打印流的目的地 System.out.println(\"我在打印流的目的地中输出\"); ps.close(); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://cometorbityh.github.io/tags/IO/"}]},{"title":"191016_JAVA_IO流(2)_IO流","slug":"191016-JAVA-IO流-2-IO流","date":"2019-11-16T13:28:49.000Z","updated":"2019-11-17T16:04:54.802Z","comments":true,"path":"2019/11/16/191016-JAVA-IO流-2-IO流/","link":"","permalink":"https://cometorbityh.github.io/2019/11/16/191016-JAVA-IO流-2-IO流/","excerpt":"","text":"IO流 1、字节输出流（内存 —&gt; 硬盘） 1.1、OutputStream public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 1.2、FileOutputStream public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称（文件路径）写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 写入数据的原理(内存–&gt;硬盘) java程序–&gt;JVM(java虚拟机)–&gt;OS(操作系统)–&gt;OS调用写数据的方法–&gt;把数据写入到文件中 字节输出流的使用步骤(重点): 1.传递路径：创建一个FileOutputStream对象,构造方法中传递写入数据的目的地 2.写入数据：调用FileOutputStream对象中的方法write,把数据写入到文件中 3.释放资源：(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)123456789101112131415161718192021222324252627282930package com.young.io;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Arrays;public class OutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; // 传递路径 FileOutputStream fos = new FileOutputStream(\"F:\\\\IO\\\\a.txt\"); // 写入数据(单个字节) //fos.write(97); //a (97---&gt;1100001---&gt;a，查询ASCII表) //写入数据(多个字节) //byte[] bytes = &#123;65,66,67,68,69&#125;; //ABCDE //byte[] bytes = &#123;-65,-66,-67,68,69&#125;; //烤紻E //fos.write(bytes); //fos.write(bytes,1,2);//BC //字符串转为字节数组 byte[] bytes2 = \"你好\".getBytes(); System.out.println(Arrays.toString(bytes2));//[-28, -67, -96, -27, -91, -67] fos.write(bytes2); // 释放资源 fos.close(); &#125;&#125; 1.2.2、续写/ 换行上述代码虽然成功写入了数据，但是每次重新运行都会清空数据重新创建文件，那么如何做到不清空数据，并且每次写入时换行？ 我们需要用到FIleOUtputStrem类的2个参数的构造方法，它可以做到追加写/ 续写 FileOutputStream(String name, boolean append)创建一个向具有指定 name 的文件中写入数据的输出文件流。 FileOutputStream(File file, boolean append)创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 参数: String name,File file:写入数据的目的地 boolean append:追加写开关 true:创建对象不会覆盖源文件,继续在文件的末尾追加写数据 false:创建一个新文件,覆盖源文件 写换行:写换行符号 windows:\\r\\n linux:/n ​ mac:/r 123456789101112public static void main(String[] args) throws IOException &#123; // 传递路径（追加写） FileOutputStream fos = new FileOutputStream(\"F:\\\\IO\\\\a.txt\", true); //写入数据(多个字节) for (int i=0;i&lt;5;i++)&#123; fos.write(\"你好\".getBytes()); fos.write(\"\\r\\n\".getBytes()); //换行 &#125; // 释放资源 fos.close(); &#125; 2、字节输入流（硬盘 —&gt; 内存） 2.1、InputStreamint read()从输入流中读取数据的下一个字节。int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。void close() 关闭此输入流并释放与该流关联的所有系统资源。 2.2、FileInputStream2.2.1、构造方法FileInputStream(String name) FileInputStream(File file) 参数:读取文件的数据源 String name:文件的路径 File file:文件 构造方法的作用: 1.会创建一个FileInputStream对象 2.会把FileInputStream对象指定构造方法中要读取的文件 读取数据的原理(硬盘--&gt;内存) java程序--&gt;JVM--&gt;OS--&gt;OS读取数据的方法--&gt;读取文件 字节输入流的使用步骤(重点): 1.创建FileInputStream对象,构造方法中绑定要读取的数据源 2.使用FileInputStream对象中的方法read,读取文件 3.释放资源123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws IOException &#123; // 传递路径（追加写） FileInputStream fis = new FileInputStream(\"F:\\\\IO\\\\a.txt\"); //(a.txt保存的数据为 \"abc\") //读取数据(单个字节) /*int content = fis.read(); System.out.println(content); //97 content = fis.read(); System.out.println(content); //98 content = fis.read(); System.out.println(content); //99 content = fis.read(); System.out.println(content); //-1 (读完)*/ //读取数据(循环读取，读到-1时结束) /*int len = 0; while((len = fis.read())!=-1)&#123; System.out.print(len); //979899 System.out.print((char)len); //abc &#125;*/ // 读取数据（多个字节，byte数组） byte[] bytes = new byte[1024];//存储读取到的多个字节 int len = 0; //记录每次读取的有效字节个数 while((len = fis.read(bytes))!=-1)&#123; //把整个byte数组转换成字符串，本例中除了 abc 其余都是空格，造成资源浪费 //System.out.println(new String(bytes)); //String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数 System.out.println(new String(bytes,0,len)); &#125; // 释放资源 fis.close();&#125; 3、案例：文件复制12345678graph LRA(常用方法) A --&gt;|获取| A1[Decision] A --&gt;|判断| A2[Result one] A --&gt;|创建+删除| A3[Result two] A1 --&gt; a11[&quot;public String getAbsolutePath()&quot;] A1 --&gt; a12[Decision] A1 --&gt; a13[Decision] 文件复制练习:一读一写 明确: 数据源: c:\\\\1.jpg 数据的目的地: d:\\\\1.jpg 文件复制的步骤: 1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 3.使用字节输入流对象中的方法read读取文件 4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 5.释放资源1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException &#123; long s = System.currentTimeMillis(); //1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"c:\\\\1.jpg\"); //2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"d:\\\\1.jpg\"); //一次读取一个字节写入一个字节的方式 //3.使用字节输入流对象中的方法read读取文件 /*int len = 0; while((len = fis.read())!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); &#125;*/ //使用数组缓冲读取多个字节,写入多个字节 byte[] bytes = new byte[1024]; //3.使用字节输入流对象中的方法read读取文件 int len = 0;//每次读取的有效字节个数 while((len = fis.read(bytes))!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(bytes,0,len); &#125; //5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了) fos.close(); fis.close(); long e = System.currentTimeMillis(); System.out.println(\"复制文件共耗时:\"+(e-s)+\"毫秒\"); &#125; 3、字符输入流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 12345678910111213141516/* 使用字节流读取中文文件 1个中文 GBK:占用两个字节 UTF-8:占用3个字节 */public class Demo01InputStream &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(\"09_IOAndProperties\\\\c.txt\"); int len = 0; while((len = fis.read())!=-1)&#123; System.out.println((char)len); &#125; fis.close(); &#125;&#125; 3.1、Readerjava.io.Reader:字符输入流,是字符输入流的最顶层的父类,是一个抽象类，定义了一些共性的成员方法, 共性的成员方法: int read() 读取单个字符并返回。 int read(char[] cbuf)一次读取多个字符,将字符读入数组。 void close() 关闭该流并释放与之关联的所有资源。 3.2、FileReaderjava.io.FileReader extends InputStreamReader extends ReaderFileReader:文件字符输入流作用:把硬盘文件中的数据以字符的方式读取到内存中 构造方法: FileReader(String fileName) FileReader(File file) 参数:读取文件的数据源 String fileName:文件的路径 File file:一个文件 FileReader构造方法的作用: 1.创建一个FileReader对象 2.会把FileReader对象指向要读取的文件字符输入流的使用步骤: 1.创建FileReader对象,构造方法中绑定要读取的数据源 2.使用FileReader对象中的方法read读取文件 3.释放资源 1234567891011121314151617181920212223242526public static void main(String[] args) throws IOException &#123; //1.创建FileReader对象,构造方法中绑定要读取的数据源 FileReader fr = new FileReader(\"09_IOAndProperties\\\\c.txt\"); //2.使用FileReader对象中的方法read读取文件 //int read() 读取单个字符并返回。 /*int len = 0; while((len = fr.read())!=-1)&#123; System.out.print((char)len); &#125;*/ //int read(char[] cbuf)一次读取多个字符,将字符读入数组。 char[] cs = new char[1024];//该数组用来存储读取到的多个字符 int len = 0;//记录的是每次读取的有效字符个数 while((len = fr.read(cs))!=-1)&#123; /* String类的构造方法 String(char[] value) 把字符数组转换为字符串 String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数 */ System.out.println(new String(cs,0,len)); &#125; //3.释放资源 fr.close();&#125; 4、字符输出流4.1、Writerjava.io.Writer:字符输出流,是所有字符输出流的最顶层的父类,是一个抽象类 共性的成员方法: - void write(int c) 写入单个字符。 - void write(char[] cbuf)写入字符数组。 - abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 - void write(String str)写入字符串。 - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 - void flush()刷新该流的缓冲。 - void close() 关闭此流，但要先刷新它。 4.2、FileWriterjava.io.FileWriter extends OutputStreamWriter extends WriterFileWriter:文件字符输出流作用:把内存中字符数据写入到文件中 构造方法: FileWriter(File file)根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。 参数:写入数据的目的地 String fileName:文件的路径 File file:是一个文件 构造方法的作用: 1.会创建一个FileWriter对象 2.会根据构造方法中传递的文件/文件的路径,创建文件 3.会把FileWriter对象指向创建好的文件 字符输出流的使用步骤(重点): 1.创建FileWriter对象,构造方法中绑定要写入数据的目的地 2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程，因为计算机是按照字节存储的) 3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中 4.释放资源(会先把内存缓冲区中的数据刷新到文件中) 1234567891011public static void main(String[] args) throws IOException &#123; //1.创建FileWriter对象,构造方法中绑定要写入数据的目的地 FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\d.txt\"); //2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程) //void write(int c) 写入单个字符。 fw.write(97); //3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中 //fw.flush(); //4.释放资源(会先把内存缓冲区中的数据刷新到文件中) fw.close();&#125; flush方法和close方法的区别 - flush ：刷新缓冲区，流对象可以继续使用。 - close: 先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 1234567891011121314151617public static void main(String[] args) throws IOException &#123; //1.创建FileWriter对象,构造方法中绑定要写入数据的目的地 FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\e.txt\"); //2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程) //void write(int c) 写入单个字符。 fw.write(97); //3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中 fw.flush(); //刷新之后流可以继续使用 fw.write(98); //4.释放资源(会先把内存缓冲区中的数据刷新到文件中) fw.close(); //close方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了 fw.write(99);//IOException: Stream closed&#125; 1234567891011121314151617public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\f.txt\"); char[] cs = &#123;'a','b','c','d','e'&#125;; //void write(char[] cbuf)写入字符数组。 fw.write(cs);//abcde //void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 fw.write(cs,1,3);//bcd //void write(String str)写入字符串。 fw.write(\"传智播客\");//传智播客 //void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 fw.write(\"黑马程序员\",2,3);//程序员 fw.close();&#125; 续写和换行 续写,追加写:使用两个参数的构造方法 FileWriter(String fileName, boolean append) FileWriter(File file, boolean append) 参数: String fileName,File file:写入数据的目的地 boolean append:续写开关 true:不会创建新的文件覆盖源文件,可以续写; false:创建新的文件覆盖源文件 换行:换行符号 windows:\\r\\n linux:/n mac:/r 123456789public class Demo04Writer &#123; public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\g.txt\",true); for (int i = 0; i &lt;10 ; i++) &#123; fw.write(\"HelloWorld\"+i+\"\\r\\n\"); &#125; fw.close(); &#125;&#125; IO流的异常处理1、JDK7前 try…catch…finally在jdk1.7之前使用try catch finally 处理流中的异常 格式: try{ 可能会产出异常的代码 }catch(异常类变量 变量名){ 异常的处理逻辑 }finally{ 一定会指定的代码 资源释放 } 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; //提高变量fw的作用域,让finally可以使用 //变量在定义的时候,可以没有值,但是使用的时候必须有值 //fw = new FileWriter(\"09_IOAndProperties\\\\g.txt\",true); 执行失败,fw没有值,fw.close会报错 FileWriter fw = null; try&#123; //可能会产出异常的代码 fw = new FileWriter(\"w:\\\\09_IOAndProperties\\\\g.txt\",true); for (int i = 0; i &lt;10 ; i++) &#123; fw.write(\"HelloWorld\"+i+\"\\r\\n\"); &#125; &#125;catch(IOException e)&#123; //异常的处理逻辑 System.out.println(e); &#125;finally &#123; //一定会指定的代码 //创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放 if(fw!=null)&#123; try &#123; //fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 2、JDK7新特性在try的后边可以增加一个(),在括号中可以定义流对象 那么这个流对象的作用域就在try中有效 try中的代码执行完毕,会自动把流对象释放,不用写finally 格式: try(定义流对象;定义流对象….){ 可能会产出异常的代码 }catch(异常类变量 变量名){ 异常的处理逻辑 } 12345678910111213141516171819public static void main(String[] args) &#123; try(//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"c:\\\\1.jpg\"); //2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"d:\\\\1.jpg\");)&#123; //可能会产出异常的代码 //一次读取一个字节写入一个字节的方式 //3.使用字节输入流对象中的方法read读取文件 int len = 0; while((len = fis.read())!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); &#125; &#125;catch (IOException e)&#123; //异常的处理逻辑 System.out.println(e); &#125;&#125; 3、JDK9新特性JDK9新特性 try的前边可以定义流对象 在try后边的()中可以直接引入流对象的名称(变量名) 在try代码执行完毕之后,流对象也可以释放掉,不用写finally 格式: A a = new A(); B b = new B(); try(a,b){ 可能会产出异常的代码 }catch(异常类变量 变量名){ 异常的处理逻辑 } 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; //1.创建一个字节输入流对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"c:\\\\1.jpg\"); //2.创建一个字节输出流对象,构造方法中绑定要写入的目的地 FileOutputStream fos = new FileOutputStream(\"d:\\\\1.jpg\"); try(fis;fos)&#123; //一次读取一个字节写入一个字节的方式 //3.使用字节输入流对象中的方法read读取文件 int len = 0; while((len = fis.read())!=-1)&#123; //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中 fos.write(len); &#125; &#125;catch (IOException e)&#123; System.out.println(e); &#125; //fos.write(1);//此时会报异常，Stream Closed流已关闭&#125; Properties集合介绍java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt; Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。 Properties集合是一个唯一和IO流相结合的集合 可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用 属性列表中每个键及其对应值都是一个字符串。 Properties集合是一个双列集合,key和value默认都是字符串 1、Properties基本使用使用Properties集合存储数据,遍历取出Properties集合中的数据 Properties集合是一个双列集合,key和value默认都是字符串 Properties集合有一些操作字符串的特有方法 Object setProperty(String key, String value) 调用 Hashtable 的方法 put。 String getProperty(String key) 通过key找到value值,此方法相当于Map集合中的get(key)方法 Set stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串,此方法相当于Map集合中的keySet方法 12345678910111213141516171819private static void show01() &#123; //创建Properties集合对象 Properties prop = new Properties(); //使用setProperty往集合中添加数据 prop.setProperty(\"赵丽颖\",\"168\"); prop.setProperty(\"迪丽热巴\",\"165\"); prop.setProperty(\"古力娜扎\",\"160\"); //prop.put(1,true); //使用stringPropertyNames把Properties集合中的键取出,存储到一个Set集合中 Set&lt;String&gt; set = prop.stringPropertyNames(); //遍历Set集合,取出Properties集合的每一个键 for (String key : set) &#123; //使用getProperty方法通过key获取value String value = prop.getProperty(key); System.out.println(key+\"=\"+value); &#125;&#125; ##2、store()——Properties数据存储到硬盘 可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储void store(OutputStream out, String comments)void store(Writer writer, String comments)参数: OutputStream out:字节输出流,不能写入中文 Writer writer:字符输出流,可以写中文 String comments:注释,用来解释说明保存的文件是做什么用的 不能使用中文,会产生乱码,默认是Unicode编码 一般使用””空字符串 使用步骤: 1.创建Properties集合对象,添加数据 2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 4.释放资源 123456789101112131415161718private static void show02() throws IOException &#123; //1.创建Properties集合对象,添加数据 Properties prop = new Properties(); prop.setProperty(\"赵丽颖\",\"168\"); prop.setProperty(\"迪丽热巴\",\"165\"); prop.setProperty(\"古力娜扎\",\"160\"); //2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 //FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\prop.txt\"); //3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 //prop.store(fw,\"save data\"); //4.释放资源 //fw.close(); prop.store(new FileOutputStream(\"09_IOAndProperties\\\\prop2.txt\"),\"\");&#125; 3、load()——Properties读取硬盘数据（⭐）可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用 void load(InputStream inStream) void load(Reader reader) 参数: InputStream inStream:字节输入流,不能读取含有中文的键值对 Reader reader:字符输入流,能读取含有中文的键值对 使用步骤: 1.创建Properties集合对象 2.使用Properties集合对象中的方法load读取保存键值对的文件 3.遍历Properties集合 注意: 1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号) 2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取 3.存储键值对的文件中,键与值默认都是字符串,不用再加引号 12345678910111213private static void show03() throws IOException &#123; //1.创建Properties集合对象 Properties prop = new Properties(); //2.使用Properties集合对象中的方法load读取保存键值对的文件 prop.load(new FileReader(\"09_IOAndProperties\\\\prop.txt\")); //prop.load(new FileInputStream(\"09_IOAndProperties\\\\prop.txt\")); //3.遍历Properties集合 Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) &#123; String value = prop.getProperty(key); System.out.println(key+\"=\"+value); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://cometorbityh.github.io/tags/IO/"}]},{"title":"191013_JAVA_IO流(1)_File类","slug":"191013_JAVA_IO流(1)_File类","date":"2019-11-13T07:18:02.000Z","updated":"2019-11-17T09:11:10.293Z","comments":true,"path":"2019/11/13/191013_JAVA_IO流(1)_File类/","link":"","permalink":"https://cometorbityh.github.io/2019/11/13/191013_JAVA_IO流(1)_File类/","excerpt":"","text":"File类1、基本描述操作对象：文件和文件夹 概述：java.io.File 类是文件和目录路径名的抽象表示形式，主要用于文件和目录的创建、查找和删除等操作。 java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件/文件夹 删除文件/文件夹 获取文件/文件夹 判断文件/文件夹是否存在 对文件夹进行遍历 获取文件的大小 File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法 重点:记住这三个单词 file:文件 directory:文件夹/目录 path:路径2、[复习]路径的写法2.1、路径路径可以是以文件结尾,也可以是以文件夹结尾路径可以是相对路径,也可以是绝对路径路径可以是存在,也可以是不存在创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况 2.2、路径的分类 绝对路径:是一个完整的路径 以盘符(c:,D:)开始的路径 c:\\\\a.txt C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan\\\\123.txt D:\\\\demo\\\\b.txt 相对路径:是一个简化的路径 相对指的是相对于当前项目的根目录(C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan) 如果使用当前项目的根目录,路径可以简化书写 C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan\\\\123.txt--&gt;简化为: 123.txt(可以省略项目的根目录) 注意: 1.路径是不区分大小写 2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠 3、静态成员变量及常用方法3.1、静态成员变量 变量 描述 static String pathSeparator 路径分隔符（1个字符串）：Windows为分号，Linux为冒号 static char pathSeparatorChar 路径分隔符（字符）：与上述功能一致 static String separator 默认名称分隔符（1个字符串）：Windows为反斜杠，Linux为正斜杠 static char separatorChar 默认名称分隔符（字符）：与上述功能一致 3.2、构造方法 public File(String pathname） 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 public File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 public File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 3.3、常用方法3.3.1、获取功能的方法 public String getAbsolutePath() 返回此File的绝对路径名字符串 public String getPath() 将此File转换为路径名字符串 public String getName() 返回由此File表示的文件或目录的名称 public long length() 返回由此File表示的文件的长度（单位：字节） 3.3.2、判断功能的方法 public boolean exists() 此File表示的文件或目录是否实际存在 public boolean isDirectory() 判断构造方法中给定的路径是否以文件夹结尾 public boolean isFile() 判断构造方法中给定的路径是否以文件结尾 注意：isDirectory()和isFile()的使用前提：路径存在，否则都会返回false 硬盘中只有文件夹和文件，因此 isDirectory()和isFile() 是互斥的 3.3.3、创建 + 删除功能的方法 方法 描述 public boolean mkdir() true：文件夹不存在，创建单级空文件夹false：文件夹已存在 / 构造方法路径不存在 public boolean mkdirs() true：文件夹不存在，创建单级空文件夹 / 多级空文件夹 false：文件夹已存在，或构造方法路径不存在 public boolean createNewFile true：文件不存在，在file对象提供的路径创建一个空文件；false：文件存在；file对象的路径必须存在，若不存在会抛出异常IOException public boolean delete() 删除FIle对象对应的文件夹/ 文件（直接删除硬盘的，不走回收站）true：删除成功false：删除失败 / 构造方法路径不存在 3.3.4、遍历目录功能的方法 public String[] list() 遍历File对象给出的目录中的所有文件和文件夹的名称，将其保存在String数组中 public List[] listFiles() 遍历File对象给出的目录中的所有文件和文件夹的全路径，将其保存在List数组中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package com.young.io;import com.sun.org.apache.xerces.internal.xs.LSInputList;import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; //demo01(); //demo02(); //demo03(); //demo04(); //demo05(); &#125; /*构造方法*/ public static void demo01()&#123; // 文件路径名 File f1 = new File(\"C:\\\\IO\"); File f2 = new File(\"C:\\\\IO\\\\demo1.txt\"); System.out.println(f1); // C:\\IO System.out.println(f2); // C:\\IO\\demo1.txt // 通过父路径和子路径字符串 File f3 = new File(\"C:\\\\IO\", \"demo2.txt\"); System.out.println(f3); // C:\\IO\\demo2.txt // 通过父级File对象和子路径字符串 File f4 = new File(f1, \"demo3.txt\"); System.out.println(f4); // C:\\IO\\demo3.tx &#125; /* 获取功能的方法 */ public static void demo02()&#123; File f1 = new File(\"C:\\\\Users\\\\Administrator.RG4-44\\\\Desktop\\\\demo01\\\\demo01.iml\"); File f2 = new File(\"demo01.iml\"); // 获取file对象的绝对路径字符串（相对/绝对都转为绝对） System.out.println(f1.getAbsolutePath()); //C:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\demo01.iml System.out.println(f2.getAbsolutePath()); //C:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\demo01.iml //获取file对象的路径字符串（路径保持原样） System.out.println(f1.getPath()); //C:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\demo01.iml System.out.println(f2.getPath()); //demo01.iml //File类的toString() == getPath() System.out.println(f1.toString()); //C:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\demo01.iml System.out.println(f2.toString()); //demo01.iml //获取File对象的路径的结尾部分 File f3 = new File(\"C:\\\\Users\\\\Administrator.RG4-44\\\\Desktop\\\\demo01\"); System.out.println(f1.getName()); //demo01.iml System.out.println(f3.getName()); //demo01 //获取FIle对象指向的文件大小（单位字节，注意文件夹没有大小） System.out.println(f1.length()); //939 System.out.println(f3.length()); //4096 &#125; /* 判断功能的方法 */ public static void demo03()&#123; File f1 = new File(\"F:\\\\IO\"); File f2 = new File(\"F:\\\\IO\\\\aaa.txt\"); if(f1.exists())&#123; System.out.println(f1.isFile()); //false System.out.println(f1.isDirectory()); //true &#125; //若不存在，则没必要获取 if (f2.exists())&#123; System.out.println(f2.isFile()); //true System.out.println(f2.isDirectory()); //false &#125; &#125; /* 创建 + 删除 */ public static void demo04() throws IOException &#123; // 创建单级文件夹 File f1 = new File(\"F:\\\\IO\\\\test01\"); //文件夹名为 “test01.txt” File f2 = new File(\"F:\\\\IO\\\\test02.txt\"); //文件夹名为 \"test02\" System.out.println(f1.mkdir()); //true System.out.println(f2.mkdir()); //true // 创建单级/多级文件夹 File f3 = new File(\"F:\\\\IO\\\\aaa\"); File f4 = new File(\"F:\\\\IO\\\\bbb\\\\ccc.txt\"); System.out.println(f3.mkdirs()); //true System.out.println(f4.mkdirs()); //true // 创建文件 File f5 = new File(\"F:\\\\IO\\\\file01.txt\"); //文件名为 \"file01.txt\" File f6 = new File(\"F:\\\\IO\\\\file02\"); //文件名为 \"file02\" System.out.println(f5.createNewFile()); //true System.out.println(f6.createNewFile()); //true //删除文件/文件夹 File f7 = new File(\"F:\\\\IO\\\\aaa\"); File f8 = new File(\"F:\\\\IO\\\\aaa.txt\"); System.out.println(f7.delete()); System.out.println(f8.delete()); &#125; //遍历目录功能的方法 public static void demo05()&#123; //遍历目录的文件和文件夹（包括隐藏文件/文件夹） File f1 = new File(\"F:\\\\IO\"); String[] list = f1.list(); for (String fileName: list)&#123; System.out.println(fileName); &#125; /* bbb file01.txt file02 test01 test02.txt */ File f2 = new File(\"F:\\\\IO\"); File[] files = f2.listFiles(); for (File file:files)&#123; System.out.println(file); &#125; /* F:\\IO\\bbb F:\\IO\\file01.txt F:\\IO\\file02 F:\\IO\\test01 F:\\IO\\test02.txt */ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cometorbityh.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://cometorbityh.github.io/tags/IO/"}]},{"title":"191111——JavaWeb之Session+Cookie","slug":"191111——JavaWeb之Session-Cookie","date":"2019-11-11T12:43:17.000Z","updated":"2019-11-13T07:14:12.260Z","comments":true,"path":"2019/11/11/191111——JavaWeb之Session-Cookie/","link":"","permalink":"https://cometorbityh.github.io/2019/11/11/191111——JavaWeb之Session-Cookie/","excerpt":"","text":"会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 Cookie本意“小饼干”，是客户端会话技术，将数据保存在客户端。 实现原理 基于响应头set-cookie和请求头cookie实现 Cookie的执行步骤： 步骤 方法 1. 创建Cookie对象 Cookie cookie = new Cookie(String name, String value) 2. 发送Cookie response.addCookie(Cookie cookie); 3. 获取Cookie,而后遍历Cookie Cookie[] cookies = request.getCookies(); 分别访问2个Servlet，Servlet发送Cookie，Servlet2获取Cookie并遍历，前提是浏览器不能关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.young.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo01\")public class CookieDemo01 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie cookie1 = new Cookie(\"msg\", \"success\"); Cookie cookie2 = new Cookie(\"code\", \"404\"); //2.发送Cookie response.addCookie(cookie1); response.addCookie(cookie2); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;package com.young.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo02\")public class CookieDemo02 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //3.获取Cookie Cookie[] cookies = request.getCookies(); for (Cookie cookie:cookies)&#123; String name = cookie.getName(); String value = cookie.getValue(); System.out.println(name + \"---\" + value); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;-------------控制台----------------msg---successcode---404device---11 有关Cookie的问题 一次可不可以发送多个cookie? 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ ​ 默认情况下，当浏览器关闭后，Cookie数据被销毁 ​ 实现持久化存储：在发送Cookie前加入方法setMaxAge(int seconds)即可。second的取值为： 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ ​ 在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3) ​ 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题 同Tomcat服务器的多个web项目： 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，则可以将path设置为“/“ 不同Tomcat服务器的多个web项目： setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 1. cookie存储数据在客户端浏览器，因此不安全 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别JSP：入门学习1. 概念： * Java Server Pages： java服务器端页面 * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 * 用于简化书写！！！ 2. 原理 * JSP本质上就是一个Servlet 3. JSP的脚本：JSP定义Java代码的方式 1. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 4. JSP的内置对象： * 在jsp页面中不需要获取和创建，可以直接使用的对象 * jsp一共有9个内置对象。 * 今天学习3个： * request * response * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前 5. 案例:改造Cookie案例Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门： 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： 获取数据：Object getAttribute(String name) 存储数据：void setAttribute(String name, Object value) 移除数据：void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(“JSESSIONID”,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化（序列化）： 在服务器正常关闭之前，将session对象序列化到硬盘上 session的活化（反序列化）： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 `&lt;session-timeout&gt;30&lt;/session-timeout&gt;` session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有","categories":[],"tags":[]},{"title":"191107——JavaWeb之Response","slug":"191107——Javaweb之Response","date":"2019-11-11T07:00:21.000Z","updated":"2019-11-15T15:20:38.557Z","comments":true,"path":"2019/11/11/191107——Javaweb之Response/","link":"","permalink":"https://cometorbityh.github.io/2019/11/11/191107——Javaweb之Response/","excerpt":"","text":"Http（二）响应消息：服务器端发送给客户端的数据 响应字符串格式 ​ HTTP/1.1 200 OK​ Content-Type: text/html;charset=UTF-8​ Content-Length: 101​ Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应消息的数据格式（1）响应行​ 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告知客户端浏览器本次请求和响应的一个状态（3位数字） 分类 描述 举例 1xx 服务器接收客户端消息，但没有接收完成， 等待一段时间后，发送1xx多状态码 2xx 成功 200：响应成功 3xx 重定向 302 重定向； 304 本地缓存（客户端本地已有，访问缓存即可） 4xx 客户端错误 404：请求路径没有对应资源 405：请求方式没有对应的doxxx方法 5xx 服务器端错误 500：服务器内部出现异常 （2）响应头​ 格式：头名称：值 常见的响应头 描述 Content-Type 服务器告知客户端本次响应体的数据格式 + 编码格式 Content-Length 响应体长度 Content-Disposition 服务器告知客户端以何种格式打开响应体数据* in-line：默认值，在当前页面内打开* attachment；filename=xxx：以附件形式打开响应体。如文件下载 （3）响应空行（4）响应体​ 响应体包含的是：真实传输的数据 Response对象功能1：设置响应消息（1）设置响应行 作用 方法 设置响应状态码 setStatus(int sc) （2）设置响应头 作用 方法 设置/修改响应体 setHeader(String name,String value) （3）设置响应体​ 步骤： 获取输出流 类型 方法 字符输出流 PrintWriter getWriter() 字节输出流 ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 功能2：重定向重定向：资源跳转的方式 （1）方法 步骤 方法 1.设置状态码为302 response.setStatus(302); 2.设置响应头location，其值为重定向的路径 response.setHeader(“location”,”/demo/responseDemo2”); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546--- FirstServlet----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); //重定向 response.setStatus(302); response.setHeader(\"location\",\"/demo01/secondServlet\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;--- SecondServlet----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 这2个方法中，302和location都是固定值，只有重定向的路径是变量，每次写起来有点麻烦，因此Response类提供了一个方法，用来简化书写。 作用 方法 重定向 sendRedirect(String path) 1response.sendRedirect(\"/demo01/secondServlet\"); （2）特点 地址栏路径改变，路径为重定向后的url 重定向可以访问服务器外部的资源 response.sendRedirect(&quot;http://www.baidu.com&quot;); 重定向是2次请求（因此不能使用request域来共享数据） （3）重定向与请求转发案例 （1）输出字符数据服务器获取字符输出流输出到浏览器页面， 步骤：1. 获取字符输出流 2. 输出数据 注意：输出到浏览器时，可能会产生中文乱码，只要是因为服务器和浏览器的编码不一致导致的， 因此在获取输出流之前需要：①设置该流的默认编码 ② 告知浏览器响应体使用的编码。 使用response.setContentType(&quot;text/html;charset=utf-8&quot;);方法可解决中文乱码问题。 123456789101112131415161718192021222324252627282930313233package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/responseServlet\")public class ResponseServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码，防止浏览器乱码 //设置流的默认编码 //response.setCharacterEncoding(\"utf-8\"); //方式1 //告知浏览器，服务器发送的消息体数据的编码，建议浏览器使用该编码解码（其中也设置了流编码） //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //方式2 response.setContentType(\"text/html;charset=utf-8\"); //2.获取字符输出流对象，获取的流的默认编码是ISO-8859-1 PrintWriter pw = response.getWriter(); //3.输出数据 pw.write(\"你好，response\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; （2）输出字节数据服务器获取字节输出流输出到浏览器页面。 步骤：1. 获取字节输出流 2. 输出数据 中文乱码的解决方法与输出字符数据一致。 1234567891011121314151617181920212223242526package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/responseServlet\")public class ResponseServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码，防止浏览器乱码 response.setContentType(\"text/html;charset=utf-8\"); //2.获取字节输出流对象 ServletOutputStream sos = response.getOutputStream(); //3.输出数据 sos.write(\"你好，response\".getBytes(\"utf-8\")); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;","categories":[],"tags":[]},{"title":"191107——JavaWeb之Request","slug":"191107——Javaweb之Request","date":"2019-11-07T07:00:13.000Z","updated":"2019-11-15T15:22:31.573Z","comments":true,"path":"2019/11/07/191107——Javaweb之Request/","link":"","permalink":"https://cometorbityh.github.io/2019/11/07/191107——Javaweb之Request/","excerpt":"","text":"Http（一）Hyper Text Transfer Protocol超文本传输协议 传输协议：数据的传输协议/规则，定义了客户端和服务端通信时，发送数据的格式（请求消息和响应消息的格式） 特点 基于TCP／IP的高级协议（TCP是安全的协议，因此Http也是安全的协议） 默认端口号：80 基于请求/响应模型：一次请求对应一次响应，请求和响应一一对应。 无状态的协议：请求之间相互独立，不能交互数据 历史版本 1.0：每次请求都会建立一个新的连接。比如访问百度时，需要 获取到很多css和图片，每次请求到一张图片后都会断开连接，这样出现的结果就是耗时且耗费连接资源 1.1：复用上次请求的连接。每次请求到一张图片后会等待一段时间，若这段时间内还有数据要发送，就默认使用刚才那个连接，知道最后一个请求之后等待一段时间，发现没有数据需要发送了，即断开连接。 请求消息的数据格式请求行 请求方式 请求url 请求协议/版本 请求方式：Http协议有7种请求方式，常用的有get和post GET POST 请求参数在请求行的url后 请求参数在请求体中 请求的url长度有限制， 请求的url长度无限制 不太安全 相对安全 请求头（键值对的格式） 请求头名称：请求头值 常见请求头 解释 作用 User-Agent 浏览器告知服务器，其使用的浏览器版本信息 在服务器端获取该头的信息，解决浏览器兼容问题（不同浏览器解析数据方法不一样， 使得用户用不同的浏览器访问同一个资源看到相同的界面） Accept 告知服务器，其可解析可接收的文件格式 Accept-Language 支持的语言环境 Accept-Encoding 支持的压缩格式 Referer 告知服务器，当前请求的来源 防盗链做统计工作 Connection 连接：keep-alive，保持活着，表示的是该连接可被复用 Upgrade-insecure 升级信息 请求空行 分隔POST的请求头和请求体 请求体（只有Post有请求体，Get没有） 封装POST请求消息的请求参数 Request请求回忆之前创建Servlet类时，service方法中有2个参数，ServletRequest req和ServletResponse res，这2个参数分别封装了请求信息和响应消息。 1. request对象和response对象的原理request和response对象是由服务器创建的，而我们的任务就是使用它们； request对象是来获取请求信息的，response对象是来设置响应消息的 2. request对象的继承体系结构ServletRequest接口，HttpServletRequest接口继承自ServletRequest接口，而org.apache.catalina.connector.RequestFacade类继承HttpServletRequest接口，这个类是tomcat定义的，tomcat创建这个request对象，并传递给service方法 3. request对象的功能3.1. 获取请求消息数据（*3）（1）获取请求行数据GET /ProjectName/demo1?name=zhangsan HTTP/1.1 方法 含义 String getMethod() 获取请求方式 ：GET String getContextPath() 获取虚拟目录：/ProjectName String getServletPath() 获取Servlet路径: /demo1 String getQueryString() 获取get方式请求参数：name=zhangsan String getRequestURI() 获取请求URI：/ProjectName/demo1 StringBuffer getRequestURL() 获取请求URL：http://localhost/ProjectName/demo1 String getRemoteAddr() 获取客户机的IP地址： String getProtocol() 获取协议及版本：HTTP/1.1 URI ：统一资源标识符 ： /ProjectName/demo1——共和国 URL：统一资源定位符 ：http://localhost/ProjectName/demo1——中华人民共和国 1234567891011121314151617181920212223242526package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"获取请求方式method：\"+request.getMethod()); System.out.println(\"获取虚拟目录：\"+request.getContextPath()); System.out.println(\"获取Servlet路径：\"+request.getServletPath()); System.out.println(\"获取get方式的请求参数：\"+request.getQueryString()); System.out.println(\"获取请求的URI：\"+request.getRequestURI()); System.out.println(\"获取请求的URL：\"+request.getRequestURL()); System.out.println(\"获取客户机IP地址：\"+request.getRemoteAddr()); System.out.println(\"获取客户机协议及版本：\"+request.getProtocol()); &#125;&#125; （2）获取请求头数据 String getHeader(String name) 通过请求头的名称获取请求头的值 Enumeration getHeaderNames() 获取所有的请求头名称；注意该枚举类型实际是迭代器 12345678910111213141516171819202122232425262728293031323334353637383940package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取所有请求头的名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); //根据名称获取对应请求头的值 while(headerNames.hasMoreElements())&#123; String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name + \"---\" + value); &#125; &#125;&#125;--- 控制台数据----------------------------------------host---localhost:8080connection---keep-alivecache-control---max-age=0upgrade-insecure-requests---1user-agent---Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36accept---text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3accept-encoding---gzip, deflate, braccept-language---zh-CN,zh;q=0.9,en;q=0.8cookie---JSESSIONID=B2F7464DCB3037A05D6AF248ED2F938E; device=11 123456789101112131415161718192021222324252627282930313233package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求头数据：user-agent String agent = request.getHeader(\"user-agent\"); System.out.println(agent); //根据agent判断浏览器版本 if(agent.contains(\"Chrome\"))&#123; System.out.println(\"It is Chrome\"); &#125;else if(agent.contains(\"firefox\"))&#123; System.out.println(\"It is FireFox\"); &#125; &#125;&#125;--- 控制台数据----------------------------------------Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36It is Chrome （3）获取请求体数据请求体中封装了POST请求的请求参数，只有POST方式有请求体； request对象将请求体封装成流，因此需要用获取流的方式来获取请求体的内容 获取步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据（文件，图片等） 从流对象中获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--- index.jsp----------------------------------------&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo01/requestDemo\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;--- RequestDemo.java----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求消息的请求体 //1.读取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125;--- 控制台数据----------------------------------------username=zhangsan&amp;password=123456 3.2. 其他功能（1）获取请求参数通用方式（GET、POST均可） String getParameter(String name) 通过参数名获取参数值 String getParameterValues(String name) 根据参数名获取参数值的数组（复选框） Enumeration&lt;String.&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的map集合 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo01/requestDemo\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;游戏 &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;学习 &lt;input type=\"checkbox\" name=\"hobby\" value=\"sing\"&gt;唱歌&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.young.servlet;import com.sun.xml.internal.ws.client.sei.ValueSetter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.bind.ValidationEvent;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;import java.util.Map;import java.util.Set;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); System.out.println(\"getParameter ---&gt; \"+ \"username:\" + username + \",\" + \"password:\" + password); /*-------------------------------*/ String[] hobbies = request.getParameterValues(\"hobby\"); System.out.print(\"getParameterValues ---&gt; \" + \"hobby:\"); for (String hobby:hobbies)&#123; System.out.print(hobby + \" \"); &#125; System.out.println(); /*-------------------------------*/ Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); System.out.print(\"getParameterNames ---&gt; \"); while (parameterNames.hasMoreElements())&#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); System.out.print(name + \":\" + value + \" \"); &#125; System.out.println(); /*-------------------------------*/ Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); System.out.println(\"getParameterMap ---&gt;\"); //遍历Map的Key Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset)&#123; System.out.print(name + \":\"); //获取key对应的value数组 String[] values = parameterMap.get(name); for (String value : values)&#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; （2）获取请求参数中文乱码解决 get方式：tomcat8 已经将中文乱码问题解决，不会出现中文乱码 post方式：未解决。 解决方案：获取参数前，设置request的编码 方法 含义 request.setCharacterEncoding(“utf-8”); 设置request的编码为utf-8 （3）请求转发一种在服务器内部的资源跳转的方式。因此不会改变地址栏url 步骤 方法 通过request对象获取请求转发器对象 request.getRequestDispatcher(String path) 使用请求转发器对象来进行资源转发 forward(ServletRequest request, ServletResponse response) 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;--------------------------------------------------- package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); request.getRequestDispatcher(\"/secondServlet\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 特点： 浏览器地址不发生变化 只能转发到服务器内部的资源；如下代码无法转发到百度服务器 request.getRequestDispatcher(&quot;http://www.baidu.com&quot;).forward(request,response); 转发是一次请求，不是两次请求 （4）共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 request域的三个方法 方法 含义 void setAttribute(String name,Object obj) 在request域中存储数据 Object getAttribute(String name) 在request域中通过键获取值 void removeAttribute(String name) 在request域中移除键所对应的键值对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455---------------FirstServlet.java-----------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); request.setAttribute(\"msg\",\"success!\"); request.getRequestDispatcher(\"/secondServlet\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;---------------SecondServlet.java-----------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object msg = request.getAttribute(\"msg\"); System.out.println(\"msg --&gt;\" + msg); System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;---------------控制台-----------------this is firstServlet...msg --&gt;success!this is secondServlet... （5）获取ServletContext对象 方法 含义 ServletContext getServletContext() 获取ServletContext对象 123456789101112131415161718192021222324252627282930313233---------------RequestDemo.java-----------------package com.young.servlet;import com.sun.xml.internal.ws.client.sei.ValueSetter;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.bind.ValidationEvent;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;import java.util.Map;import java.util.Set;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext servletContext = request.getServletContext(); System.out.println(servletContext); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125;---------------控制台-----------------org.apache.catalina.core.ApplicationContextFacade@3060c493 ServletContext对象概念：代表整个web应用，可以和程序的容器(服务器)来通信 1. 获取方式（2种） 获取方式 方法 通过request对象获取 request.getServletContext() 通过HttpServlet获取 this.getServletContext() 2. ServletContext的功能（1）获取MIME类型 MIME类型：在互联网通信过程中定义的一种文件数据类型的标准 格式： 大类型/小类型 （例：text/html， image/jpeg） 获取：String getMimeType(String file) （2）域对象：共享数据ServletContext对象范围：共享所有用户所有请求的数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) （3）获取文件的真实(服务器)路径1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.young.servlet;import javax.servlet.Servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo\")public class ServletContextDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取ServletContext对象 ServletContext context1 = request.getServletContext(); ServletContext context2 = this.getServletContext(); System.out.println(context1); System.out.println(context2); //获取MIME类型 String mimeType = context2.getMimeType(\"a.jpg\"); System.out.println(mimeType); //获取文件真实路径 String test01 = context2.getRealPath(\"/WEB-INF/classes/test01.txt\"); //src目录下访问资源 System.out.println(test01); String test02 = context2.getRealPath(\"/WEB-INF/test02.txt\"); //WEB-INF目录下访问资源 System.out.println(test02); String test03 = context2.getRealPath(\"/test03.txt\"); //web目录下访问资源 System.out.println(test03); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;-------- 控制台输出结果 ----------------------org.apache.catalina.core.ApplicationContextFacade@1f5b43b6org.apache.catalina.core.ApplicationContextFacade@1f5b43b6image/jpegC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\WEB-INF\\classes\\test01.txtC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\WEB-INF\\test02.txtC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\test03.txt","categories":[],"tags":[]},{"title":"191106——JavaWeb之Servlet","slug":"191106——JavaWeb之Servlet","date":"2019-11-06T09:16:13.000Z","updated":"2019-11-11T07:02:46.303Z","comments":true,"path":"2019/11/06/191106——JavaWeb之Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/11/06/191106——JavaWeb之Servlet/","excerpt":"","text":"Servlet1. Servlet简介servlet = server applet，字面意思是：运行在服务器端的小程序 servlet就是一个接口，定义了Java类被浏览器访问到的规则。 ##2. 实现Servlet及其执行原理 查看Java EE8文档，发现servlet定义了5个方法。当一个类实现Servlet接口时，需要重写Servlet的方法。 定义一个类实现Servlet接口的4个步骤： （1）创建JAVA EE项目 （2）定义一个类，实现Servlet接口 （3）实现Servlet接口的抽象方法 （4）配置Servlet（在web.xml中配置） 执行原理： 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径； 查找web.xml文件，是否有&lt;url-pattern&gt;标签体内容； 若有，则找到对应的&lt;servlet-class&gt;全类名； tomcat会将字节码文件加载进内存，并且创建其对象，调用其方法。（反射操作） 3. Servlet的生命周期 方法 作用 生命周期 void init 初始化的方法，在Servlet被创建时执行，只执行一次 被创建 void service 提供服务的方法，每一个Servlet被访问时都会被执行，可执行多次 提供服务 void destroy 销毁的方法，在服务器正常关闭时执行，只执行一次 被销毁 其他2个方法 ServletConfig getServletConfig 获取ServletConfig对象，servlet的配置对象 String getServletInfo 获取Servlet的一些信息：版本、作者… Servlet对象什么时候被创建？ 默认情况：第一次被访问时创建。 特殊情况：在服务器启动时创建。配置web.xml下的&lt;servlet&gt;中的&lt;load-on-startup&gt;。 当值为负整数时，第一次被访问时创建。 当值为正整数或0时，在服务器启动时创建。值的范围为[0,10] 一个servlet在内存中有几个对象？ Servlet的init方法只执行1次，说明一个Servlet在内存中只存在一个对象，因此servlet是单例的。 多个用户同时访问时，可能存在安全问题。因此尽量不在Servlet中定义成员变量。若定义了成员变量，也不要有修改值的操作，因为这个变量会被所有用户访问到。 destroy方法是在servlet对象被销毁之前执行还是之后执行？ 好比临终遗言般，destroy应该是在Servlet销毁之前执行，一般用于释放资源。 4. Servlet 3.0注解配置Servlet 3.0加入了注解配置，使得Servlet可以不用配置web.xml文件，直接在Servlet类上添加注解@WebServlet(&quot;/demo&quot;)，其中/demo是url-pattern，这样子就大大简化了代码，也不需要配置servlet-name了。 urlpartten：Servlet访问路径，是个数组，因此可以设置多个路径 一个Servlet可以设置多个访问路径：@WebServlet({&quot;/aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;}) 路径配置规则（*是通配符，优先级是最低的） /xxx：单层路径（/*随意起名都可访问该Servlet类） /xxx/xxx：双层路径（/xxx/*表示第二层随意起名都可访问该Servlet类） *.do（注意前面不加“/”） 5. Servlet的体系结构通过之前的小案例，了解了Servlet的基本操作。但是发现每次实现Servlet接口都要重写其5个方法，单往往我们只需要其中的service方法，其他4个方法一般不会使用。因此有没有什么方式能让我们只需要重写service方法就行了呢？有！ 我们去看下Servlet接口的继承结构： Servlet接口有一个实现类GenericServlet，这个类是个抽象类。而抽象类GenericServlet还有一个子类，名为HttpServlet，也是一个抽象类。这2个抽象类都能更简便的让我们重写Servlet的某些方法，而不是重写所有方法。 GenericServlet抽象类将Serrvlet接口中其他的方法做了默认空实现，只保留service( )方法作为抽象，也就是说，定义一个继承GenericServlet的Servlet类时，只需重写service（）方法即可，其他方法可以选择性的按照需求重写。 虽然GenericServlet抽象类很方便，但是我们实际开发时也很少使用GenericServlet，通常我们会使用HttpServlet抽象类 HttpServlet继承自GenericServlet抽象类，是Http协议的一种封装，可以简化操作 查看源码Service源码中获取了请求的方法，判断这个请求方式执行的方法， 因此我们无需像GenericServlet类一样重写service方法，而是重写对应的请求方法执行的方法，如doGet()、doPost()等7种。 定义类继承HttpServlet 复写doGet() / doPost()方法，当请求方法是get时，调用doGet方法，当请求是Post时，调用doPost方法，我们现在已知的post请求只有一种（表单method = post），其余均为get请求。","categories":[],"tags":[]},{"title":"191106——Git基本操作","slug":"191106——Git基本操作","date":"2019-11-03T12:00:46.000Z","updated":"2019-11-06T13:45:04.679Z","comments":true,"path":"2019/11/03/191106——Git基本操作/","link":"","permalink":"https://cometorbityh.github.io/2019/11/03/191106——Git基本操作/","excerpt":"","text":"1. 版本控制工具集中式版本控制工具：SVN、CVS、VSS… 分布式版本控制工具：Git、Mercurial、Bazaar、Darcs… 2. Git2.1. Git的优势 大部分操作在本地完成，无需联网（分布式版本控制，相当于本地仓库，因此无需联网） 完整性保证 尽可能添加数据而不是删除或修改数据（删除修改都是不可逆的操作） 分支操作非常快加流畅 与Linux命令全面兼容（他俩一个爹：Linux） 2.2. Git结构 ##2.3. Git 和代码托管中心 2.3.1 代码托管中心的任务：维护远程库 局域网环境下 GitLab 服务器 外网环境下 GitHub 码云 3. 本地库及其命令3.1 本地库和远程库（1）团队内部协作 （2）跨团队协作 ##3.2. 本地库操作命令 3.2.1 本地库初始化 + 签名本地库初始化命令： git init 注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要随意修改。 设置签名作用：区分不同开发人员的身份 格式：（举例，用户名与Email无实际联系） 用户名：tom Email：goodMorning@hello.com 注意：该签名和用于登录远程库（即代码托管中心）的账号密码无任何关系。 命令： 项目级别/仓库级别：只在当前本地库范围生效（信息保存在.git目录下的config文件中） git config user.name tom_pro git config user.email goodMorning_pro@hello.com 系统用户级别：登录当前操作系统的用户范围 （信息保存位置：系统~家目录下的.gitconfig文件） git config --global user.name tom_glb git config --global user.email goodMorning_glb@hello.com 级别优先级： 就近原则（项目级别 &gt; 系统级别，二者都有时采用项目级别的签名） 若只有系统级别的签名：以系统用户级别的签名为准 当二者都没有是不允许的。 ###3.2.2. 基本操作 新建一个文件，工作区添加到暂存区，提交到本地库 修改一个文件，添加到暂存区，提交到本地库 查看提交日志 前进后退版本 索引值能前进后退版本，^和~只能后退版本。 该命令中存在hard参数，在reset命令中，还有soft和mixed参数 soft参数：仅在本地库移动HEAD指针 mixed参数：在本地库移动HEAD指针，重置暂存区 hard参数：在本地库移动HEAD指针，重置暂存区，重置工作区 删除文件找回 前提：删除前，文件存在时的状态提交到了本地库 （之前已经把要找回的文件提交到了本地库） git reset --hard [指针位置]: 指针位置： 删除操作已提交到本地库，指针位置指向历史记录（永久删除文件后找回） 删除操作未提交到本地库，指针位置指向HEAD（添加到暂存区的删除文件找回） 永久删除文件后找回 添加到暂存区的删除文件找回 比较差异（比较不同版本的同一文件的差异） git diff [文件名]：将工作区的文件和暂存区进行比较 git diff [本地库历史版本] [文件名]：将工作区中的文件和本地库历史记录比较 不带文件名 比较多个文件 3.2.3. 分支管理查看分支 git branch -v 创建分支 git branch [分支名] 切换分支 git checkout [分支名] 合并分支 ​ 切换到接收修改的分支上（被合并的，变更内容的分支） git checkout [被合并的分支名] ​ 执行merge命令 git merge [有新内容的分支名] 分支冲突：2个分支同时修改了文件，git不清楚盖如何合并，导致分支冲突 解决： 编辑文件，删除特殊符号，修改文件内容后保存退出； 文件添加到暂存区，提交到本地库（注意此步操作不加文件名） #4. Git基本原理 4.1. 哈希算法哈希是一系列的算法，不同hash算法的加密强度不同。哈希算法不可逆。 Git底层采用的是SHA-1算法，哈希算法可以用来验证文件 ##4.2. Git 保存版本的机制 Git 的文件管理机制 Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。 Git 文件管理机制细节  Git 的“提交对象” 提交对象及其父对象形成的链条 Git 分支管理机制 5.3.1 分支的创建 分支的切换 总而言之，创建分支是创建新的指针，切换分支是切换指针的位置，因此非常高效 #5. 远程库操作命令 5.1. GitHub创建仓库1.注册账号并登录 2.创建仓库（远程库） 5.2. 本地库推送到远程库本地库连接远程库，执行推送操作 刷新远程库，可以看到刚才提交的文件了，点击可查看内容 ##5.3. 从远程库克隆项目到本地 另一个人执行的克隆操作 复制地址 克隆项目 这样用户2就克隆了用户1的远程库到本地了。 ##5.4. 修改内容重新推送到远程库 现在，用户2想修改用户1的内容并重新发回到用户1的本地库该怎么弄？ 之前图里看到过，直接推送是不行的， 需要用户1批准用户2，邀请用户2加入团队成为团队成员才能进行推送操作。 此时用户1成功邀请2成为团队成员 用户2就可以推送操作了 ###远程库修改的拉取 pull = fetch + merge 分为2步。git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名]/[远程分支名] ##5.5. 协同开发的冲突的解决 当用户1和用户2同时修改了某个文件的同一位置时，分别推送到远程库会出现冲突，即先推送的能成功，后推送的失败，因为远程库根据哈希值比较，若不同则认为你的本地库不是最新的了，因此用户2需要先拉取到本地，进行内容的修改，再进行推送。 如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 ##5.6. 跨团队协作操作 用户1和用户2是团队A的，用户3是团队B的，现在A对需要把项目给B队去优化，应该怎么做？ 首先团队B的成员要把团队A的远程库fork成自己的远程库，再克隆到本地，修改完成后push，发起pull request 团队1接受pull request 之后团队1就可以拉取远程库了。 5.7. SSH免密登录可以实现免GitHub账号登录，因此使用SSH可以免密登录，需要注意的是这样只能一个账号登陆 6. Git图形化&lt;eclipse版&gt;##6.1. 新建项目提交到本地库（忽略特定文件） 以eclipse为例： 点击Window——&gt; Preferences ——&gt; Team——&gt; Git——&gt;Configuration 新建一个Maven项目 将eclipse工程初始化为本地库 右击工程——&gt;Team——&gt;Share Project ——&gt;Git 解决追踪文件，首先要忽略一些特定文件 概念：Eclipse 特定文件 这些都是 Eclipse 为了管理我们创建的工程而维护的文件，和开发的代码没有 直接关系。最好不要在 Git 中进行追踪，也就是把它们忽略。 .classpath 文件 .project 文件 .settings 目录下所有文件 为什么要忽略 Eclipse 特定文件呢？ 同一个团队中很难保证大家使用相同的 IDE 工具，而 IDE 工具不同时，相关工程特定文件就有可能不同。如果这些文件加入版本控制，那么开发时很可能需要为了这些文件解决冲突 在家目录的本机用户的.gitconfig同级目录下新建一个java.gitignore，该文件的内容位于 https://github.com/github/gitignore/blob/master/Java.gitignore 在.gitconfig中添加： 这样，无论做任何版本操作，这些特定的文件都不会受任何干扰了 将项目添加到暂存区，右击项目——&gt;Team——&gt;add to Index 将项目提交到本地库，右击项目——&gt;Team——&gt;commit 若再添加新文件，可以直接对其commir，不用add。这就是图形化界面的优势 6.2. 推送到远程库新建远程库，复制链接 右击项目——&gt;Team——&gt;remote——&gt;push 添加所有分支 成功后，回到远程库可查看 6.3. 克隆工程操作右击空白处，import——&gt; Git——&gt;Project from Git——&gt;next——&gt;Clone URI——&gt;粘贴URI——&gt;master——&gt;next——&gt;更改保存路径——&gt;完成 克隆结束后，发现项目文件不完整，因为之前忽略了一些特定文件，所以还需要一些操作 右击项目，——&gt; configure ——&gt; convert to Maven Project，这样就能自动生成为Maven项目了。 ##6.4. 在eclipse解决冲突 分别提交 推送到远程库，第二个推送的人会产生冲突 解决：用户2先拉取（pull）,右击项目——&gt;Team——&gt;pull 右击冲突文件——&gt;Team——&gt;Merge Tool，可以看到对比 打开提交界面 此时文件图标恢复正常，到远程库即可。 查看远程库，推送成功！ 7. Git工作流（略）概念 在项目开发过程中使用 Git 的方式 分类 集中式工作流 GitFlow 工作流 Forking 工作流","categories":[{"name":"Git","slug":"Git","permalink":"https://cometorbityh.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cometorbityh.github.io/tags/Git/"}]},{"title":"191101——SpringMVC小结（1）","slug":"191101——SpringMVC小结（1）","date":"2019-11-01T01:18:58.000Z","updated":"2019-11-01T16:18:25.284Z","comments":true,"path":"2019/11/01/191101——SpringMVC小结（1）/","link":"","permalink":"https://cometorbityh.github.io/2019/11/01/191101——SpringMVC小结（1）/","excerpt":"","text":"2019.11.01记录帖SpringMVC简介SpringMVC是Spring框架的一个模块 1. 回忆MVC2. 第一个SpringMVC程序 若前端控制器没有配置init-param（没有说明springmvc配置文件的路径，有默认位置），则springmvc配置文件的默认位置应该在WEB-INF文件夹下，默认名为springDispatcherServlet-servlet.xml。","categories":[],"tags":[]},{"title":"记录独自做SSM论坛系统的错误、解决方案以及心得","slug":"记录独自做SSM论坛系统的错误、解决方案以及心得","date":"2019-10-27T08:55:47.000Z","updated":"2019-11-07T09:06:16.502Z","comments":true,"path":"2019/10/27/记录独自做SSM论坛系统的错误、解决方案以及心得/","link":"","permalink":"https://cometorbityh.github.io/2019/10/27/记录独自做SSM论坛系统的错误、解决方案以及心得/","excerpt":"","text":"1. 如何在文章下加入评论由于自己用的分页插件pageHelper只支持List，因此想用map插入实在很难解决（可能是我不懂哈哈）， 之前试过4表查询，结果只能得到有评论的文章。 因此在纠结了2天之后，我终于找到方法，就是查到所有评论，在控制层中按照文章的序号加入对应的评论，这样我就可以把对应的评论加入到对应文章的List中，从而解决了使用插件的难题。很开心，这样在之后插入也可以一个模块一个模块加入到文章bean中。 2. 添加文章时出现400错误代码在点击提交添加的按钮那边，一直出现400，很着急，按照百度的说法，有很多原因，有写是因为Date类型格式无法识别的，有说是int与Integer未转换，我一一试了一遍。都不行。最后在谷歌浏览器的控制台发现：我遍历出来的文章类型是类型名，但是我数据库中文章有关类型的字段是类型ID，看到这里我真的感觉很尴尬，我仿佛已经看到我要重构项目的时候了，郁闷。为什么当初要用Mybatis逆向工程，啊啊啊啊！！！不过好在解决了这个问题，这样发帖子功能也实现了，虽然没实现添加图片的功能，不过这个功能先放一放，后面再写。 3. 添加文章时，类型错误在添加带图片的文章时，由于图片是file类型的，因此后台一直获取不到这个数据。找了很多方法，最后在Controller方法的参数前加上@requestParam注解得以解决。 4. 收藏文章的思路需求：点击收藏按钮时变红（收藏），再次点击收藏时变灰（取消收藏），并且显示当前收藏数 思路： 先去数据库查出该文章被收藏的条目，在控制层中将其加入到各文章的LIst中，这样该文章的收藏数就是这些收藏条目的长度了。 在前端页面中，使用ajax遍历文章 用户未登录，且当前文章不是是当前登录用户的，收藏按钮显示为“请登录” 用户已登录，且当前文章不是是当前登录用户的（ 当前登录的用户ID和文章ID ） 未收藏（当前登录用户ID和文章ID 不等于 传到页面的Articles的该Article的Collection中的每条数据） 点击时收藏（调用收藏操作，执行添加收藏方法，并使收藏按钮变红） 已收藏（当前登录用户ID和文章ID 等于 传到页面的Articles的该Article的Collection中的某条数据） 点击时取消收藏（调用取消收藏操作，执行取消收藏方法，并使收藏按钮变灰） 5.重大消息今天发现之前跟着视频用分页做的逻辑居然如此好用，里面有个to_page()方法，它用了Ajax刷新了整个页面，但我居然不知道去使用，知道今天才发现，害我写了N多的重复代码，真的想哭。不过好在及时发现了这个神器，嘻嘻，再也不用重复写相同的逻辑了。这样的话之前的代码就需要重构了，不过没事，能简化代码我很开心呢。嗷嗷嗷嗷嗷嗷！","categories":[],"tags":[]},{"title":"191024——java多线程","slug":"191024——java多线程","date":"2019-10-24T08:04:02.000Z","updated":"2019-10-24T09:56:19.525Z","comments":true,"path":"2019/10/24/191024——java多线程/","link":"","permalink":"https://cometorbityh.github.io/2019/10/24/191024——java多线程/","excerpt":"","text":"多线程概述1.1. 概念进程：正在运行的程序 多进程：计算机同时支持运行多个进程，可以提高CPU的利用率 线程：一个进程可以执行多个任务，每一个任务都被称为一个线程，线程是程序的执行单元/执行路径。 多线程：提高应用程序的使用率。 多线程的意义：程序的执行本质是在抢CPU的资源，CPU的执行权。多进程是在抢占这个资源，而其中的某一个进程如果执行路径较多，就会有更高的几率抢到CPU执行权。但是线程的执行有随机性，无法保证一定抢到。 1.2. JAVA程序运行原理Java命令会启动JVM，等于启动一个应用程序，即启动一个进程。该进程会自动启动一个“主线程”，该主线程会自动调用某个类的main方法，因此main方法运行在主线程中。 问：JVM的启动是单线程还是多线程的？ 答：多线程，JVM启动后最少会有２个线程，一个主线程，一个垃圾回收线程（为了防止出现内存溢出）。 多线程实现方案Java提供类Thread来实现多线程，有2种方式实现多线程程序。 2.1. 方式1：继承Thread类2.1.1. 步骤： 自定义类MyThread继承Thread类 MyThread类重写run方法（只有run方法中的代码才会被线程执行） 创建MyThread对象 启动线程（start方法） 为什么启动线程是用start方法而不是run方法？ ​ 因为run方法只是封装了被线程执行的代码，直接调用是普通方法。 ​ 而start方法是先启动了线程，再由jvm去调用该线程的run方法 一个线程能调用2次start方法吗？ ​ 不能。这样相当于启动了2次一样的线程，一个线程同时只能启动一次。 如何获取和设置线程名称？ ​ public final String getName()：获取线程名称 ​ 线程类的无参构造方法创建的对象 + public final String setName()：设置线程名称 ​ 线程类的有参构造方法：设置线程名称 如何获得main方法所在线程对象的名称？ ​ Thread.currentThread().getName(); //Thread.currentThread()返回当前正在执行的线程对象 1234567891011121314151617181920package demo.test.thread;public class MyThread extends Thread&#123; @Override public void run() &#123; //需要被执行的代码 for(int x=0;x&lt;100;x++) &#123; System.out.println(getName()+\"---\"+x); &#125; &#125; public MyThread() &#123; // TODO Auto-generated constructor stub &#125; //有参构造方法：用来直接设置线程名称 public MyThread(String name) &#123; super(name); &#125;&#125; 1234567891011121314151617package demo.test.thread;public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建线程对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); //MyThread t3 = new MyThread(\"3号线程\"); t1.setName(\"1号线程\"); t2.setName(\"2号线程\"); //启动线程 t1.start(); t2.start(); &#125;&#125; ### 线程调度和线程控制3.1. 线程调度线程调度有2种模型。 分时调度模型，所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片 抢占式调度模型（java使用的）：优先使优先级高的线程使用CPU，若优先级相同，则会随机选择一个。注意：优先级高的线程获取CPU时间片相对多一些。 如何设置线程的优先级？ setPriority(10)：线程的默认优先级为5，其取值范围为[1，10]； 优先级仅仅表示线程获取的CPU的时间片的几率高。 3.2. 线程控制 线程睡眠：Thread.sleep(ms) 加入线程：join()：优先执行该线程 线程礼让：Thread.yield():暂停当前正在执行的线程对象，并执行其他线程对象（使线程执行更有规律，但无法保证一个线程执行一次） 守护线程： 中断线程： 线程生命周期 线程同步死锁线程间通信定时器的使用","categories":[],"tags":[]},{"title":"JAVA——集合类","slug":"JAVA——集合类","date":"2019-10-23T06:59:40.000Z","updated":"2019-10-23T10:29:08.254Z","comments":true,"path":"2019/10/23/JAVA——集合类/","link":"","permalink":"https://cometorbityh.github.io/2019/10/23/JAVA——集合类/","excerpt":"","text":"集合：也称容器。是一种可以装任何类型的容器 集合与数组的区别：数组长度不可变。集合长度可变 List特点：有序可重复，容器保存的数据可以是多种类型的，但是当我们存储了很多不同类型的数据后，取数据就需要转成对应的类型，导致很麻烦，那么有没有什么办法可以规定该List只能存储一种数据类型呢？ 我们使用泛型来规定数据类型，未规定泛型的集合里面可以存储任意类型的数据或对象，规定泛型之后，该集合只能存储对应数据类型的数据或对象。 注意：泛型可以用引用数据类型代替，而不是指基本数据类型。如List&lt;Integer&gt;而不是List&lt;int&gt;。 ArrayList的常用方法常用方法： 增删改查：add(E e) ,remove(index),set(index,value),get(index),size() 其他方法：addAll(list2) 并集， removeAll(list2)差集， retainAll（list2) 交集 ​ indexOf() , lastIndexOf(), contains() List=subList() ​ isEmpty() clear() ensureCapacity() iterator()迭代器 ​ toArray(T[] x); TrimToSize(); add ——存 remove(int index)——删除对应索引的元素 set(int index,E value)——对应索引的元素改成新元素 inr size()——返回该list的有效元素个数 list1.addAll(Collection&lt;? extends E&gt; list2)：将list2的所有元素添加到list1中，注意如果2个List都有泛型，那么list2的泛型应该与list1的泛型相同或是list1的泛型的子类，若泛型无关联，则无法添加。(并集) list1.addAll(int index, Collection&lt;? extends E&gt; list2)：将list2的所有元素添加到list1中，在索引处前开始插入。注意如果2个List都有泛型，那么list2的泛型应该与list1的泛型相同或是list1的泛型的子类，若泛型无关联，则无法添加。 E get(int index)——取出对应索引位置的元素，返回值为规定的泛型 clear()——清除list中的所有元素 boolean contains(Object)——判断是否包含该元素 int indexOf(Object o)——判断该元素第一次在list中出现的索引 int lastIndexOf(Object o)——判断该元素最后一次在list中出现的索引 boolean isEmpty() ——判断list是否为空 system.out.println(list)：遍历对象，说明List重写了toString()方法 Iterator iterator()——迭代器 removeAll(list2)——差集 retainAll(list2)——交集 ArrayList Vector LinkedList 底层数据结构 动态数组（扩容1.5倍） 动态数组（扩容2倍） 双向链表 特点 有序可重复，适合遍历和查询 有序可重复，适合遍历和查询 有序可重复，适合增加和删除 线程不同步，安全性低，效率高 线程同步，安全性高，效率低 Set接口实现Collection接口，以value形式存在 无序无重复， 无序：set集合使用hash算法对元素进行排列，不是按照存储顺序排列，因此无序 HashSet TreeSet 底层数据结构 HashMap（散列表=数组+链表） TreeMap（红黑二叉树） 特点 无序无重复 无序无重复 无重复原则有2个方法同时起作用* equals hashCode* 默认比较2个对象的地址，若第二个对象地址与第一个一致，则不存入* 若i想改变其规则，则可重写上述2个方法 无重复原则有1个方法在起作用* compareTo* 该方法并非所有对象都有，若想将1个对象存入TreeSet中，需让对象所属的类实现接口COmparable，再将compareTo重写，返回值int，负数靠前排布，整数排列靠后 Map&lt;K,V&gt;接口Map，直译为地图，在Java中表示映射，可以通过某个key直接定位到对应的value值 存储的方式：键值对（key-value)，key无序无重复，value无序可重复。就像账号和密码，账号是唯一的，密码可能会一样。 HashMap&lt;K,V&gt;类3.1. 所属包：java.util 3.2. 如何创建对象 12//创建一个HashMap对象，该方法：初始容器16，当容量达到容量的0.75倍时自动扩容HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); 3.3. 基本方法 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243package demo.test.collection;import java.util.HashMap;import java.util.Iterator;import java.util.Set;public class TestHashMap &#123; public static void main(String[] args) &#123; //创建一个HashMap对象，该方法：初始容器16，当容量达到容量的0.75倍时自动扩容 HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); /*==== 增删改查 ====*/ map.put(1, \"aaa\"); map.put(4, \"ddd\"); map.put(2, \"aaa\"); //key不同，value相同 map.put(3, \"bbb\"); map.put(3, \"xxx\"); //key相同，value不同 System.out.println(map); /* * 无序：存元素的顺序与取元素的顺序无关 key不能重复：若重复，则后添加的覆盖前添加的 value可重复：不同的key可以有相同的value */ map.remove(3); map.put(2, \"我是2号key\"); System.out.println(\"map的有效元素个数：\"+map.size()); System.out.println(map); /*==== 遍历 ====*/ //获取map集合的全部key Set&lt;Integer&gt; keys = map.keySet(); //通过迭代器遍历keys Iterator&lt;Integer&gt; it = keys.iterator(); while(it.hasNext()) &#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+\"-----\"+value); &#125; &#125;&#125; 其他方法 ​","categories":[],"tags":[]},{"title":"SSM图片上传并回显","slug":"SSM图片上传并回显","date":"2019-10-19T15:27:08.000Z","updated":"2019-10-20T04:26:26.653Z","comments":true,"path":"2019/10/19/SSM图片上传并回显/","link":"","permalink":"https://cometorbityh.github.io/2019/10/19/SSM图片上传并回显/","excerpt":"","text":"最近做一个SSM项目需要用到图片上传，在网上找了很多教程，配置了几遍，终于弄出来了，在此记录一贴留念。 本文使用的工具是idea，数据库是Mysql，框架是SSM。 1. 项目结构新建一个maven项目，进行ssm整合之后，添加以下文件： 2. 前期准备在本地找个盘建个文件夹用来存放图片，如我在E盘下新建文件夹“upload”（忽略图片，测试时用的）: idea创建好一个Maven项目，配置好Tomcat，将放图片的文件夹也加入： 当启动tomcat时，会部署2个目录分支，这样前期工作就准备好了。 3. 新建数据库123456DROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `pid` int(11) NOT NULL AUTO_INCREMENT, `pimage` varchar(255) DEFAULT NULL, PRIMARY KEY (`pid`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 4. 具体代码1. pom.xml123456789101112&lt;!-- 上传下载需要涉及到的jar包 --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 2. SpringMVC.xml12345678&lt;!-- 定义文件上传解析器 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"&gt;&lt;/property&gt; &lt;!-- 其他的大家可以自行配置，不影响主功能--&gt;&lt;/bean&gt; 3. Product.java123456789101112131415161718192021222324252627package com.young.bean;public class Product &#123; private Integer pid; private String pimage; public Integer getPid() &#123; return pid; &#125; public void setPid(Integer pid) &#123; this.pid = pid; &#125; public String getPimage() &#123; return pimage; &#125; public void setPimage(String pimage) &#123; this.pimage = pimage; &#125; @Override public String toString() &#123; return \"Product [pid=\" + pid + \", pimage=\" + pimage + \"]\"; &#125;&#125; 4. ProductMapper.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.young.dao.ProductMapper\"&gt; &lt;!-- 添加商品图片 --&gt; &lt;insert id=\"save\" parameterType=\"com.young.bean.Product\" &gt; insert into product(pimage) values (#&#123;pimage&#125;) &lt;/insert&gt; &lt;!-- 查询商品--&gt; &lt;select id=\"list\" resultType=\"com.young.bean.Product\"&gt; select * from product &lt;/select&gt;&lt;/mapper&gt; 5.ProductMapper.java123456789101112package com.young.dao;import com.young.bean.Product;import java.util.List;public interface ProductMapper &#123; //保存商品 void save(Product product); //查询商品 List&lt;Product&gt; list();&#125; 6. ProductService.java123456789101112package com.young.service;import com.young.bean.Product;import java.util.List;public interface ProductService &#123; List&lt;Product&gt; list(); void save(Product product);&#125; 7. ProductServiceImpl.java12345678910111213141516171819202122232425262728293031323334package com.young.service.impl;import com.young.bean.Product;import com.young.dao.ProductMapper;import com.young.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.ui.ModelMap;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID;@Service@Transactionalpublic class ProductServiceImpl implements ProductService &#123; //注入ProductMapper @Autowired private ProductMapper productMapper; @Override public List&lt;Product&gt; list() &#123; return productMapper.list(); &#125; @Override public void save(Product product) &#123; productMapper.save(product); &#125;&#125; 8.ProductController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.young.controller;import com.young.bean.Product;import com.young.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID;@Controllerpublic class ProductController &#123; //注入ProductService @Autowired private ProductService productService; //查询 @RequestMapping(\"/list.do\") public String listUser( Model model)&#123; List&lt;Product&gt; list= productService.list(); model.addAttribute(\"list\",list); System.out.println(list); return \"list\"; &#125; @RequestMapping(\"/addProduct.do\") public String fileUpload(MultipartFile file,Product product, ModelMap map) throws IOException &#123; /** * 上传图片 */ //图片上传成功后，将图片的地址写到数据库 String filePath = \"E:\\\\upload\";//保存图片的路径,tomcat中有配置 //获取原始图片的拓展名 String originalFilename = file.getOriginalFilename(); //新的文件名字，使用uuid随机生成数+原始图片名字，这样不会重复 String newFileName = UUID.randomUUID()+\"_\"+originalFilename; //封装上传文件位置的全路径，就是硬盘路径+文件名 File targetFile = new File(filePath,newFileName); //把本地文件上传到已经封装好的文件位置的全路径就是上面的targetFile file.transferTo(targetFile); product.setPimage(newFileName);//文件名保存到实体类对应属性上 /** * 保存商品 */ productService.save(product); return \"redirect:/list.do\"; //重定向到查询 &#125;&#125; 9. index.jsp123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"addProduct.do\" method=\"post\" enctype=\"multipart/form-data\"&gt; 图片：&lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10. list.jsp这里有一个地方需要注意：此处填选的是tomcat中加入部署的文件夹时起的名字 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"/&gt; &lt;script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=\"text/css\"&gt; #images&#123; width: 50px; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table class=\"table table-bordered table-hover\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;图片&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"product\" &gt; &lt;tr&gt; &lt;th&gt;$&#123;product.pid &#125;&lt;/th&gt; &lt;th&gt;&lt;c:if test=\"$&#123;product.pimage !=null &#125;\"&gt; &lt;img id=\"images\" alt=\"\" src=\"/upload/$&#123;product.pimage &#125;\"&gt; &lt;/c:if&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5. 测试结果启动tomcat，开始测试 至此，大功告成！","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM文件上传","slug":"SSM文件上传","permalink":"https://cometorbityh.github.io/tags/SSM文件上传/"}]},{"title":"","slug":"JAVA——多线程","date":"2019-10-17T12:04:38.212Z","updated":"2019-10-18T07:40:29.836Z","comments":true,"path":"2019/10/17/JAVA——多线程/","link":"","permalink":"https://cometorbityh.github.io/2019/10/17/JAVA——多线程/","excerpt":"","text":"2 1. 概念理解1.1. 并发与并行1.2. 程序，进程，线程1.3. 线程调度，分时调度 描述 举例 并发 多个事件交替执行(单核)，效率低 一个人同时吃2个包子，一个包子吃一口 并行 多个事件同时执行(多核)，效率高 两个人吃2个包子 程序 QQ程序 进程 运行中的(进入到内存中)应用程序 开启1个QQ或多个QQ，这些QQ叫进程 线程 是进程的一个执行单元。进程中的操作 360可以同时清理垃圾，扫描病毒，这些操作都叫线程 多线程 效率高，线程之间互不影响 线程调度（2种） 分时调度 每个线程占用的时间相等 抢占式调度(java采用的) 优先级越高的线程被执行的几率就大 一个程序至少包含1个进程，一个进程可以包含多个线程 2. 多线程的创建方式 java中的程序只有1个线程，从main方法开始执行，即主线程； 当程序之间有一个异常时，后面的程序都不会执行到，因此我们需要引入多线程来执行异常后的代码。 2.1. 创建Thread的子类2.2.实现Runnable接口 创建一个Runnable的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法 2.3. Thread和Runnable的区别一个类继承Thread类，则不适合资源共享 一个类实现Runnable接口，很容易就可实现资源共享 实现Runnable接口创建多线程程序的好处： 适合多个相同的程序代码的线程去共享同一个资源 可避免Java的单继承的局限性（实现Runnable接口还可以实现其他类或接口） 增加程序的健壮性，实现解耦操作，代码可被多个线程共享，代码和线程独立 实现Runnable，把设置线程任务和开启新线程进行分离（解耦） 实现类重写了run方法：用来设置线程任务 创建Thread类对象，调用start方法，用来开启新线程 线程池只能放入实现Runnable或Callable类的线程，而不能直接放入继承Thread的类 在Java中，程序每次运行至少启动2个线程，一个main线程。一个是垃圾收集线程， 因为每当使用Java命令执行一个类时，实际上都会启动一个JVM，每一个JVM其实就是在操作系统中启动了一个进程。 2.4. 用匿名内部类来创建线程匿名：没有名字 内部类：写在其他类内部的类 匿名内部类的作用：简化代码 把【子类继承父类，重写父类的方法，创建子类对象】合成一步完成 把【实现类实现类接口，重写接口中的方法。创建实现类对象】合成异步完成 匿名内部类的最终产物：子类/实现类对象，而这个类没有名字 匿名内部类的格式： 123new 父类/接口()&#123; //重写父类/接口的方法&#125;； 匿名内部类创建线程的步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.test.ThreadDemo;public class InnerClassThread &#123; public static void main(String[] args) &#123; /*----------------------------------*/ //new 父类Thread //new MyThread().start(); new Thread() &#123; //重写run方法，设置线程任务 public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Thread\"); &#125; &#125; &#125;.start(); /*----------------------------------*/ //new 接口Runnable //Runnable r = new RunnableTest(); 创建Runnable接口的实现类对象 Runnable r = new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Runnable\"); &#125; &#125; &#125;; //创建Thread类对象，构造方法床底Runnable接口的实现类对象 //调用start方法开启线程 new Thread(r).start(); /*----------------------------------*/ //简化Runnable new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Runnable01\"); &#125; &#125; &#125;).start(); &#125;&#125; 3. 线程安全3.1. 线程安全问题当多个线程访问共享的资源时，这些线程会抢占cpu的执行权，就会产生线程安全问题。 例如3个售票处同时售卖100张票，但会卖到同一张票，而一张票只能卖给一个人，此时的售票员多尴尬啊。 以下程序中不仅出现重复卖票，还出现不存在的票。 123456789101112131415161718package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义票数，这是一个共享的资源 private int ticket=10; //模拟售票 @Override public void run() &#123; while(true) &#123; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125; &#125;&#125; 12345678910111213141516171819package com.test.ThreadDemo;public class ThreadSecurityDemo &#123; public static void main(String[] args) &#123; //创建实现Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //定义Thread类的子类对象，其构造方法的参数为实现Runnable接口的实现类对象 Thread t1 = new Thread(run); Thread t2 = new Thread(run); Thread t3 = new Thread(run); //开启多线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 3.2. 解决线程安全问题（3种方法）（1）同步代码块synchronized关键字可用于方法中的某个区块中，表示只对该区块的资源进行互斥访问。 格式： 123synchronized(同步锁对象)&#123; 可能会出现线程安全问题的代码（共享数据的代码）&#125; 锁对象：锁对象可以使用任意的对象，多个线程使用的锁对象必须使同一个， 锁对象的作用：把同步代码块锁住，只允许一个线程在同步代码块中执行。 1234567891011121314151617181920212223242526272829303132package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; while(true) &#123; //同步代码块 synchronized(obj) &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125; &#125; &#125;&#125; （2）同步方法synchronized关键字修饰的方法，当某个线程执行该方法时，锁住代码，其他线程只能在方法外等候。 同步方法 格式 锁对象 原因 非静态同步方法 修饰符 synchronized 返回值类型 方法名(参数列表){ //需要同步的代码} this 静态同步方法 修饰符 static synchronized 返回值类型 方法名(参数列表){ //需要同步的代码} 本类的class文件对象 因为this是创建对象后产生的，而静态方法优先于对象，因此静态同步方法的锁对象是本类的class文件对象 非静态同步方法1234567891011121314151617181920212223242526272829303132333435package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; saleTicket(); &#125; &#125; //同步方法 public synchronized void saleTicket() &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125;&#125; 123456789101112131415161718192021package com.test.ThreadDemo;public class ThreadSecurityDemo &#123; public static void main(String[] args) &#123; //创建实现Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); System.out.println(\"run___\"+run); //定义Thread类的子类对象，其构造方法的参数为实现Runnable接口的实现类对象 Thread t1 = new Thread(run); Thread t2 = new Thread(run); Thread t3 = new Thread(run); //开启多线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 非静态同步方法的锁对象是对应的Runnable接口的实现类对象，即this 静态同步方法123456789101112131415161718192021222324252627282930313233343536package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private static int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; saleTicket(); &#125; &#125; //同步方法 public static synchronized void saleTicket() &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125;&#125; （3）Lock锁java.util.concurrent/locks.Lock接口 Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作 Lock接口中的方法: void lock()————————获取锁 void unlock()————————释放锁 Lock接口有个实现类： java.util.concurrent.locks.ReentrantLock 使用步骤： 在成员位置创建ReentrantLock对象 在可能会出现安全问题的代码前调用Lock接口的lock方法来获取锁 在可能会出现安全问题的代码后调用Lock接口的unlock方法来释放锁 1234567891011121314151617181920212223242526272829303132333435363738package com.test.ThreadDemo;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private static int ticket=10; /*1.创建ReentrantLock对象*/ Lock l =new ReentrantLock(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; /*2. 在线程安全代码之前获取锁*/ l.lock(); if(ticket&gt;0) &#123; try &#123; //睡眠，相当于冷却 Thread.sleep(5); //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; /*3. 在线程安全代码之后释放锁*/ l.unlock(); &#125; &#125; &#125; &#125;&#125; 4. 线程状态Thread的内部类State描述了线程的6种状态 4.1. TimedWaiting（计时等待）调用sleep()，使线程进入睡眠状态； 调用wait(long m)，等待毫秒值结束后，若没有被notify()唤醒，则自动醒来，线程进入运行状态或阻塞状态 4.2. BLOCKED（锁阻塞）当线程抢到cpu执行权时，进入运行状态。未强抢到执行权时，进入阻塞状态 4.3. Waiting（无限等待）线程进入等待状态，需要等待被唤醒。 wait()线程等待，需要notify唤醒 wait(long m)，等待毫秒值结束后，若没有被notify()唤醒，则自动醒来，线程进入运行状态或阻塞状态 notify()唤醒在该对象监视器等待的单个线程 notifyAll()唤醒在该对象监视器等待的所有线程 4.4. 其他5. 等待唤醒机制我们知道。多个线程并发执行时，cpu是随机切换线程的，当我们需要多个线程共同执行一项任务时，必然是需要有规律的执行，只做包子不吃或者只吃包子不做都是不符合规律的，因此我们需要他们之间协调通信来完成任务。 什么是等待唤醒机制？线程之间的通信 为了解决线程之间的通信问题，为了有效利用共享的资源 用到的方法： wait()：线程进入等待状态，进入对象的waiting set中，不再占用cpu资源和竞争锁。需要得到通知notify才能重新进入到调度队列中 notify()：释放对象的waiting set中等待时间最长的线程 notifyAll()：释放对象的waiting set中的全部线程","categories":[],"tags":[]},{"title":"JAVA——集合","slug":"JAVA——集合","date":"2019-10-16T11:22:04.000Z","updated":"2019-10-23T06:59:00.173Z","comments":true,"path":"2019/10/16/JAVA——集合/","link":"","permalink":"https://cometorbityh.github.io/2019/10/16/JAVA——集合/","excerpt":"","text":"1.CollectionCollection的常用方法 操作对象 方法 描述 单个容器 boolean add(Object element) 增加元素到容器中 boolean remove(Object element) 从容器中移除元素 boolean contains(Object element) 容器中是否包含该元素 int size() 容器中元素的数量 boolean isEmpty() 容器中是否为空 void clear() 清空容器中所有元素 迭代器 Interator 提供了统一的遍历容器的方式 多个容器 boolean addAll(Collection c) 将容器C的所有元素添加到本容器中 boolean removeAll(Collection c) 移除本容器和C容器中都包含的元素 boolean containsAll(Collection c) 本容器中是否包含c容器中的所有元素 boolean retainAll(Collection c) 留下本容器和容器C都包含的元素，移除本容器和C容器中非交集的元素 Object[] toArray() 转化为Object数组 123456789101112131415161718192021222324252627package com.orbit.demo;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add(\"张三\"); c.add(\"李四\"); System.out.println(c.toString()); System.out.println(\"当前容器是否为空 ==&gt; \"+c.isEmpty()); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); System.out.println(\"当前容器是否包含李四 ==&gt; \"+c.contains(\"李四\")); System.out.println(\"转为Object数组 ==&gt; \"+c.toArray().toString()); System.out.println(\"移除李四\"); c.remove(\"李四\"); System.out.println(c.toString()); System.out.println(\"清空\"); c.clear(); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"aa\"); list01.add(\"bb\"); list01.add(\"cc\"); List&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"aa\"); list02.add(\"dd\"); list02.add(\"ee\"); System.out.println(list01); System.out.println(list02); list01.addAll(list02); //list02添加到list01（可重复） System.out.println(list01); System.out.println(list01.containsAll(list02)); //list01是否包含list02 list01.removeAll(list02); //删除交集元素 System.out.println(list01); list01.retainAll(list02); //删除非交集元素 System.out.println(list01); &#125; &#125; 2.List接口List是有序的、可重复的容器。 有序：每个元素都有索引，可通过索引访问元素 可重复：允许加入重复元素 List接口常用的实现类有3个：ArrayList，LinkedList，Vector 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aa\"); list.add(\"bb\"); list.add(\"cc\"); list.add(\"dd\"); //在最后增加元素 System.out.println(list); list.add(2, \"AA\"); //在索引处插入元素 System.out.println(list); list.remove(2); //移除指定索引的元素 System.out.println(list); list.set(2, \"aa\"); //覆盖指定索引的元素 System.out.println(list); System.out.println(list.get(2)); //获取指定索引的元素 System.out.println(list.indexOf(\"aa\")); //获取该元素第一次出现的索引位置。不存在则返回-1 System.out.println(list.indexOf(\"bc\")); System.out.println(list.lastIndexOf(\"aa\")); //获取该元素最后一次出现的索引位置。不存在则返回-1 &#125; &#125; 2.1 ArrayList（常用）ArrayList底层是用数组实现的存储。 数组占用空间连续 特点：查询效率高，增删效率低，线程不安全。 数组长度有限，但ArrayList长度不限，可存放任意数量的对象。它是如何实现的？ 扩容。数组的默认长度为10，当长度满时，创建一个新的长度为原来的1.5倍（原长度+原长度右移1位）长度的数组，再将旧数组的元素复制到新数组中。 2.2 LinkedListLinkedList底层时采用双向链表实现的存储。链表占用空间不连续 特点：查询效率低，增删效率高，线程不安全 双向链表：每个数据节点（node）都有2个指针，分别指向前一个节点和后一个节点。 上节点地址 || 元素数据 || 下节点地址 2.3 VectorVector底层是采用数组实现的List，相关方法都增加了同步检查（synchronized） 特点：效率低（同步检查耗费时间），线程安全 3. Map接口显示生活中，常需要成对存储某些信息，比如一个手机号对应一个微信号，这就是成对存储关系， 在Java中，这对数据称为键值对（key-value）， Map就是用来存储键值对的，通过键来获取值，因此键对象是唯一的不可重复。 若重复，则新的键值对会覆盖旧的键值对 。 Map接口的实现类：HashMap，TreeMap，HashTable，Properties 操作对象 方法 描述 单个Map Object put(Object key,Object value) 存放键值对 Object get(Object key) 通过键对象查找得到值对象 Object remove(Object key) 删除键对象对应的值对象 boolean containsKey(Object key) Map容器中是否包含键对象对应的键值对 boolean containsValue(Object value) Map容器中是否包含值对象对应的键值对 int size() 键值对的数量 boolean isEmpty() 判断Map是否为空 void clear() 清空所有键值对 多个Map void putAll(Map m) 将m容器中的所有键值对存放到本map对象 3.1 HashMap类HashMap底层实现使用了哈希表，这是一种重要的数据结构。 哈希表的基本结构是&quot;数组＋单向链表&quot;。即结合了两者的优点，查询快，增删效率也快。 存储方式：将很多链保存在数组中 约定数组的长度必须是2的整数次幂，这样采用位算法可以实现取余的效果。 这些键值对越散越好，便于查询，因此为了得到更好的散列效果，jdk对hashcode还进行了2次散列处理，即移位操作，核心目标是为了分布更散更均匀 (1). hashmap如何存储数据①. put存储数据过程核心：产生hash值，该值用来对应数组的存储位置第一步，调用方法 key对象.hashcode() 生成 哈希码，注意整形数的哈希码是它本身第二步，调用hashMap的hash()方法 计算出哈希值，hash值=hashcode＆(数组长度-1)，哈希值的范围[0，table数组的length-1]，即数组的索引位置第三步，结合 hash值，key对象，value对象，next 四个数据生成entry对象，即链第四步，将这个entry对象存储到数组索引位置，当有多个entry对象的hash值一样时，前一个entry对象的next即指向后一个entry对象。 ②. get获取数据过程3.2 HashTable类——线程同步的HashMap类底层和用法与hashmap几乎一样，只是hashtable的方法添加了synchronized关键字，确保线程同步检查，效率较低。区别 hashmap线程不安全，效率高，允许key或value为nulltreemap线程安全，效率低，不允许key或value为null 3.3 TreeMap类treemap是红黑二叉树的典型实现源码中，root用来存储整个树的根节点，其类型为entry，entr底层源码中，存储了本身数据，左节点，右节点，父节点，节点颜色。treemap和hashmap实现了同样的接口map,因此用法对于调用者来说无区别，hashmap的效率高于treemap，在需要排序的map时才选用treemap #4. set接口继承自collection接口，有collection所有的方法，无新增方法 特点：无序，不可重复， 五序指set中元素无索引，只能遍历查找， 不可重复指不允许加入重复的元素。即新元素与set中的元素通过equal()方法对比为true，则不可加入。因此set中也只能放一个null元素。 (其实hashset的元素底层是map的key，因此不可重复，至于value只是定义了一个恒定的Object对象) 实现类：HashSet,TreeSet 4.1 HashSet(常用)4.2 TreeSet底层用treemap实现，内部维持了一个简化版的treemap.与hashset一样，通过key来存储set的元素，value是一个默认的Object对象。treeset需要对存储的元素进行排序，因此对应类需要实现Comparable接口，这样才能根据compareTo()方法比较对象之间的大小进行内部排序。 #5. Iterator迭代器的使用提供了统一的遍历容器的方式。 6. Collections工具类提供了对set，list，map，进行排序填充，查找元素的辅助方法，注意Collection是接口，Collections是工具类sort(list)按升序排序shuffle(list)随机排序reverse(list)倒序排序int binarySearch(list，Object)二分查找法查找特定对象","categories":[],"tags":[]},{"title":"SSM整合实例_05_删除人员","slug":"SSM整合实例-05-删除人员","date":"2019-10-10T08:46:39.000Z","updated":"2019-10-10T08:47:01.723Z","comments":true,"path":"2019/10/10/SSM整合实例-05-删除人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-05-删除人员/","excerpt":"","text":"","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_04_修改人员","slug":"SSM整合实例-04-修改人员","date":"2019-10-10T08:46:28.000Z","updated":"2019-10-10T12:38:18.452Z","comments":true,"path":"2019/10/10/SSM整合实例-04-修改人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-04-修改人员/","excerpt":"","text":"修改操作1.点击编辑，弹出修改的模态框，并显示用户信息 2.点击更新，完成用户修改 删除操作单个：url:/emp/{id} DELETE","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_03_增加人员","slug":"SSM整合实例-03-增加人员","date":"2019-10-08T14:14:41.000Z","updated":"2019-10-10T08:45:16.614Z","comments":true,"path":"2019/10/08/SSM整合实例-03-增加人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例-03-增加人员/","excerpt":"","text":"新增操作 需求： 思路： 点击“新增”按钮时弹出对话框，该对话框的功能为增加人员，需要获取到部门的数据到下拉框中 为“新增”绑定点击事件，包括： 1. 先清除表单数据 2. 调用获取部门数据的方法： 获取部门数据：发送ajax请求到处理器相应方法，收到返回结果，该返回结果是去数据库查询的部门列表 部门数据放到下拉框中：在ajax中，将success的result进行遍历，并拼接到标签中 3. 弹出模态框：利用bootstrap的$(id).modal({backdrop:&quot;static&quot;}); 对用户名进行ajax“重复”检验 为用户名输入框的change绑定事件：获取到输入框的值；发送ajax请求（发送用户名数据）到处理器校验用户名是否可用，得到返回值，返回值是一个状态码；判断该状态码：状态码为可用状态时，调用显示校验提示的方法，并给保存按钮添加一个自定义属性，属性值为success（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)）状态码为不可用状态时，调用显示校验提示的方法，显示提示信息，并给保存按钮添加一个自定义属性，属性值为error（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)），点击无效 点击“保存”按钮：对要提交给服务器的数据进行校验此时自动调转到包含该员工数据的那一页 为提示框的添加按钮绑定点击事件，包括： 1. 调用数据校验的方法。若该方法返回值为false,return false;该方法具体如下: 获取对应文本框中输入的值（var value=$(&quot;#文本框id&quot;).val()）； 定义一个正则表达式（var regValue=xxxxx）； 使用正则表达式对该值进行校验（regValue.test(value)），判断该语句的值； 是false则调用显示校验提示的方法并return false； 是true继续校验下一个； 以此类推，全部检验完毕，return true 1-1. 调用显示校验提示的方法： 先在每一个文本框下添加一个span标签，用来输出提示信息 清空当前元素的校验状态 判断输入框的格式 如果输入框格式有误，就在输入框的父标签（div）的class添加has error字段（bootstrap语法，该语法使文本框变红），在输入框的下一个标签（span）添加文本，文本为错误提示信息。 如果输入框格式正确，就在输入框的父标签（div）的class添加has success字段（bootstrap语法，该语法使文本框变绿） 该方法有相同之处，可抽取3个参数（输入框id，输入框格式状态，提示信息），不再详细说明。 2. 判断添加按钮的自定义属性（在上一个需求）是否为error，若是则return false; 3. 保存新增的员工数据：页面发送ajax请求（将表单数据序列化）到处理器的新增人员的方法，完成数据库数据的添加 4. 跳转到新员工的页面：调用to_page();，定义一个变量，赋值为总记录数，to_page(变量)即可跳转 重要数据，对用户进行后端校验（JSR303），唯一约束 1. 导入jar包：hibernate-validator（JSR303数据校验支持）2. 在处理器的保存人员方法中添加检验，并返回一个参数给请求页面的ajax解析","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_02_主页设计","slug":"SSM整合实例_02_主页设计","date":"2019-10-08T14:08:54.000Z","updated":"2019-10-08T14:15:36.119Z","comments":true,"path":"2019/10/08/SSM整合实例_02_主页设计/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例_02_主页设计/","excerpt":"","text":"查询操作需求：获取数据库的数据到主页。 1，查询步骤（model方法） 访问index.jsp index.jsp页面发出查询人员列表的请求 对应处理器（EmployeeController.java）接收请求，查询人员数据 响应数据到index.jsp页面 123456789101112//查询所有员工（分页查询）@RequestMapping(\"/emps\")public String getEmps(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model)&#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn,5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps,5); model.addAttribute(\"pageInfo\",page); return \"list\";&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;%--取出pageInfo属性中的list，将每一个list都命名为emp--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.list&#125;\" var=\"emp\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;emp.empId&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empName&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.gender=='M'?'男':'女'&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.email&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department.deptName&#125;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-primary btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt; 编辑 &lt;/button&gt; &lt;button class=\"btn btn-danger btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\"&gt; 当前$&#123;pageInfo.pageNum&#125;/$&#123;pageInfo.pages&#125;页，共$&#123;pageInfo.total&#125;条记录 &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;%--首页即第一页--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=1\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;%-- 点击上一页，当前页面减1 --%&gt; &lt;%--如有上一页，就显示上一页图标，否则不显示（因为第一页时点击上一页会显示-1，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasPreviousPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum-1&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--该分页条显示的页码，每一个页码都用pageNum表示，遍历出来--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.navigatepageNums&#125;\" var=\"page_Num\"&gt; &lt;%--当遍历出的这个页码和该显示页面的页码一致时,页码高亮--%&gt; &lt;c:if test=\"$&#123;page_Num == pageInfo.pageNum&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;%--当遍历出的这个页码和该显示页面的页码不一致时,页码不高亮，点击时可跳转至对应页面--%&gt; &lt;c:if test=\"$&#123;page_Num != pageInfo.pageNum&#125;\"&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;page_Num&#125;\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%-- 点击下一页，当前页面加1 --%&gt; &lt;%--如有下一页，就显示下一页图标，否则不显示（因为最后一页时点击下一页会显示不存在的页数，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasNextPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum+1&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--末页即总页码--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pages&#125;\"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2，查询步骤（ajax方法）（推荐） index.jsp页面发送ajax请求查询 服务器将查到的数据，以json字符串的形式返回给浏览器 浏览器收到js字符串，可使用js对json进行解析，使用js通过dom增删改来改变页面 返回json，实现客户端的无关性 给浏览器添加提示信息Msg,java EmployeeController.java 123456789101112131415161718192021222324252627282930313233343536373839package com.yanghan.crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.bean.Msg;import com.yanghan.crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; //查询所有员工（ajax分页查询） @RequestMapping(\"/emps\") @ResponseBody //可以将返回的pageInfo对象转为json字符串,需要导入Jackson包 public Msg getEmpsWithJson(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model) &#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn, 5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps, 5); return Msg.success().add(\"pageInfo\",page); &#125;&#125; index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\" id=\"emps_table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_info_area\"&gt; &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_nav_area\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //页面加载完成后，直接发送ajax请求，获取到分页数据 $(function () &#123; //第一次去首页 to_page(1); &#125;); $(function () &#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=1\", type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125;); //跳到指定页面 function to_page(pn)&#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=\"+pn, type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125; //解析显示表格数据 function build_emps_table(result) &#123; //先清空上一次的数据 $(\"#emps_table tbody\").empty(); //取出json字符串的分页数据 var emps = result.extend.pageInfo.list; //遍历分页数据，index是索引，item是某个属性的集合 $.each(emps,function(index,item)&#123; // alert(item.empName); //构建单元格(append用来追加元素) var empIdTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empId); var empNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empName); var genderTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.gender=='M'?\"男\":\"女\"); var emailTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.email); var deptNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.department.deptName); // &lt;button class=\"btn btn-primary btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt;编辑 // &lt;/button&gt; // &lt;button class=\"btn btn-danger btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt;删除 // &lt;/button&gt; var editBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-primary btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-pencil\").append(\"修改\"); var delBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-danger btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-trash\").append(\"删除\"); //将按钮放在一个单元格中 var btnTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(editBtn).append(\" \").append(delBtn); //构建行(将单元格拼接成行，appendTo表示将该行添加到id为emps_table的tbody标签中) $(\"&lt;tr&gt;&lt;/tr&gt;\").append(empIdTd).append(empNameTd) .append(genderTd).append(emailTd).append(deptNameTd) .append(btnTd).appendTo(\"#emps_table tbody\"); &#125;); &#125; //解析显示分页信息 function build_page_info(result) &#123; //先清空上一次的数据 $(\"#page_info_area\").empty(); $(\"#page_info_area\").append(\"当前\" + result.extend.pageInfo.pageNum + \"/\" + result.extend.pageInfo.pages + \"页，共\" + result.extend.pageInfo.total + \"页\"); &#125; //解析构建分页条信息，点击进行跳转下一页 function build_page_nav(result) &#123; //先清空上一次的数据 $(\"#page_nav_area\").empty(); var ul = $(\"&lt;ul&gt;&lt;/ul&gt;\").addClass(\"pagination\"); //构建元素 var firstPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"首页\").attr(\"href\",\"#\")); var prePageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;laquo;\")); if (result.extend.pageInfo.hasPreviousPage == false) &#123; firstPageLi.addClass(\"disabled\"); prePageLi.addClass(\"disabled\"); &#125;else &#123; //为元素添加翻页事件 firstPageLi.click(function () &#123; to_page(1); &#125;); prePageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum -1); &#125;); &#125; var nextPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;raquo;\")); var lastPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"末页\").attr(\"href\",\"#\")); if (result.extend.pageInfo.hasNextPage == false) &#123; nextPageLi.addClass(\"disabled\"); lastPageLi.addClass(\"disabled\"); &#125;else &#123; nextPageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum +1); &#125;); lastPageLi.click(function () &#123; to_page(result.extend.pageInfo.pages); &#125;); &#125; //页码1，2，3，4 ul.append(firstPageLi).append(prePageLi); $.each(result.extend.pageInfo.navigatepageNums,function (index, item) &#123; var numLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(item)); if (result.extend.pageInfo.pageNum == item) &#123; numLi.addClass(\"active\"); &#125; numLi.click(function () &#123; to_page(item); &#125;); ul.append(numLi); &#125;); ul.append(nextPageLi).append(lastPageLi); //把ul加入到nav var navEle = $(\"&lt;nav&gt;&lt;/nav&gt;\").append(ul); navEle.appendTo(\"#page_nav_area\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"JS语法基础2","slug":"JS语法基础2","date":"2019-10-08T07:15:05.000Z","updated":"2019-10-08T07:15:05.569Z","comments":true,"path":"2019/10/08/JS语法基础2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS语法基础","slug":"JS语法基础","date":"2019-10-08T07:14:58.000Z","updated":"2019-10-08T07:14:58.895Z","comments":true,"path":"2019/10/08/JS语法基础/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SSM整合实例_01_环境搭建","slug":"SSM整合实例_01_环境搭建","date":"2019-10-07T05:59:45.000Z","updated":"2019-10-08T14:19:02.021Z","comments":true,"path":"2019/10/07/SSM整合实例_01_环境搭建/","link":"","permalink":"https://cometorbityh.github.io/2019/10/07/SSM整合实例_01_环境搭建/","excerpt":"","text":"环境搭建1，创建maven工程2，引入jar包 spring相关jar包 springmvc相关jar包 mybatis相关jar包（逆向工程jar包） 数据库连接池，驱动包 其他（jstl，servlet-api，junit，pageHelper分页插件） 3，引入bootstrap前端框架+JS4，编写ssm整合的关键配置文件 web.xml applicationContext.xml springmvc.xml mybatis-config.xml 5，mybatis逆向工程 + 测试（1）mybatis逆向工程生成对应的bean以及mapper 在项目下新建mbg.xml，修改部分内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--mybatis逆向工程--&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!--不生成注释--&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息--&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javaBean生成的位置--&gt; &lt;javaModelGenerator targetPackage=\"com.yanghan.crud.bean\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 指定sql映射文件位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\".\\src\\main\\resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定dao接口生成的位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.yanghan.crud.dao\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定每个表的生成策略:javaBean的名字--&gt; &lt;!-- &lt;table schema=\"DB2ADMIN\" tableName=\"ALLTYPES\" domainObjectName=\"Customer\" &gt;--&gt; &lt;!-- &lt;property name=\"useActualColumnNames\" value=\"true\"/&gt;--&gt; &lt;!-- &lt;generatedKey column=\"ID\" sqlStatement=\"DB2\" identity=\"true\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"DATE_FIELD\" property=\"startDate\" /&gt;--&gt; &lt;!-- &lt;ignoreColumn column=\"FRED\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"LONG_VARCHAR_FIELD\" jdbcType=\"VARCHAR\" /&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;table tableName=\"tbl_emp\" domainObjectName=\"Employee\"/&gt; &lt;table tableName=\"tbl_dept\" domainObjectName=\"Department\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; com.xxx.crud.test包下新建MBGTest.java。 把以下内容复制进入。并修改File configFile = new File(&quot;mbg.xml&quot;); 执行该方法，即可自动生成。 123456789101112131415161718192021222324252627package com.yanghan.crud.test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;//逆向工程测试类public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; MapperTest.java测试是否连接成功数据库（可做增删改操作） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.yanghan.crud.test;import com.yanghan.crud.bean.Department;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.dao.DepartmentMapper;import com.yanghan.crud.dao.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;/** * 测试dao层工作 * Spring的项目可以使用Spring的单元测试，可以自动注入我们需要的组件 * 1、导入SpringTest模块 * 2、@ContextConfiguration指定spring配置文件的位置 * 3、直接autowired要使用的组件即可 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession sqlSession; /** * 测试DepartmentMapper */ @Test public void testCRUD() &#123; //1、插入/删除部门// departmentMapper.insertSelective(new Department(null,\"测试1\"));// departmentMapper.insertSelective(new Department(null,\"测试2\"));// departmentMapper.deleteByPrimaryKey(3); //2、生成员工数据，测试员工插入// employeeMapper.insertSelective(new Employee(null,\"Jerry\",\"M\",\"Jerry@qq.com\",1)); //3、批量插入多个员工；使用可执行批量操作的sqlSession //for循环并非批量，是插入1000次，而sqlsession是预编译sql，然后修改参数进行插入 EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); String uid = \"initUid\"; int rid1 = 666; int rid2 = 666; for (int i = 0; i &lt; 100; i++) &#123; uid = UUID.randomUUID().toString().substring(0, 5)+i; rid1 = (int)(1+Math.random()*(2-1+1)); rid2 = (int)(1+Math.random()*(2-1+1)); mapper.insertSelective(new Employee(null,uid,(rid1==1)?(\"M\"):(\"W\"),uid+\"@test.com\",rid2)); &#125; &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SpringMVC(3)","slug":"SpringMVC-3","date":"2019-10-06T07:11:34.000Z","updated":"2019-10-06T07:11:34.539Z","comments":true,"path":"2019/10/06/SpringMVC-3/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringMVC(2)","slug":"SpringMVC-2","date":"2019-10-06T07:11:26.000Z","updated":"2019-10-06T14:28:25.267Z","comments":true,"path":"2019/10/06/SpringMVC-2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-2/","excerpt":"","text":"文件上传文件上传需要的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 1.传统方式实现文件上传2.SpringMVC实现本地服务器文件上传在springmvc.xml文件中配置 文件解析器 对象 12345&lt;!-- 配置文件解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--最大上传大小：10MB=10*1024*1024B--&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; 3.SpringMVC实现跨服务器文件上传跨服务器上传文件需要的2个jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 4.代码 index.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;SpringMVC方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;跨服务器方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.yanghan.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;@Controller@RequestMapping(\"/file\")public class FileController &#123; /** * 跨服务器文件上传 * @return */ @RequestMapping(\"/fileupload3\") public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"跨服务器文件上传...\"); // 定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 创建客户端的对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; &#125; /** * SpringMVC文件上传 * @return */ @RequestMapping(\"/fileupload2\") public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println(\"springmvc文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return \"success\"; &#125; /** * 文件上传 * @return */ @RequestMapping(\"/fileupload1\") public String fileupload1(HttpServletRequest request) throws Exception &#123; System.out.println(\"文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for(FileItem item:items)&#123; // 进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; // 说明普通表单向 &#125;else&#123; // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 item.write(new File(path,filename)); // 删除临时文件 item.delete(); &#125; &#125; return \"success\"; &#125;&#125; 异常处理 web.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 字符过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp【测试页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"ex/testException\"&gt;异常测试&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ExceptionController.java【处理器】 1234567891011121314151617181920212223242526package com.yanghan.controller;import com.yanghan.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/ex\")public class ExceptionController &#123; @RequestMapping(\"/testException\") public String testException() throws SysException &#123; System.out.println(\"testException执行了...\"); try &#123; // 模拟异常 int a = 10/0; &#125; catch (Exception e) &#123; // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new SysException(\"出现异常了...\"); &#125; return \"success\"; &#125;&#125; SysException.java【系统异常实体类】 1234567891011121314151617181920212223package com.yanghan.exception;/** * 自定义异常类 */public class SysException extends Exception&#123; // 存储提示信息的 private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; SysExceptionResolver.java【异常处理器】 12345678910111213141516171819202122232425262728293031323334package com.yanghan.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver&#123; //处理异常业务逻辑 public ModelAndView resolveException (HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // 获取到异常对象 SysException e = null; if(ex instanceof SysException)&#123; e = (SysException)ex; &#125;else&#123; e = new SysException(\"系统正在维护....\"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\",e.getMessage()); mv.setViewName(\"error\"); return mv; &#125;&#125; springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.yanghan\"/&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!--配置异常处理器--&gt; &lt;bean id=\"sysExceptionResolver\" class=\"com.yanghan.exception.SysExceptionResolver\"/&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; error.jsp【返回的错误信息页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;errorMsg&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"SpringMVC(1)","slug":"SpringMVC-1","date":"2019-10-05T12:17:55.000Z","updated":"2019-10-06T10:19:45.392Z","comments":true,"path":"2019/10/05/SpringMVC-1/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/SpringMVC-1/","excerpt":"","text":"1. SpringMVC1.1. 简介SpringMVC框架基于组件方式的执行流程 1.导包 2.写配置 配置前端控制器。指明springmvc的配置文件的位置 配置视图解析器，简化方法返回值（目标页面地址），实现前缀+返回值+后缀以拼接地址。 3.测试 1.2. 入门案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.orbit&lt;/groupId&gt; &lt;artifactId&gt;springmvc_01_newstart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_01_newstart Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvc_01_newstart&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;============================== web.xml ==============================&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置解决中文乱码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.orbit\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器对象:可以根据服务方法的返回值,自动的拼接最终的跳转路径--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持：自动配置处理器映射器和处理器适配器 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 1234567891011121314151617============================== FirstController.java ==============================package com.orbit.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class firstController &#123; @RequestMapping(path=\"/hello\") public String sayHello()&#123; System.out.println(\"hello,SpringMVC\"); return \"success\"; &#125;&#125; 12345678910111213141516171819202122232425============================== index,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;第一个springMVC程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;点我跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;============================== success,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 跳转成功！&lt;/body&gt;&lt;/html&gt; 1.3. 用到的注解@RequestMapping:表示请求的具体的模块 value=&quot;/xx&quot;或path=&quot;/xx&quot;：指定请求的url method={RequestMethod.GET}：指定请求方式，GET，POST，…，是一个枚举类型的数组 params={&quot;&quot;}：指定请求中必须包含的请求参数的表达式集，是一个String类型的数组 params={&quot;param1&quot;}：请求中必须包含请求参数params1 params={&quot;!param1&quot;}：请求中不能包含请求参数param1 params={&quot;param1=123&quot;}：请求中必须包含请求参数params1，且其值必须是123 params={&quot;param1!=123&quot;}：请求中包含的请求参数的值不能是123（也可不包含param1，此时param1=null） params={&quot;param1=123&quot;,&quot;param2=zs&quot;}：请求中必须包含请求参数params1和param2，且param1=123,param2=zs headers={&quot;k=v&quot;}：指定发送的请求中必须包含的请求头 @RequestParam：获取请求的参数值，相当于request.getParameter(&quot;user&quot;); value=&quot;user&quot;：指定请求参数的key required：是否必须包含请求参数，true表示url一定要包含该请求参数，false表示可不包含 defaultValue：设置该参数的默认值 RequestHeader：获取请求头的部分的值 @RequestBody：获取请求体内容 @PathVariable获取请求路径中对应占位符的值。例如：url中有/delete/{id}，{id}就是占位符 。注意：1个占位符只能占1层路径 @ModelAttribute：出现在方法上：表示当前方法会在控制器方法执行前线执行。出现在参数上：获取指定的数据给参数赋值。 @CookieValue·：用于获取指定cookie的名称的值 2. 请求参数绑定2.1. 传入POJO，级联12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970============================== Account.java ==============================package com.orbit.domain;public class Account &#123; private Integer id; private String pwd; private Double money; private User user; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; //getter setter toString&#125;package com.orbit.domain;public class User &#123; private String uname; private Integer uage; //getter setter toString&#125;============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"params/saveAccount\" method=\"post\"&gt;序号：&lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"pwd\"&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"user.uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"user.uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"list[0].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"list[0].uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"map['one'].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"map['one'].uage\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;============================== ParamsController.java ==============================package com.orbit.controller;import com.orbit.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/params\")public class ParamsController &#123; @RequestMapping(\"/saveAccount\") public String savaAccount(Account account)&#123; System.out.println(account); return \"success\"; &#125;&#125;============================== 其他页面同入门案例 ============================== 2.2. 数据输出的方式（1）传入原生API (方式1)SpringMVC的handler接收如下的ServletAPI类型的参数： 123456789• HttpServletRequest• HttpServletResponse• HttpSession• java.security.Principal• Locale• InputStream• OutputStream• Reader• Writer （2）Map，Model，ModelMap（方式2）处理方法返回时，Map中的数据会自动添加到模型中 （3）ModelAndView作为返回值输出（方式3） 方法的返回值可以是ModelAndView类型， 既包含视图信息（页面地址），也包含模型数据（携带到页面的数据），模型数据存放在请求域（requestScope）中。 （4）@SessionAttributes临时保存数据（方式4）(了解)@SessionAttributes只能标在类上，是SpringMVC提供的一种临时在session域中保存数据的方式。 value=&quot;xx&quot;：本类中以xx为key所对应的值，临时复制到session域中 规则：将该类中保存在 BindingAwareModelMap 或 ModelAndView 中的数据，临时复制一份到session域中。 （5）@ModelAttribute（6）@ResponseBody响应json数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152============================== pom.xml ============================== &lt;dependencies&gt; &lt;!-- 新增依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yanghan\"&gt;&lt;/context:component-scan&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 告诉前端控制器，哪些路径下的资源不拦截--&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\"/&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 页面加载，绑定单击事件 $(function()&#123; $(\"#btn\").click(function()&#123; // alert(\"hello btn\"); // 发送ajax请求 $.ajax(&#123; // 编写json格式，设置属性和值 url:\"demo/testAjax\", contentType:\"application/json;charset=UTF-8\", data:'&#123;\"uid\":\"10001\",\"uname\":\"zs\",\"upwd\":123&#125;', dataType:\"json\", type:\"post\", success:function(data)&#123; // data服务器端响应的json的数据，进行解析 alert(data); alert(data.uid); alert(data.uname); alert(data.upwd); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122============================== TestController.java ==============================package com.yanghan.controller;import com.yanghan.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(\"/demo\")public class TestController &#123; @RequestMapping(\"/testAjax\") public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println(user.toString()); user.setUname(\"张三\"); return user; &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"Spring框架——AOP","slug":"Spring框架——AOP","date":"2019-10-05T05:35:06.000Z","updated":"2019-10-05T12:22:59.679Z","comments":true,"path":"2019/10/05/Spring框架——AOP/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/Spring框架——AOP/","excerpt":"","text":"3. Spring中的AOP3.1. 引出问题（1）完善之前的account案例 （2）引出问题 （3）动态代理的2种实现方式 （4）解决问题 3.2. AOP的基本概述（1）AOP中的一些专业术语 连接点（Joinpoint）：业务层中所有的方法 切入点（Pointcut）：业务层中所要代理增强的方法 切入点一定是连接点，但连接点不一定是切入点 通知/增强（advice）：拦截到连接点后做的事情即通知。 通知类型：前置通知，后置通知，异常通知，最终通知，环绕通知 引介（Introduction）一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 目标对象（Target）代理的目标对象。 代理（Proxy）一个类被 AOP 织入增强后，就产生一个结果代理类。 切面（Aspect） 是切入点和通知（引介）的结合。 织入（Weaving）: 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 3.3. 基于XML的AOP配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day03_eesy_04adviceType&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.itheima.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\" &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154============================== AccountService.java ==============================package com.itheima.service;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /** * 删除账户 * @return */ int deleteAccount();&#125;============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService&#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125; ============================== Logger.java ============================== package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试AOP的配置 */public class AOPTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); //3.执行方法 as.saveAccount(); &#125;&#125; 3.4. 基于注解的AOP配置@Pointcut(&quot;execution(* com.xxx.service.impl.*.*(..))&quot;)：切入点表达式注解 private void pc(){} @Before(pc())：前置通知注解 @AfterReturning(&quot;pc()&quot;)：后置通知注解 @AfterThrowing(&quot;pc()&quot;)：异常通知注解 @After&quot;pc()&quot;)：最终通知注解 @Around(&quot;pc()&quot;)：环绕通知注解 注意： 使用注解AOP配置会先执行最终通知，后执行后置通知/异常通知； 使用环绕通知则按照正常顺序执行。 因此实际开发时应该注意这个细节，正确选择合适的注解。 12345678910111213141516171819202122============================== pom.xml ==============================......============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置spring开启注解aop的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119============================== AccountService.java ==============================......============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;import org.springframework.stereotype.Service;/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService&#123; public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125;============================== Logger.java ==============================package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 用于记录日志的工具类，它里面提供了公共的代码 */@Component(\"logger\")@Aspect //表示当前类是切面public class Logger &#123; @Pointcut(\"execution(* com.itheima.service.impl.*.*(..))\") private void pc()&#123;&#125; /** * 前置通知 */ @Before(\"pc()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ @AfterReturning(\"pc()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ @AfterThrowing(\"pc()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ @After(\"pc()\") public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pc()\") public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================......","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring——JdbcTemplate,事务控制","slug":"Spring——JdbcTemplate-事务控制","date":"2019-10-04T15:13:33.000Z","updated":"2019-10-05T05:33:44.980Z","comments":true,"path":"2019/10/04/Spring——JdbcTemplate-事务控制/","link":"","permalink":"https://cometorbityh.github.io/2019/10/04/Spring——JdbcTemplate-事务控制/","excerpt":"","text":"4. Spring中的JdbcTemlateJdbcTemplate 是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。 导包： spring-jdbc-5.0.2.RELEASE.jar （数据库相关） spring-tx-5.0.2.RELEASE.jar（事务相关） JdbcTemplate的基础案例： 123456789101112131415============================== Account.java ============================== package com.yanghan.domain;/** * 账户实体类 */public class Account &#123; private Integer id; private String name; private Float money; //get + set //toString()&#125; 12345678910111213141516171819202122232425262728293031323334353637============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yanghan&lt;/groupId&gt; &lt;artifactId&gt;spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5. Spring中的事务控制","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring框架——IOC","slug":"Spring框架——IOC","date":"2019-10-02T07:53:22.000Z","updated":"2019-10-05T05:34:40.467Z","comments":true,"path":"2019/10/02/Spring框架——IOC/","link":"","permalink":"https://cometorbityh.github.io/2019/10/02/Spring框架——IOC/","excerpt":"","text":"1. Spring框架的基本概述1.1. Spring是什么？ 2. Spring中的IOCIOC : invertion of control（控制反转）——把对象的创建交给spring（IOC容器）来处理 IOC容器的理解：读取一个全限定类名，反射创建一个对象，并且存入核心容器中，最后通过对应的id来将该对象取出来。 2.1. 基于XML的IOC配置2.1.1. IOC中的bean标签 作用： 用于配置对象让 spring 来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 * singleton :默认值，单例的. * prototype :多例的. * request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. * session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. * global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session. init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162------------------------------ AccountService.java ------------------------------package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125;------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;public class AccountServiceImpl implements AccountService &#123; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125;------------------------------ bean.xml ------------------------------ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); System.out.println(as); &#125;&#125;------------------------------ 输出结果 ------------------------------ com.yanghan.service.impl.AccountServiceImpl@26be92ad 2.1.2. IOC 中的 DI 依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。注入依赖。 （1）构造函数注入 顾名思义，就是使用类中的构造函数，给成员变量赋值。 注意：赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。 要求： 类中需要提供一个对应参数列表的构造函数。 （有参构造函数） 标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 （需记忆参数索引位置，因此不用） type :指定参数在构造函数中的数据类型 （若有2个数据类型一样的参数则无法辨别，因此不用） name:指定参数在构造函数中的名称 用这个找给谁赋值 （推荐使用） （==上面三个找要赋值的参数，下面两个是给参数赋值==） value:它能赋的值是基本数据类型和 String 类型 ref :它能赋的值是其他 bean 类型，引用关联的bean对象，必须得是在配置文件中配置过的 bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283------------------------------ AccountService.java ------------------------------ package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125; ------------------------------ AccountServiceImpl.java ------------------------------ package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"西门吹雪\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ 西门吹雪,18,Thu Oct 03 13:56:03 CST 2019 （2）set方法注入 前提：setter方法 + 无参构造函数 标签：property 属性： name：找的是类中 set 方法后面的部分 ref ：引用其他 bean 类型 value：基本数据类型和 string 类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- set方法注入 --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"菠萝吹雪\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"20\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ 输出结果 ------------------------------菠萝吹雪,20,Thu Oct 03 14:45:23 CST 2019 （3）集合数据的注入（set方法） 在注入集合数据时，只要结构相同，标签可以互换 用于给List 结构集合注入的标签： list，array，set 用于给Map结构集合注入的标签：map，props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.*;public class AccountServiceImpl implements AccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,Object&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, Object&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"myStrs\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"张三\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"李四\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ [AAA, BBB, CCC][AAA, BBB, CCC][AAA, BBB, CCC]&#123;name=张三, sex=男&#125;&#123;name=李四, sex=男&#125; 2.2. 基于注解的IOC配置spring中IOC的常用注解学习基于注解的 IoC 配置，注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 实际开发中，基于注解和XML的IOC配置混合使用。 根据作用分类 基于XML的IOC配置 基于注解的IOC配置 创建对象（将当前类对象存入spring容器中） &lt;bean&gt;标签 @Component(value=&quot;bean-id&quot;) 默认值为当前类名首字母小写@Controller(value=&quot;bean-id&quot;)：用于表现层@Service(value=&quot;bean-id&quot;)：用于业务层@Repository(value=&quot;bean-id&quot;)：用于持久层 注入数据 &lt;bean&gt;标签中的 &lt;property&gt;标签 （1）注入其他bean：@autowired 自动按照类型注入。即bean的class ＊若容器中有唯一的bean对象类型与要注入的变量类型匹配，则注入成功。 ＊若容器中没有bean对象类型与要注入的变量类型匹配，则注入失败，报错。 ＊若容器中有多个bean对象类型匹配与要注入的变量类型匹配，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 出现位置：变量上 ／ 方法上@qualifier(value=&quot;bean-id&quot;) 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。 在给字段注入时，不能独立使用，必须和@autowired一起使用； 在给方法参数注入时，可以独立使用。@resource(name=&quot;bean-id&quot;)（2）注入基本类型和String：@Value(value=&quot;具体数据&quot;)：可以使用spEL（spring的EL表达式）（3）注入集合类型：只能通过XML来实现 改变作用范围 &lt;bean&gt;标签中的 scope属性 @Scope(value=&quot;&quot;) 指定bean的作用范围； value的取值：singleton，prototype，request，session，globalsession 生命周期相关 &lt;bean&gt;标签中的 init-method属性 destory-method属性 2.3. IOC案例（持久层技术选择：dbutils）案例1：使用XML方式实现单表的CRUD操作案例2：使用XML方式和注解方式实现单表的CRUD操作案例3：使用纯注解的方式实现单表的CRUD操作（spring的一些新注解使用） @Configuration：表示该类是一个配置类 @ComponentScan( value=&quot;xxx&quot; )：指定spring在创建容器时要扫描的包 @ComponentScan( basePackages=”xxx” ) @Bean(name= &quot;bean-id&quot; )：把当前方法的返回值作为bean对象存入spring的ioc容器中 当我们用注解配置方法时，若方法有参数，spring框架会去容器中查找有无可用的bean对象，查找的方式与Autowired注解一致。 @Import( )：导入其他的配置类，value的值是配置类的字节码 带有Import注解的配置类称为父配置类，被导入的配置类称为子配置类 @PropertySource：导入配置文件 spring和Junit整合#","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"JavaWeb--ajax","slug":"JavaWeb-ajax","date":"2019-09-27T09:58:24.000Z","updated":"2019-09-30T14:41:13.904Z","comments":true,"path":"2019/09/27/JavaWeb-ajax/","link":"","permalink":"https://cometorbityh.github.io/2019/09/27/JavaWeb-ajax/","excerpt":"","text":"ajax简介1. 概念1.1. Ajax 【 Asynchronous JavaScript And XML 】【 异步的JavaScript和XML 】 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 1.2. 异步和同步的概念​ 同步：客户端给服务端发送请求，客户端必须等待服务器端的响应，在等待服务端处理请求的过程中，客户端无法进行其他操作； ​ 异步：客户端给服务端发送请求，客户端无需等待服务器端的响应，在等待服务端处理请求的过程中，客户端可以进行其他操作。 2. 实现方式2.1. 原生的JS实现方式（了解） XMLHttpRequest 用于在后台与服务器交换数据 XMLHttpRequest对象的2个方法 open 方法 １. 作用：与服务器建立连接。 ２. open方法的３个参数: (1). 请求方式(GET、POST) (2). 请求的URL： ＊若请求方式为GET，则将请求参数拼接在URL后方，send方法为空参或null ＊请求参数为POST，则将请求参数在send方法中定义 (3). 是否为异步请求，true为异步，false为同步send 方法 1. 作用：发送请求 2. send(xxx); XMLHttpRequest对象的2个属性 readyState（就绪状态） 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status（响应状态码） 200: “OK” 404: 未找到页面 2.2. JQuery实现方式（掌握） $.ajax( ) 语法：$.ajax({键值对});由于有很多内置键，因此举个例子介绍常用的几个键： $.get( ) 语法：$.get ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） $.post( ) 语法：$.post ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） —– 举个例子 —– ajax01.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;发送异步请求&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function fun1() &#123; $.ajax(&#123; url:\"ajaxServlet\", //请求路径 type:\"POST\", //请求方式 data:&#123;\"username\":\"Ajax\"&#125;, //请求参数 //data:\"username=jack\", success:function (data) &#123; //响应成功后的回调函数 alert(data); &#125;, error:function () &#123; alert(\"出错了\"); &#125;, &#125;); &#125; function fun2() &#123; $.get(\"ajaxServlet\",&#123;username:\"Get\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; function fun3() &#123; $.post(\"ajaxServlet\",&#123;username:\"Post\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"submit\" value=\"ajax方式发送异步请求\" onclick=\"fun1();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"get 方式发送异步请求\" onclick=\"fun2();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"post方式发送异步请求\" onclick=\"fun3();\"&gt;&lt;/body&gt;&lt;/html&gt; AjaxServlet.java 12345678910111213141516171819202122232425package com.test.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/ajaxServlet\")public class AjaxServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求参数 String username = request.getParameter(\"username\"); //2.处理业务逻辑 //3.打印username System.out.println(username); //4.响应 response.getWriter().write(\"hello:\"+username); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; JSON1. 概念 【JSON】【Javascript Object Notation】【JavaScript对象表示法】 进行数据的传输。是存储和交换文本信息的语法。 类似XML，但比XML更小更快，更易解析 2. JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 2.1. JSON定义数据的规则数据在名称/值对中 ＊键用引号（单双均可）括起来，也可以不使用引号 ＊JSON 值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 数据由逗号分隔：多个键值对用逗号隔开 花括号保存对象 方括号保存数组 2.2. JSON获取数据的规则 json对象的键名 json对象[“键名”] 数组对象[索引] 2.3. JSON遍历数据for ( var 键 in json对象 ) { ​ alert ( json对象 [ 键 ] ); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;script&gt; //1. 定义基本格式 var person = &#123;name:\"熊大\",age:23,gender:true&#125;; //alert(person.name); //遍历基本格式的json数据 for(var key in person)&#123; //key是字符串，person.key相当于person.\"xxx\"，因此不可取 alert(key + \":\" + person[key]); &#125; //2. 嵌套格式 （json对象中的数组） var persons = &#123; person:[ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ] &#125;; alert(persons.person[2].name); //3. 嵌套格式 （数组中的json对象） var persons2 = [ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ]; //alert(persons2[1].name); // 遍历数组中的json数据 for(var i=0;i&lt;persons2.length;i++)&#123; var p = persons2[i]; for(var key in p)&#123; alert(key + \":\" +p[key]); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JavaWeb项目——学生管理系统","slug":"JavaWeb项目——学生管理系统","date":"2019-09-06T08:31:03.000Z","updated":"2019-09-06T08:35:23.962Z","comments":true,"path":"2019/09/06/JavaWeb项目——学生管理系统/","link":"","permalink":"https://cometorbityh.github.io/2019/09/06/JavaWeb项目——学生管理系统/","excerpt":"","text":"1. 创建数据库123456CREATE TABLE `t_stu` (`id` int(10) NOT NULL AUTO_INCREMENT ,`uname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`upwd` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,PRIMARY KEY (`id`)) 2. 创建JDBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBC &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); System.out.println(\"驱动注册成功\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); System.out.println(\"数据库连接成功\"); stmt = conn.createStatement(); System.out.println(\"连接对象创建成功\"); String sql = \"select * from t_stu\"; rs = stmt.executeQuery(sql); if(rs.next()) &#123; System.out.print(rs.getInt(\"id\")+\" \"); System.out.print(rs.getString(\"uname\") + \" \"); System.out.println(rs.getString(\"upwd\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"项目","slug":"项目","permalink":"https://cometorbityh.github.io/tags/项目/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-09-03T08:55:59.000Z","updated":"2019-09-29T16:34:22.908Z","comments":true,"path":"2019/09/03/JDBC/","link":"","permalink":"https://cometorbityh.github.io/2019/09/03/JDBC/","excerpt":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。","text":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。 一、JDBC编程6步 注册驱动（作用：告知Java程序，指明将要连接的数据库品牌） 获取连接（打开JVM的进程和数据库的进程之间的通道，属于进程之间的通信，使用完需要关闭） 获取数据库操作对象（专门执行sql语句的对象） 执行sql语句（DQL，DML） 处理查询指令集（只有当第四步执行的是select语句的时候，才需要第五步，否则省略） 释放资源（关闭JVM的进程和数据库的进程之间的通信资源） 二、JDBC的基本使用本例使用的是Mysql数据库，其驱动为mysql-connector-java-5.1.47.jar. 新建java project——在项目下新建文件夹lib——导入Mysql驱动jar包，右键jar包，点击build path,add 即可。 1. 使用Statement对数据库进行 “增删改” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.orbit.jdbc;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class test01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; // 1.注册驱动 //方式一// Driver driver = new com.mysql.jdbc.Driver();// Driver driver = new com.oracle.Driver.OracleDriver();// DriverManager.registerDriver(driver); //方式二(常用，原因是参数是字符串，字符串可以写到properties文件中，起到解耦合的作用) //该方法无需接收返回值，因为我们只想用它的类加载动作 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.获取连接 // oracle的URL： jdbc:oracle://localhost:1521:xxx String url = \"jdbc:mysql://localhost:3306/orbit\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); //com.mysql.jdbc.JDBC4Connection@3d646c37 System.out.println(conn); // 3.获取数据库操作对象（Statement专门执行sql语句） stmt = conn.createStatement(); // 4.执行sql (JDBC中的sql语句不需要分号结尾)// String sql = \"insert into dept(dno,dname,dage) values(2,'LS',23)\"; String sql = \"delete from dept where dno = 2\";// String sql = \"update dept set dname='王五',dage='20' where dno=1\"; // 专门执行DML语句的（insert，delete，update），返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); // 5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源，为了保证资源一定释放，必须放到finally语句中关闭资源 // 并且要遵循从小到大依次关闭，分别对其try...catch try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注册驱动的方式二为什么能够用放射直接调用？** ​ 因为mysql的驱动包中的com.mysql.jdbc包下的Driver.java的静态块中已经注册了驱动 2. 从属性配置文件中获取连接在src文件下新建file，输入”db.properties” db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/orbituser=rootpassword=123456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"insert into dept(dno,dname,dage) values(3,'娜可露露',22)\"; int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3. 使用Statement对数据库进行 “查” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"select dno,dname,dage from dept\"; rs = stmt.executeQuery(sql); System.out.println(rs); while(rs.next()) &#123; //该行有元素 int eno = rs.getInt(1); String ename = rs.getString(2); int eage = rs.getInt(3); //第二种写法：在getString中直接写入列名// String eno = rs.getString(\"dno\"); // String ename = rs.getString(\"dname\");// String eage = rs.getString(\"dage\"); System.out.println(eno +\" \" + ename + \" \" +eage); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4. 实例（设计登录界面，并解决SQL注入）这里使用到一个工具“PowerDesigner16.5”，用以物理建模，它与MySQL所不同的是，PowerDesigner用于设计阶段的物理建模，而MySQL用于开发阶段的数据处理。 123456789101112131415161718drop table if exists t_user;/*==============================================================*//* Table: t_user *//*==============================================================*/create table t_user( id bigint auto_increment, loginName varchar(255), loginPwd varchar(255), realName varchar(255), primary key (id));insert into t_user(loginName,loginPwd,realName) values('Zhangsan','123','张三');insert into t_user(loginName,loginPwd,realName) values('LiSi','123','李四');insert into t_user(loginName,loginPwd,realName) values('Wangwu','123','王五');commit;select * from t_user; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest02 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; Statement stmt = null; ResultSet rs = null; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql String sql = \"select * from t_user where loginName = '\"+loginName+\"' and loginPwd = '\"+loginPwd+\"'\"; //5、处理查询结果集 //发生sql语句给DBMS，DBMS进行sql编译 rs = stmt.executeQuery(sql); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 但是此时的程序存在一个安全问题，请看下面案例： 该现象称为“SQL注入”，这是一个安全隐患，是黑客入侵常用手段。 发生sql注入的原因是什么？ 用户输入的信息中含有sql的关键字，并且这些关键字拼接在sql语句中，参与sql语句的编译过程，导致sql语句原意被扭曲，进而引起sql注入。 如何解决SQL注入？ 只要用户提供的信息不参与SQL语句的编译过程，问题即可解决。 即便用户提供的信息中包含SQL的关键字，但这些关键字没有参与编译，就不会起作用 要想用户信息不参与SQL编译，需要用到java.sql.PreparedStatement PreparedStatement接口继承了java.sql.Statement，是预编译数据库操作对象(作用：编译、 ) 其原理为：预先对SQL语句的框架进行编译，然后再给SQL语句传值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest03 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、执行sql语句框架 // ?表示一个占位符，用来接收值。注意？不加单引号 String sql = \"select * from t_user where loginName = ? and loginPwd = ?\"; //4、获取预编译数据库操作对象 ps = conn.prepareStatement(sql); //给占位符传值，若为字符串，其传值方法为setString(下标，值)； JDBC的下标都是从1开始的 ps.setString(1,loginName); //将对应下标的？替换为'xxxx' ps.setString(2,loginPwd); // ps.setString(3,100); 将对应下标的？替换为100 //5、处理查询结果集 rs = ps.executeQuery(); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 比较Statement和PreparedStatement Statement存在注入问题，PreparedStatement可以解决SQL注入问题 Statement是编译一次执行一次，PreparedStatement是编译一次执行N次；（多次执行相同的sql语句时，DBMS只会编译一次就可以执行多次。Statement的sql语句中包含可变的参数，每次执行都要重新编译，PreparedStatement中sql语句占位符是固定的符号，只需编译一次即可执行多次） PreparedStatement会在编译阶段做类型的安全检查，如setString()方法中输入了int型字符，系统会报错。 因此，PreparedStatement使用场景较多。但需要sql注入时就要用到Statement 5.实例（Statement实现输入升序降序）升序降序用PreparedStatement传值给占位符？是不可行的，因为desc,asc都是字符串，传进入的话会加上引号，无法识别，因此需要用到Statement来实现输入升序降序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.*;import java.util.Scanner;public class JDBCTest04 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(\"输入asc/desc进行升序/降序：\"); String keyWord = sc.nextLine(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); stmt = conn.createStatement(); String sql = \"select loginName from t_user order by loginName \"+ keyWord; rs = stmt.executeQuery(sql); while (rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 6.使用PreparedStatement增删改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.jdbc;import java.sql.*;public class JDBCTest05 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\");// String sql = \"insert into t_user(loginName,loginPwd,realName) values(?,?,?)\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"ZhaoLiu\");// ps.setString(2,\"123\");// ps.setString(3,\"赵六\");// String sql = \"delete from t_user set loginName = ? ,realName = ? where id = ?\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"WangBa\");// ps.setString(2,\"王八\");// ps.setInt(3,4); String sql = \"delete from t_user where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1,4); int count = ps.executeUpdate(); System.out.println(count + \"行受影响\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 7. JDBC事务问题(模拟账户转账)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); //空指针异常，会导致程序中途停止运行 //导致用户10001丢失10000元，而用户10002也没收到10000元 String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解决方案(3行重要代码) conn.setAutoCommit(false); 禁用自动提交事务，开启事务 conn.commit(); 手动提交事务，即在此处才执行sql语句，事务结束 conn.rollback(); 回滚事务，回到事务发生之前数据，事务结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //禁用自动提交事务 conn.setAutoCommit(false); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); //手动提交事务 conn.commit(); &#125; catch (Exception e) &#123; if(conn != null)&#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 8.简化代码为工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.orbit.jdbc.DBUtil;import java.sql.*;public class DBUtil &#123; /*工具类的构造方法都是私有的， * 因为工具类的方法都是静态的，无需new对象，直接使用类名调用*/ private DBUtil()&#123;&#125; //静态代码块在类加载时执行，且只执行一次 //注册驱动只需要执行一次，因此放在静态代码块中 static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; //Statement ps面向抽象编程 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627package com.orbit.jdbc;import com.orbit.jdbc.utils.DBUtil;import java.sql.*;public class JDBCTest07 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = \"select loginName from t_user where loginName like ?\"; ps = conn.prepareStatement(sql); ps.setString(1,\"%g%\"); rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtil.close(conn,ps,rs); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/tags/JDBC/"}]},{"title":"JSP——系统开发模型","slug":"JSP——系统开发模型","date":"2019-08-31T06:51:33.000Z","updated":"2019-09-03T15:06:52.679Z","comments":true,"path":"2019/08/31/JSP——系统开发模型/","link":"","permalink":"https://cometorbityh.github.io/2019/08/31/JSP——系统开发模型/","excerpt":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构","text":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构 开发模型1. 纯JSP将所有业务处理、数据显示功能全都放在JSP页面完成。 缺点：代码结构乱，显示功能与业务处理功能代码没有划分，维护和升级麻烦。 2. JSP+JavaBean的Model1该开发模型将大多数业务处理交给专门的JavaBean完成。JSP页面主要负责数据显示功能。相对于“纯JSP”来说，已经得到极大改进。但是对于客户端的请求的解析，对于JavaBean对象的选择和创建，还是由JSP页面处理，即JSP还负责大量的请求解析、业务处理功能。 JavaBean的介绍 JavaBean 广义JavaBean，一般的Java类，主要功能：承载数据，业务处理 数据承载Bean：实体类，专门用于承载数据（装数据）的类，如User，Student 业务处理Bean：Service或Dao对象，专门用以处理用户提交请求的类。 狭义JavaBean：符合SUN公司提出的“JavaBean规范”的Java类。JavaBean规范规定，该类需满足以下四点： 公共，public class 实现Serializable接口 具备无参构造器 若有成员变量，则成员变量应该是私有的，且提供getter和setter 实际项目中，实体类（广义JavaBean的数据承载Bean）一般会被定义成满足“JavaBean规范”的狭义JavaBean 3. MVC的Model2MVC Model（模型），承载数据，并对用户的请求进行计算的模块。分为数据承载Bean和业务处理Bean，其实就是JavaBean。 View（视图），为用户提供使用界面，与用户进行直接交互 Controller（控制器），将请求转发给相应的Model进行处理，即选择使用哪一个JavaBean来处理请求。并提供Model的计算结果向用户进行相应的响应。 4. MVC + 三层架构三层架构 View层 / 视图层 / 表现层 / web层，编写用于接收用户请求的代码 Service层 / 服务层 / 业务层 / 逻辑层，编写系统的业务逻辑 Dao层 / 持久层 / 数据访问层，编写直接操作数据库的代码，Data Access Object数据访问对象 为了更好的降低各层之间的耦合度，在三层架构程序设计中，采用面向抽象编程，即上层对下层的调用是通过接口实现的。下层对上层的真正服务者，是下层接口的实现类，服务标准（接口）是相同的，服务提供者（实现类）可更换，这就实现了层间解耦合。 MVC + 三层架构 “MVC + 三层架构”开发模型，主要是指将MVC的业务处理Model分成了2层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。 “MVC + 三层架构”开发模型，是传统的JavaWeb项目最常用的开发模型。 实例：学生登录系统","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——JSTL","slug":"JSP——JSTL","date":"2019-08-30T08:22:01.000Z","updated":"2019-08-31T06:49:16.550Z","comments":true,"path":"2019/08/30/JSP——JSTL/","link":"","permalink":"https://cometorbityh.github.io/2019/08/30/JSP——JSTL/","excerpt":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。","text":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。 JSTL中定义了5个标签库： 核心标签库：主要用于完成基本逻辑运算 格式化标签库：主要用于完成日期、数字的格式化显示 EL函数标签库：定义了16个EL函数 SQL操作标签库：完成SQL操作，现已废弃不用，Java代码即可完全实现SQL操作 XML操作标签库：完成XML操作，现已废弃不用，Java代码即可完全实现XML操作 1 核心标签库（遍历数据等）12&lt;!-- 使用前先导入标签库 --&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; c:set——为指定变量赋值123456789101112131415161718192021222324252627282930313233package com.orbit.beans;public class Information &#123; private String uname; private String gender; public Information() &#123; // TODO Auto-generated constructor stub &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Information(String uname, String gender) &#123; super(); this.uname = uname; this.gender = gender; &#125; @Override public String toString() &#123; return \"Information [uname=\" + uname + \", gender=\" + gender + \"]\"; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:set 为域中的指定变量赋值 --------------- &lt;br/&gt; &lt;!-- var是变量名，value是变量值，scope是变量所在域，默认是pageContext --&gt; &lt;c:set var=\"name\" value=\"小明\" scope=\"session\"/&gt; name = $&#123;name &#125;&lt;br/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为域中的Bean对象的属性赋值 --------------- &lt;br/&gt; &lt;% Information info = new Information(); pageContext.setAttribute(\"info\", info); %&gt; &lt;!-- property表示属性名，value表示属性值，target表示属性的范围 --&gt; &lt;c:set value=\"小李\" property=\"uname\" target=\"$&#123;pageScope.info &#125;\"/&gt; &lt;c:set value=\"男\" property=\"gender\" target=\"$&#123;pageScope.info &#125;\"/&gt; info = $&#123;info&#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为Map的键值赋值 --------------- &lt;br/&gt; &lt;% Map &lt;String,Object&gt; map = new HashMap(); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- property表示指定key，value表示key的值，target表示key的范围 --&gt; &lt;c:set value=\"网龙\" property=\"company\" target=\"$&#123;pageScope.map&#125;\"/&gt; &lt;c:set value=\"福建\" property=\"place\" target=\"$&#123;pageScope.map&#125;\"/&gt; map = $&#123;map &#125;&lt;/body&gt;&lt;/html&gt; c:remove——删除域中的属性1234567891011121314151617181920212223242526272829&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:remove 删除指定域中的指定属性 --------------- &lt;br/&gt; &lt;c:set var=\"name\" value=\"page_name\"/&gt; &lt;c:set var=\"name\" value=\"req_name\" scope=\"request\"/&gt; &lt;c:set var=\"name\" value=\"ses_name\" scope=\"session\"/&gt; &lt;c:set var=\"name\" value=\"app_name\" scope=\"application\"/&gt; &lt;c:remove var=\"name\" scope=\"session\"/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:remove 删除所有域中的指定属性 --------------- &lt;br/&gt; &lt;c:remove var=\"name\" /&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; c:out1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"test1\" value=\"&lt;h2&gt;hello,java!&lt;/h2&gt;\"/&gt; &lt;!-- value中EL的变量未定义时，默认输出default的值 --&gt; &lt;!-- value会原样输出其值，若该值带有html标签，可用escapeXml对该值进行解析 --&gt; &lt;c:out value=\"$&#123;test1 &#125;\" default=\"Hello,jsp!\" escapeXml=\"false\"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value=\"$&#123;test2 &#125;\" default=\"Hello,jsp!\"&gt;&lt;/c:out&gt;&lt;/body&gt;&lt;/html&gt; c:catch——捕获异常对象1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:catch var=\"math\"&gt; &lt;% int i = 7 / 0; %&gt; &lt;/c:catch&gt; $&#123;math.message &#125;&lt;/body&gt;&lt;/html&gt; c:if（掌握）——条件判断1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"name\" value=\"熊大\"/&gt; &lt;c:if test=\"$&#123;name=='熊大' &#125;\"&gt; &lt;href a=\"#\"&gt;我是熊大&lt;/href&gt; &lt;/c:if&gt; &lt;/body&gt;&lt;/html&gt; c:choose（掌握）——条件判断123456789101112131415161718192021222324252627282930313233&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"pageno\" value=\"2\"/&gt;&lt;c:set var=\"totalpage\" value=\"3\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;totalpage == 1 &#125;\"&gt; 首页 上一页 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == 1 &#125;\"&gt; 首页 上一页 &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == totalpage &#125;\"&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach（掌握）——遍历&lt;c:forEach items=”${names }” var=”name” begin=”0” end=”9” step=”2”varStatus=”status” &gt; begin、end、step分别表示：起始序号，结束序号，跳跃步伐 varStatus属性定义了一个status名的对象作为varStatus的绑定值，该绑定值也就是status封装了当前遍历的状态。可以方便我们实现一些与行数相关的功能，如：奇数行、偶数行差异；最后一行特殊处理等等。先就varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=\"text/css\"&gt; .odd&#123; background-color: #F8E2D3; &#125; .even&#123; background-color: #D3EE66; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;------------ c:forEach 例1 ------------&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"喜羊羊\"); names.add(\"美羊羊\"); names.add(\"懒羊羊\"); names.add(\"沸羊羊\"); names.add(\"暖羊羊\"); names.add(\"慢羊羊\"); names.add(\"灰太狼\"); names.add(\"红太狼\"); names.add(\"小灰灰\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name，step步长 --&gt; &lt;c:forEach items=\"$&#123;names &#125;\" var=\"name\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/c:forEach&gt;------------ c:forEach 例2 ------------&lt;br/&gt; &lt;c:forEach var=\"num\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;num &#125; &lt;/c:forEach&gt; &lt;br/&gt; ------------ c:forEach 例3 ------------&lt;br/&gt;&lt;% List&lt;Information&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Information(\"张三\",\"男\")); persons.add(new Information(\"李四\",\"不详\")); persons.add(new Information(\"王五\",\"男\")); persons.add(new Information(\"赵六\",\"女\")); persons.add(new Information(\"田七\",\"女\")); persons.add(new Information(\"王八\",\"男\")); pageContext.setAttribute(\"persons\", persons); %&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;persons &#125;\" var=\"person\" varStatus=\"vs\"&gt; &lt;tr class=\"$&#123;vs.count % 2==0 ? 'even':'odd'&#125;\"&gt; &lt;td&gt;$&#123;vs.count &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.uname &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.gender &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2 格式化标签库fmt:formatDate——日期格式fmt:parseDatefmt:formatNumberfmt:parseNumber12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;---------- 格式化日期 ----------&lt;br/&gt; &lt;% Date now = new Date(); pageContext.setAttribute(\"now\", now); %&gt; now = $&#123;now &#125;&lt;br/&gt; now = &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\"/&gt;&lt;br/&gt; &lt;!-- 将结果保留在var属性中 --&gt; &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\" var=\"time\"/&gt; birthday = $&#123;time &#125;&lt;br/&gt;----------将字符串转换为日期 ----------&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\"/&gt;&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\" var=\"day\"/&gt; ay = $&#123;day &#125; &lt;br/&gt;---------- 格式化数字 ----------&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" groupingUsed=\"false\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxIntegerDigits=\"8\" minIntegerDigits=\"6\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxFractionDigits=\"6\" minFractionDigits=\"5\"/&gt;&lt;br/&gt; &lt;br/&gt;----------将字符串转换为数字 ----------&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\"/&gt;&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\" var=\"num\"/&gt; num + 1 = $&#123;num + 1&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——自定义标签","slug":"JSP——自定义标签","date":"2019-08-28T11:59:55.000Z","updated":"2019-08-30T08:49:28.154Z","comments":true,"path":"2019/08/28/JSP——自定义标签/","link":"","permalink":"https://cometorbityh.github.io/2019/08/28/JSP——自定义标签/","excerpt":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。","text":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。 自定义标签的步骤： 定义标签处理器——定义一个类，继承SimpleTagSupport类，重写doTag( )方法 注册标签库，注册标签 导入标签库，使用标签 下面举2个案例来说明自定义标签。 2 定义带标签体的自定义标签（使用无标签体的标签完成：输出客户端IP） （使用有标签体的标签完成：小写转大写） 2-1 定义标签处理器 一个标签对应着一个类的一段代码。 一个类要实现自定义标签的功能，需要该类实现一个接口：Javax.servlet.jsp.tagext.SimpleTag，该接口有5个需要实现的方法，此时该类被称为标签处理器类。 ​ 123456789101112131415161718192021222324252627package com.orbit.tag;import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：获取客户端IPpublic class ClientIPTag extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //获取PageContext对象 PageContext pc = (PageContext) this.getJspContext(); //获取请求对象 ServletRequest request = pc.getRequest(); //获取客户端IP String ClientIp = request.getRemoteAddr(); //获取标准输出流 JspWriter out = pc.getOut(); //将客户端IP写入到输出流中 out.print(ClientIp); &#125;&#125; 12345678910111213141516171819202122232425262728package com.orbit.tag;import java.io.IOException;import java.io.StringWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：小写转大写public class LowerToUpper extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //创建一个输出流，该流中的内容可以通过其toString()方法获取到文本形式 StringWriter sw = new StringWriter(); //获取标签体对象 JspFragment jspBody = this.getJspBody(); //将标签体内容写入到输出流中 jspBody.invoke(sw); //以文本形式获取到输出流中的内容 String content = sw.toString(); //小写变大写 content = content.toUpperCase(); //将文本写入到标准输出流并打印 this.getJspContext().getOut().print(content);; &#125;&#125; 2-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;!-- 注册标签 --&gt; &lt;tag&gt; &lt;name&gt;clientIP&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ClientIPTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;tag&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.LowerToUpper&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- empty:当前标签没有标签体 scriptless:当前标签有标签体，但该标签中不能出现Java脚本，可以出现EL表达式 jsp:(已过时)，当前标签具有标签体，标签体内容原样显示到浏览器 tagdependent:当前标签有标签体，标签体内容原样显示到浏览器，即使是EL也一样 --&gt;&lt;/taglib&gt; 2-3 导入标签库，使用标签123456789101112131415161718192021222324252627&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用Java代码块获取IP --&gt; &lt;% String ip = request.getRemoteAddr(); out.println(\"ip = \" + ip); %&gt;&lt;br/&gt; &lt;!-- 使用无标签体的自定义标签获取IP --&gt; ip = &lt;tag:clientIP/&gt;&lt;br/&gt; &lt;!-- 使用有标签体的自定义标签完成小写转大写 --&gt; &lt;% String s = \"abc\"; pageContext.setAttribute(\"s\", s); %&gt; &lt;tag:LowerToUpper&gt;$&#123;s&#125;&lt;/tag:LowerToUpper&gt;&lt;br/&gt; &lt;tag:LowerToUpper&gt;are you kidding me?&lt;/tag:LowerToUpper&gt; &lt;/body&gt;&lt;/html&gt; 2-4 输出结果 3 定义带属性的自定义标签3-1 定义标签处理器1234567891011121314151617181920212223242526272829package com.orbit.tag;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;public class IfTag extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; if(test) &#123;// //获取标签体对象// JspFragment jspBody = this.getJspBody();// //将标签体加入到输出流// jspBody.invoke(this.getJspContext().getOut()); //invoke(null)等价于invoke(this.getJspContext().getOut()) this.getJspBody().invoke(null); &#125; &#125;&#125; 3-2 定义标签库，注册标签12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.IfTag&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 标签的属性 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性名 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true表示调用该标签时，必须要写该属性 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- runtime expression value运行时表达式值，true表示该属性的值支持EL与JSP表达式 --&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 3-3 导入标签库，使用标签123456789101112131415161718192021&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用带属性的自定义标签 --&gt; &lt;% boolean gender = true; pageContext.setAttribute(\"gender\", gender); %&gt; &lt;tag:if test=\"$&#123;gender &#125;\"&gt;男&lt;/tag:if&gt; &lt;tag:if test=\"$&#123;not gender &#125;\"&gt;女&lt;/tag:if&gt; &lt;/body&gt;&lt;/html&gt; #### 3-4 输出结果 4 自定义遍历List集合的forEachList标签4-1 定义标签处理器123456789101112131415161718192021222324252627282930package com.orbit.tag;import java.io.IOException;import java.util.List;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachListTag extends SimpleTagSupport&#123; private List items; private String var; //var代表当前对象要放入域中的属性名 public void setItems(List items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; for (Object obj : items) &#123; //EL只能处理四大域中的数据，因此将该遍历对象放入到四大域中 //key为var指定的名称（name）,value为当前遍历对象obj this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 4-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEachList&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachListTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 4-3 导入标签库，使用标签12345678910111213141516171819202122232425&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自定义标签 --&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEachList items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEachList&gt; &lt;/body&gt;&lt;/html&gt; 4-4 输出结果 5 自定义遍历集合和数组的forEach标签5-1 定义标签处理器(方法一) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.orbit.tag;import java.io.IOException;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; //判断items的类型 if(items instanceof List) &#123; List itemsList = (List) items; for (Object obj : itemsList) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Set) &#123; Set itemsSet = (Set) items; for (Object obj : itemsSet) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Map) &#123; Map itemsMap = (Map) items; for (Object obj : itemsMap.entrySet()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Object[]) &#123; Object[] itemsObject = (Object[]) items; for (Object obj : itemsObject) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125; &#125;&#125; （方法二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.tag;import java.io.IOException;import java.lang.reflect.Array;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var;// private Collection coll; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; public Collection getColl() &#123; if(items instanceof List) &#123; return (List) items; &#125;else if(items instanceof Set) &#123; return (Set) items; &#125;else if(items instanceof Map) &#123; return ((Map) items).entrySet(); &#125; /*该方法只能遍历非基本数据类型的数组*/// else if(items instanceof Object[]) &#123;// //将items强转为数组，数组再转为List集合（因为返回值是集合类型）// return Arrays.asList((Object[])items);// &#125; /*该方法能遍历任何数组*/ else if(items.getClass().isArray()) &#123; List nums = new ArrayList(); for(int i =0;i&lt;Array.getLength(items);i++) &#123; nums.add(Array.get(items, i)); &#125; return nums; &#125; return null; &#125; @Override public void doTag() throws JspException, IOException &#123; //遍历getColl()的返回值 for (Object obj : getColl()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 5-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEach&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 5-3 导入标签库，使用标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ===========遍历List===========&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEach items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Set===========&lt;br/&gt; &lt;% Set&lt;String&gt; cities = new HashSet&lt;&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"广州\"); pageContext.setAttribute(\"cities\", cities); %&gt; &lt;tag:forEach items=\"$&#123;cities &#125;\" var=\"city\"&gt; $&#123;city &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Map===========&lt;br/&gt; &lt;% Map&lt;String,Object&gt; infos = new HashMap&lt;&gt;(); infos.put(\"name\", \"张三\"); infos.put(\"age\", 24); infos.put(\"gender\", \"男\"); pageContext.setAttribute(\"infos\", infos); %&gt; &lt;tag:forEach items=\"$&#123;infos &#125;\" var=\"info\"&gt; $&#123;info &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型的数组===========&lt;br/&gt; &lt;% Object[] objs = &#123;\"元素1\",\"元素2\",\"元素3\"&#125;; pageContext.setAttribute(\"objs\", objs); %&gt; &lt;tag:forEach items=\"$&#123;objs &#125;\" var=\"obj\"&gt; $&#123;obj &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型及数据类型的数组===========&lt;br/&gt; &lt;% int[] ages = &#123;11,12,13&#125;; pageContext.setAttribute(\"ages\", ages); %&gt; &lt;tag:forEach items=\"$&#123;ages &#125;\" var=\"age\"&gt; $&#123;age &#125; &lt;br/&gt;&lt;/tag:forEach&gt; &lt;/body&gt;&lt;/html&gt; 5-4 输出结果 6 将自定义标签库打包发行右击项目名——Export——搜索JARfile——勾选需要打包的包名，其他的取消勾选，选择保存位置，命名为xxx.jar——将对应的tld文件复制到xxx.jar中的META-INF文件夹中——需要时导入即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"Next主题格式配置记录","slug":"Next主题格式配置记录","date":"2019-08-27T15:23:14.000Z","updated":"2019-08-27T15:48:58.046Z","comments":true,"path":"2019/08/27/Next主题格式配置记录/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/Next主题格式配置记录/","excerpt":"文章背景色","text":"文章背景色","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://cometorbityh.github.io/tags/next/"}]},{"title":"使用PicGo + 七牛云 快速创建图床","slug":"使用PicGo-七牛云-快速创建图床","date":"2019-08-27T12:04:12.000Z","updated":"2019-08-27T15:25:44.190Z","comments":true,"path":"2019/08/27/使用PicGo-七牛云-快速创建图床/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/使用PicGo-七牛云-快速创建图床/","excerpt":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。","text":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。 注册七牛云账号（https://www.qiniu.com/），并完成实名认证。 创建存储空间 下载并安装PicGo（https://github.com/Molunerfinn/PicGo/releases） 七牛图床设置 上传图片","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"JSP——EL表达式","slug":"JSP——EL表达式","date":"2019-08-26T06:14:53.000Z","updated":"2019-08-31T07:19:51.261Z","comments":true,"path":"2019/08/26/JSP——EL表达式/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/JSP——EL表达式/","excerpt":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值","text":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值 使用EL获取数据 从四大域中获取数据EL只能获取到四大域中的数据，因此要获取到某个数据，需要将其加入到某个域中，再使用EL表达式获取数据。 从四大域中依次查找数据 ${属性}EL01.jsp 12345678910&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;name&#125; &lt;/body&gt; 输出结果为page域的属性值（最小的域） 从指定域中获取数据 ${域scope.属性}依次从四大域查找属性效率过低，为了提高效率，我们应该想想如何从指定域中直接获取某个属性值。 EL有4个域属性空间相关的内置对象，分别为pageScope，requestScope，sessionScope，applicationScope。表示从对应域属性空间中查找指定key。 1234567891011121314&lt;!-- EL01.jsp --&gt;&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;pageScope.name&#125;&lt;br/&gt; name = $&#123;requestScope.name&#125;&lt;br/&gt; name = $&#123;sessionScope.name&#125;&lt;br/&gt; name = $&#123;applicationScope.name&#125;&lt;br/&gt;&lt;/body&gt; 获取Bean的属性 ${key.属性}创建一个Bean的对象，将这个Bean对象加入到域属性空间中，通过 ${key.属性} 可以访问该对象的属性值。 注意：若访问对象为null，则EL也不会报空指针异常，显示结果为”” 12345678910111213141516171819202122232425262728293031/* School.java */package com.orbit.el;public class School &#123; private String scname; private String scaddress; public School(String scname, String scaddress) &#123; super(); this.scname = scname; this.scaddress = scaddress; &#125; public String getScname() &#123; return scname; &#125; public void setScname(String scname) &#123; this.scname = scname; &#125; public String getScaddress() &#123; return scaddress; &#125; public void setScaddress(String scaddress) &#123; this.scaddress = scaddress; &#125; @Override public String toString() &#123; return \"School [scname=\" + scname + \", scaddress=\" + scaddress + \"]\"; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/* Student.java */package com.orbit.el;public class Student &#123; private String sname; private int sno; private School school; public Student(String sname, int sno, School school) &#123; super(); this.sname = sname; this.sno = sno; this.school = school; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSno() &#123; return sno; &#125; public void setSno(int sno) &#123; this.sno = sno; &#125; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return \"Student [sname=\" + sname + \", sno=\" + sno + \", school=\" + school + \"]\"; &#125; &#125; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School school = new School(\"清华大学\",\"北京\"); Student student = new Student(\"杨小杨\",10001,school); pageContext.setAttribute(\"student\", student); %&gt; &lt;!-- 若访问对象为null，则EL也不会报空指针异常，显示结果为\" \" --&gt;&gt; student = $&#123;student1&#125; student = $&#123;student&#125;&lt;br/&gt; student.sname = $&#123;student.sname&#125;&lt;br/&gt; student.sname = $&#123;student['sname']&#125;&lt;br/&gt; student.sno = $&#123;student.sno&#125;&lt;br/&gt; student.sno = $&#123;student['sno']&#125;&lt;br/&gt; student.school = $&#123;student.school&#125;&lt;br/&gt; student.school.scname = $&#123;student.school.scname&#125;&lt;br/&gt; student.school.scaddress = $&#123;student.school.scaddress&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 获取数组 ${array[i]}创建一个数组，将这个数组加入到域属性空间，通过 ${array[i]} 可以访问该数组的第 i+1个元素。 1234567891011121314151617181920212223&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School[] schools = new School[3]; schools[0] = new School(\"清华大学\",\"中国北京\"); schools[1] = new School(\"北京大学\",\"中国北京\"); schools[2] = new School(\"厦门大学\",\"中国福建\"); pageContext.setAttribute(\"schools\", schools); %&gt; school[2] = $&#123;schools[0]&#125;&lt;br/&gt; school[2].address = $&#123;schools[2].scaddress&#125;&lt;br/&gt; &lt;!-- 数组下标超出上限，EL不会报越界异常 --&gt; school[3] = $&#123;schools[3]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ​ ​ 获取List中的元素 ${list[i]}访问list与访问数组的方式一致。 注意：set是无序的，其中的元素没有索引，因此无法用该种方式访问。 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; names[1] = $&#123;names[1]&#125;&lt;br/&gt; names[10] = $&#123;names[10]&#125;&lt;/body&gt;&lt;/html&gt; 获取Map中的元素 ${map.元素}123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"school\", new School(\"厦门大学\",\"中国福建\")); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- map.school是Object类型的，map.school.scname是默认Object型强转为School型 --&gt; $&#123;map.school.scname &#125;&lt;br/&gt; $&#123;map.name &#125;&lt;/body&gt;&lt;/html&gt; ​ EL常见运算符 序号 类别 运算符 1 算术运算符 + - * / % 2 关系运算符 &gt; &lt; == &gt;= &lt;= != 3 逻辑运算符 &amp;&amp;(and) ||(or) !(not) 4 条件运算符 ？ ： 5 取值运算符 . [ ] 6 empty运算符 empty empty的用法 empty判空，四大域中的元素符合以下条件时empty的运算结果为true： 没有定义的属性 值为null的引用 值为空串的String引用 没有元素的数组或集合 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String b = null; String c = \"\"; List&lt;String&gt; d = new ArrayList&lt;&gt;(); pageContext.setAttribute(\"b\", b); pageContext.setAttribute(\"c\", c); pageContext.setAttribute(\"d\", d); %&gt; empty a = $&#123;empty a&#125;&lt;br/&gt; empty b = $&#123;empty b&#125;&lt;br/&gt; empty c = $&#123;empty c&#125;&lt;br/&gt; empty d = $&#123;empty d&#125;&lt;/body&gt;&lt;/html&gt; EL内置对象 EL有11个内置对象，除了前面的和4个域属性空间相关的内置对象之外，还有7个。 EL的内置对象中，除了pageContext之外，其他内置对象的类型均为java.util.Map类型。 此处介绍常用的四个内置对象： pageContext 是不是有点熟悉？没错，EL的pageContext和JSP的pageContext是同一个对象。 可以获取到JSP的request、response、session、servletContext、servletConfig等对象 注意获取到的这些内置对象是JSP的，不是EL的，EL中没有这些内置对象。 如何在EL中使用pageContext获取到JSP的内置对象？ 例如，获取request内置对象——${pageContext.request} 其底层实际调用的方法为 pageContext.getRequest()，其他内置对象同理 常用内置对象的方法？ ${pageContext.request.contextPath()}，用来获取当前项目路径，一般用在JSP页面的路径中。 1234567&gt; &lt;body&gt;&gt; &lt;!-- 可读性差 --&gt;&gt; &lt;form action=\"register\"&gt;&lt;/form&gt; &gt; &lt;!-- 可读性好 --&gt;&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/register\"&gt;&lt;/form&gt;&gt; &lt;/body&gt;&gt; param ${param.parameter}`获取request域（请求）中的指定参数的值。 底层调用的是：request.getparameter() paramValues ${paramValues.parameter[i]}` :获取request域（请求）中指定参数的所有值。 底层调用的是：request.getparameterValues() initParam 获取初始化参数 底层调用的是servletContext.getInitParameter() 1234567891011121314151617181920212223&lt;!-- index.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/show.jsp\" &gt; 姓名：&lt;input type=\"text\" name=\"uname\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"uage\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"uhobby\" value=\"sing\"/&gt;唱 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"dancing\"/&gt;跳 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"rap\"/&gt;RAP &lt;input type=\"checkbox\" name=\"uhobby\" value=\"basketball\"/&gt;篮球&lt;br/&gt; &lt;input type=\"submit\"value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!-- show.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;param.uname&#125;&lt;br/&gt; 年龄：$&#123;param.uage&#125;&lt;br/&gt; 爱好：$&#123;paramValues.uhobby[0]&#125; &amp;nbsp; $&#123;paramValues.uhobby[1]&#125;&amp;nbsp; $&#123;paramValues.uhobby[2]&#125;&amp;nbsp; $&#123;paramValues.uhobby[3]&#125;&lt;br/&gt; 学校：$&#123;initParam.school&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;display-name&gt;02-EL&lt;/display-name&gt;&lt;context-param&gt; &lt;param-name&gt;school&lt;/param-name&gt; &lt;param-value&gt;清华大学&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; EL自定义函数 EL函数只能处理四大域中的属性值及常量 步骤：定义函数——定义标签库——注册函数——使用函数 12345678910//ELFunctions.javapackage com.orbit.el;public class ELFunctions &#123; //小写转大写 public static String LowertoUpper(String source) &#123; return source.toUpperCase(); &#125;&#125; 12345678910111213141516171819&lt;!-- myFt.tld --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 定义标签库信息 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myFt&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/el/functions&lt;/uri&gt; &lt;!-- 注册函数 --&gt; &lt;function&gt; &lt;name&gt;IsLowertoUpper&lt;/name&gt; &lt;function-class&gt;com.orbit.el.ELFunctions&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String LowertoUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 12345678910111213141516171819202122&lt;!-- index.jsp --&gt;&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/el/functions\" prefix=\"myFt\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用函数：处理常量 --&gt; $&#123;myFt:IsLowertoUpper(\"no one can stop me!\") &#125; &lt;!-- 使用函数：处理四大域中的属性 --&gt; &lt;% String name=\"Selena\"; pageContext.setAttribute(\"name\", name); %&gt; $&#123;myFt:IsLowertoUpper(name) &#125;&lt;/body&gt;&lt;/html&gt; JSTL中的EL函数​ JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache定义好的一套标准的标签库规范。 ​ JSTL中，定义了一套关于字符串处理的函数标签库，这个函数标签库中包含16个处理字符串的函数。 ​ 在JSP页面中导入jstl.jar ，standard.jar，就可以直接使用。 ​ 导入jar包 jstl.jar下载地址： http://repo2.maven.org/maven2/javax/servlet/jstl/ standard.jar下载地址： http://repo2.maven.org/maven2/taglibs/standard/ ​ 查看目录 ​ 使用函数 1234567891011121314&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:substring(\"abcdefg\",2,5) &#125; $&#123;fn:substringBefore(\"abcdefg\",\"cd\") &#125; $&#123;fn:substringAfter(\"abcdefg\",\"cd\"\") &#125;&lt;/body&gt;&lt;/html&gt; 对于EL做出的总结 EL不能出现在Java代码块、表达式块等JSP的动态代码部分 EL只能从四大域属性空间中获取数据（pageContext,request,session,application） EL不会抛出空指针异常，若访问一个null对象的属性，则什么也不显示 EL不会抛出数组访问越界异常，若访问一个数组中不存在的元素，则什么也不显示 EL本身无法对字符串进行处理，要想进行处理，可以通过EL自定义函数和JSTL中的EL函数来处理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"解决hexo显示不出本地图片问题","slug":"解决hexo显示不出本地图片问题","date":"2019-08-26T05:45:45.000Z","updated":"2019-08-27T15:26:08.966Z","comments":true,"path":"2019/08/26/解决hexo显示不出本地图片问题/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/解决hexo显示不出本地图片问题/","excerpt":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。","text":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹 1hexo new &quot;博客名&quot; 将想要上传的图片先保存在文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 使用hexo g部署，进入public\\2019\\08\\26\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2019/08/26/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"Servlet","slug":"Servlet","date":"2019-08-24T11:40:33.000Z","updated":"2019-08-26T09:26:49.702Z","comments":true,"path":"2019/08/24/Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/08/24/Servlet/","excerpt":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层","text":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层 2. Servlet的作用：用来接收客户端的请求数据，然后调用底层service处理数据并生成结果，返回一个响应给浏览器。 利用他可以实现业务层和表现层的分离，同时又可以生成动态页面。 3 . Servlet执行业务的步骤浏览器http请求——》tomcat服务器——-》到达servlet—–》执行doget，dopost方法—-》返回数据&lt;1&gt;客户端发送请求到服务器端&lt;2&gt;服务器将请求信息发送至Servlet&lt;3&gt;Servlet生成响应内容并将其传给服务器。&lt;4&gt;服务器将响应返回给客户端。 4. 创建Servlet的三种方式 定义一个类实现javax.servlet.Servlet接口 定义一个类继承javax.servet.GenericServlet类 定义一个类继承javax.servlet.http.HttpServlet类 web应用我们自然基本上都是继承HttpServlet 5. Servlet的生命周期（Servlet实例对象从创建到销毁的整个过程）​ Servlet的生命周期由一套定义良好的生命周期规则来约束管理 ​ 其中定义了Servlet如何被加载实例化和初始化,处理客户端请求,以及何时结束服务 ​ 生命周期方法有: ​ void init(ServletConfig)； ​ void service(ServletRequest,ServletResponse)； ​ void destroy()；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://cometorbityh.github.io/tags/Servlet/"}]}]}