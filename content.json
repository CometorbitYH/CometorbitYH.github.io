{"meta":{"title":"MY","subtitle":"IT IS MY LIFE","description":"每一天都在进步...","author":"杨涵","url":"https://cometorbityh.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-24T06:54:16.000Z","updated":"2019-08-24T08:45:36.335Z","comments":true,"path":"categories/index.html","permalink":"https://cometorbityh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-24T06:54:02.000Z","updated":"2019-08-24T08:47:48.572Z","comments":true,"path":"tags/index.html","permalink":"https://cometorbityh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA——集合","slug":"JAVA——集合","date":"2019-10-16T11:22:04.000Z","updated":"2019-10-16T16:00:15.408Z","comments":true,"path":"2019/10/16/JAVA——集合/","link":"","permalink":"https://cometorbityh.github.io/2019/10/16/JAVA——集合/","excerpt":"","text":"1.CollectionCollection的常用方法 操作对象 方法 描述 单个容器 boolean add(Object element) 增加元素到容器中 boolean remove(Object element) 从容器中移除元素 boolean contains(Object element) 容器中是否包含该元素 int size() 容器中元素的数量 boolean isEmpty() 容器中是否为空 void clear() 清空容器中所有元素 迭代器 多个容器 boolean addAll(Collection c) 将容器C的所有元素添加到本容器中 boolean removeAll(Collection c) 移除本容器和C容器中都包含的元素 boolean containsAll(Collection c) 本容器中是否包含c容器中的所有元素 boolean retainAll(Collection c) 留下本容器和容器C都包含的元素，移除本容器和C容器中非交集的元素 Object[] toArray() 转化为Object数组 123456789101112131415161718192021222324252627package com.orbit.demo;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add(\"张三\"); c.add(\"李四\"); System.out.println(c.toString()); System.out.println(\"当前容器是否为空 ==&gt; \"+c.isEmpty()); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); System.out.println(\"当前容器是否包含李四 ==&gt; \"+c.contains(\"李四\")); System.out.println(\"转为Object数组 ==&gt; \"+c.toArray().toString()); System.out.println(\"移除李四\"); c.remove(\"李四\"); System.out.println(c.toString()); System.out.println(\"清空\"); c.clear(); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"aa\"); list01.add(\"bb\"); list01.add(\"cc\"); List&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"aa\"); list02.add(\"dd\"); list02.add(\"ee\"); System.out.println(list01); System.out.println(list02); list01.addAll(list02); //list02添加到list01（可重复） System.out.println(list01); System.out.println(list01.containsAll(list02)); //list01是否包含list02 list01.removeAll(list02); //删除交集元素 System.out.println(list01); list01.retainAll(list02); //删除非交集元素 System.out.println(list01); &#125; &#125; 2.List接口List是有序的、可重复的容器。 有序：每个元素都有索引，可通过索引访问元素 可重复：允许加入重复元素 List接口常用的实现类有3个：ArrayList，LinkedList，Vector 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aa\"); list.add(\"bb\"); list.add(\"cc\"); list.add(\"dd\"); //在最后增加元素 System.out.println(list); list.add(2, \"AA\"); //在索引处插入元素 System.out.println(list); list.remove(2); //移除指定索引的元素 System.out.println(list); list.set(2, \"aa\"); //覆盖指定索引的元素 System.out.println(list); System.out.println(list.get(2)); //获取指定索引的元素 System.out.println(list.indexOf(\"aa\")); //获取该元素第一次出现的索引位置。不存在则返回-1 System.out.println(list.indexOf(\"bc\")); System.out.println(list.lastIndexOf(\"aa\")); //获取该元素最后一次出现的索引位置。不存在则返回-1 &#125; &#125; 2.1 ArrayList（常用）ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。 数组长度有限，但ArrayList长度不限，可存放任意数量的对象。它是如何实现的？ 扩容。数组的默认长度为10，当长度满时，创建一个新的长度为原来的1.5倍（原长度+原长度右移1位）长度的数组，再将旧数组的元素复制到新数组中。 2.2 LinkedListLinkedList底层时采用双向链表实现的存储 特点：查询效率低，增删效率高，线程不安全 双向链表：每个数据节点（node）都有2个指针，分别指向前一个节点和后一个节点。 上节点地址 || 元素数据 || 下节点地址 2.3 VectorVector底层是采用数组实现的List，相关方法都增加了同步检查（synchronized） 特点：效率低（同步检查耗费时间），线程安全 3. Map接口显示生活中，常需要成对存储某些信息，比如一个手机号对应一个微信号，这就是成对存储关系， 在Java中，这对数据称为键值对（key-value），Map就是用来存储键值对的，通过键来获取值，因此键对象是唯一的不可重复。 Map接口的实现类：HashMap，TreeMap，HashTable，Properties 操作对象 方法 描述 单个Map Object put(Object key,Object value) 存放键值对 Object get(Object key) 通过键对象查找得到值对象 Object remove(Object key) 删除键对象对应的值对象 boolean containsKey(Object key) Map容器中是否包含键对象对应的键值对 boolean containsValue(Object value) Map容器中是否包含值对象对应的键值对 int size() 键值对的数量 boolean isEmpty() 判断Map是否为空 void clear() 清空所有键值对 多个Map void putAll(Map m) 将m容器中的所有键值对存放到本map对象","categories":[],"tags":[]},{"title":"SSM整合实例_05_删除人员","slug":"SSM整合实例-05-删除人员","date":"2019-10-10T08:46:39.000Z","updated":"2019-10-10T08:47:01.723Z","comments":true,"path":"2019/10/10/SSM整合实例-05-删除人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-05-删除人员/","excerpt":"","text":"","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_04_修改人员","slug":"SSM整合实例-04-修改人员","date":"2019-10-10T08:46:28.000Z","updated":"2019-10-10T12:38:18.452Z","comments":true,"path":"2019/10/10/SSM整合实例-04-修改人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-04-修改人员/","excerpt":"","text":"修改操作1.点击编辑，弹出修改的模态框，并显示用户信息 2.点击更新，完成用户修改 删除操作单个：url:/emp/{id} DELETE","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_03_增加人员","slug":"SSM整合实例-03-增加人员","date":"2019-10-08T14:14:41.000Z","updated":"2019-10-10T08:45:16.614Z","comments":true,"path":"2019/10/08/SSM整合实例-03-增加人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例-03-增加人员/","excerpt":"","text":"新增操作 需求： 思路： 点击“新增”按钮时弹出对话框，该对话框的功能为增加人员，需要获取到部门的数据到下拉框中 为“新增”绑定点击事件，包括： 1. 先清除表单数据 2. 调用获取部门数据的方法： 获取部门数据：发送ajax请求到处理器相应方法，收到返回结果，该返回结果是去数据库查询的部门列表 部门数据放到下拉框中：在ajax中，将success的result进行遍历，并拼接到标签中 3. 弹出模态框：利用bootstrap的$(id).modal({backdrop:&quot;static&quot;}); 对用户名进行ajax“重复”检验 为用户名输入框的change绑定事件：获取到输入框的值；发送ajax请求（发送用户名数据）到处理器校验用户名是否可用，得到返回值，返回值是一个状态码；判断该状态码：状态码为可用状态时，调用显示校验提示的方法，并给保存按钮添加一个自定义属性，属性值为success（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)）状态码为不可用状态时，调用显示校验提示的方法，显示提示信息，并给保存按钮添加一个自定义属性，属性值为error（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)），点击无效 点击“保存”按钮：对要提交给服务器的数据进行校验此时自动调转到包含该员工数据的那一页 为提示框的添加按钮绑定点击事件，包括： 1. 调用数据校验的方法。若该方法返回值为false,return false;该方法具体如下: 获取对应文本框中输入的值（var value=$(&quot;#文本框id&quot;).val()）； 定义一个正则表达式（var regValue=xxxxx）； 使用正则表达式对该值进行校验（regValue.test(value)），判断该语句的值； 是false则调用显示校验提示的方法并return false； 是true继续校验下一个； 以此类推，全部检验完毕，return true 1-1. 调用显示校验提示的方法： 先在每一个文本框下添加一个span标签，用来输出提示信息 清空当前元素的校验状态 判断输入框的格式 如果输入框格式有误，就在输入框的父标签（div）的class添加has error字段（bootstrap语法，该语法使文本框变红），在输入框的下一个标签（span）添加文本，文本为错误提示信息。 如果输入框格式正确，就在输入框的父标签（div）的class添加has success字段（bootstrap语法，该语法使文本框变绿） 该方法有相同之处，可抽取3个参数（输入框id，输入框格式状态，提示信息），不再详细说明。 2. 判断添加按钮的自定义属性（在上一个需求）是否为error，若是则return false; 3. 保存新增的员工数据：页面发送ajax请求（将表单数据序列化）到处理器的新增人员的方法，完成数据库数据的添加 4. 跳转到新员工的页面：调用to_page();，定义一个变量，赋值为总记录数，to_page(变量)即可跳转 重要数据，对用户进行后端校验（JSR303），唯一约束 1. 导入jar包：hibernate-validator（JSR303数据校验支持）2. 在处理器的保存人员方法中添加检验，并返回一个参数给请求页面的ajax解析","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_02_主页设计","slug":"SSM整合实例_02_主页设计","date":"2019-10-08T14:08:54.000Z","updated":"2019-10-08T14:15:36.119Z","comments":true,"path":"2019/10/08/SSM整合实例_02_主页设计/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例_02_主页设计/","excerpt":"","text":"查询操作需求：获取数据库的数据到主页。 1，查询步骤（model方法） 访问index.jsp index.jsp页面发出查询人员列表的请求 对应处理器（EmployeeController.java）接收请求，查询人员数据 响应数据到index.jsp页面 123456789101112//查询所有员工（分页查询）@RequestMapping(\"/emps\")public String getEmps(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model)&#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn,5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps,5); model.addAttribute(\"pageInfo\",page); return \"list\";&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;%--取出pageInfo属性中的list，将每一个list都命名为emp--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.list&#125;\" var=\"emp\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;emp.empId&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empName&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.gender=='M'?'男':'女'&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.email&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department.deptName&#125;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-primary btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt; 编辑 &lt;/button&gt; &lt;button class=\"btn btn-danger btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\"&gt; 当前$&#123;pageInfo.pageNum&#125;/$&#123;pageInfo.pages&#125;页，共$&#123;pageInfo.total&#125;条记录 &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;%--首页即第一页--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=1\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;%-- 点击上一页，当前页面减1 --%&gt; &lt;%--如有上一页，就显示上一页图标，否则不显示（因为第一页时点击上一页会显示-1，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasPreviousPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum-1&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--该分页条显示的页码，每一个页码都用pageNum表示，遍历出来--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.navigatepageNums&#125;\" var=\"page_Num\"&gt; &lt;%--当遍历出的这个页码和该显示页面的页码一致时,页码高亮--%&gt; &lt;c:if test=\"$&#123;page_Num == pageInfo.pageNum&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;%--当遍历出的这个页码和该显示页面的页码不一致时,页码不高亮，点击时可跳转至对应页面--%&gt; &lt;c:if test=\"$&#123;page_Num != pageInfo.pageNum&#125;\"&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;page_Num&#125;\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%-- 点击下一页，当前页面加1 --%&gt; &lt;%--如有下一页，就显示下一页图标，否则不显示（因为最后一页时点击下一页会显示不存在的页数，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasNextPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum+1&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--末页即总页码--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pages&#125;\"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2，查询步骤（ajax方法）（推荐） index.jsp页面发送ajax请求查询 服务器将查到的数据，以json字符串的形式返回给浏览器 浏览器收到js字符串，可使用js对json进行解析，使用js通过dom增删改来改变页面 返回json，实现客户端的无关性 给浏览器添加提示信息Msg,java EmployeeController.java 123456789101112131415161718192021222324252627282930313233343536373839package com.yanghan.crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.bean.Msg;import com.yanghan.crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; //查询所有员工（ajax分页查询） @RequestMapping(\"/emps\") @ResponseBody //可以将返回的pageInfo对象转为json字符串,需要导入Jackson包 public Msg getEmpsWithJson(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model) &#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn, 5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps, 5); return Msg.success().add(\"pageInfo\",page); &#125;&#125; index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\" id=\"emps_table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_info_area\"&gt; &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_nav_area\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //页面加载完成后，直接发送ajax请求，获取到分页数据 $(function () &#123; //第一次去首页 to_page(1); &#125;); $(function () &#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=1\", type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125;); //跳到指定页面 function to_page(pn)&#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=\"+pn, type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125; //解析显示表格数据 function build_emps_table(result) &#123; //先清空上一次的数据 $(\"#emps_table tbody\").empty(); //取出json字符串的分页数据 var emps = result.extend.pageInfo.list; //遍历分页数据，index是索引，item是某个属性的集合 $.each(emps,function(index,item)&#123; // alert(item.empName); //构建单元格(append用来追加元素) var empIdTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empId); var empNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empName); var genderTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.gender=='M'?\"男\":\"女\"); var emailTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.email); var deptNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.department.deptName); // &lt;button class=\"btn btn-primary btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt;编辑 // &lt;/button&gt; // &lt;button class=\"btn btn-danger btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt;删除 // &lt;/button&gt; var editBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-primary btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-pencil\").append(\"修改\"); var delBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-danger btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-trash\").append(\"删除\"); //将按钮放在一个单元格中 var btnTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(editBtn).append(\" \").append(delBtn); //构建行(将单元格拼接成行，appendTo表示将该行添加到id为emps_table的tbody标签中) $(\"&lt;tr&gt;&lt;/tr&gt;\").append(empIdTd).append(empNameTd) .append(genderTd).append(emailTd).append(deptNameTd) .append(btnTd).appendTo(\"#emps_table tbody\"); &#125;); &#125; //解析显示分页信息 function build_page_info(result) &#123; //先清空上一次的数据 $(\"#page_info_area\").empty(); $(\"#page_info_area\").append(\"当前\" + result.extend.pageInfo.pageNum + \"/\" + result.extend.pageInfo.pages + \"页，共\" + result.extend.pageInfo.total + \"页\"); &#125; //解析构建分页条信息，点击进行跳转下一页 function build_page_nav(result) &#123; //先清空上一次的数据 $(\"#page_nav_area\").empty(); var ul = $(\"&lt;ul&gt;&lt;/ul&gt;\").addClass(\"pagination\"); //构建元素 var firstPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"首页\").attr(\"href\",\"#\")); var prePageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;laquo;\")); if (result.extend.pageInfo.hasPreviousPage == false) &#123; firstPageLi.addClass(\"disabled\"); prePageLi.addClass(\"disabled\"); &#125;else &#123; //为元素添加翻页事件 firstPageLi.click(function () &#123; to_page(1); &#125;); prePageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum -1); &#125;); &#125; var nextPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;raquo;\")); var lastPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"末页\").attr(\"href\",\"#\")); if (result.extend.pageInfo.hasNextPage == false) &#123; nextPageLi.addClass(\"disabled\"); lastPageLi.addClass(\"disabled\"); &#125;else &#123; nextPageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum +1); &#125;); lastPageLi.click(function () &#123; to_page(result.extend.pageInfo.pages); &#125;); &#125; //页码1，2，3，4 ul.append(firstPageLi).append(prePageLi); $.each(result.extend.pageInfo.navigatepageNums,function (index, item) &#123; var numLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(item)); if (result.extend.pageInfo.pageNum == item) &#123; numLi.addClass(\"active\"); &#125; numLi.click(function () &#123; to_page(item); &#125;); ul.append(numLi); &#125;); ul.append(nextPageLi).append(lastPageLi); //把ul加入到nav var navEle = $(\"&lt;nav&gt;&lt;/nav&gt;\").append(ul); navEle.appendTo(\"#page_nav_area\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"JS语法基础2","slug":"JS语法基础2","date":"2019-10-08T07:15:05.000Z","updated":"2019-10-08T07:15:05.569Z","comments":true,"path":"2019/10/08/JS语法基础2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS语法基础","slug":"JS语法基础","date":"2019-10-08T07:14:58.000Z","updated":"2019-10-08T07:14:58.895Z","comments":true,"path":"2019/10/08/JS语法基础/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SSM整合实例_01_环境搭建","slug":"SSM整合实例_01_环境搭建","date":"2019-10-07T05:59:45.000Z","updated":"2019-10-08T14:19:02.021Z","comments":true,"path":"2019/10/07/SSM整合实例_01_环境搭建/","link":"","permalink":"https://cometorbityh.github.io/2019/10/07/SSM整合实例_01_环境搭建/","excerpt":"","text":"环境搭建1，创建maven工程2，引入jar包 spring相关jar包 springmvc相关jar包 mybatis相关jar包（逆向工程jar包） 数据库连接池，驱动包 其他（jstl，servlet-api，junit，pageHelper分页插件） 3，引入bootstrap前端框架+JS4，编写ssm整合的关键配置文件 web.xml applicationContext.xml springmvc.xml mybatis-config.xml 5，mybatis逆向工程 + 测试（1）mybatis逆向工程生成对应的bean以及mapper 在项目下新建mbg.xml，修改部分内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--mybatis逆向工程--&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!--不生成注释--&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息--&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javaBean生成的位置--&gt; &lt;javaModelGenerator targetPackage=\"com.yanghan.crud.bean\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 指定sql映射文件位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\".\\src\\main\\resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定dao接口生成的位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.yanghan.crud.dao\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定每个表的生成策略:javaBean的名字--&gt; &lt;!-- &lt;table schema=\"DB2ADMIN\" tableName=\"ALLTYPES\" domainObjectName=\"Customer\" &gt;--&gt; &lt;!-- &lt;property name=\"useActualColumnNames\" value=\"true\"/&gt;--&gt; &lt;!-- &lt;generatedKey column=\"ID\" sqlStatement=\"DB2\" identity=\"true\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"DATE_FIELD\" property=\"startDate\" /&gt;--&gt; &lt;!-- &lt;ignoreColumn column=\"FRED\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"LONG_VARCHAR_FIELD\" jdbcType=\"VARCHAR\" /&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;table tableName=\"tbl_emp\" domainObjectName=\"Employee\"/&gt; &lt;table tableName=\"tbl_dept\" domainObjectName=\"Department\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; com.xxx.crud.test包下新建MBGTest.java。 把以下内容复制进入。并修改File configFile = new File(&quot;mbg.xml&quot;); 执行该方法，即可自动生成。 123456789101112131415161718192021222324252627package com.yanghan.crud.test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;//逆向工程测试类public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; MapperTest.java测试是否连接成功数据库（可做增删改操作） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.yanghan.crud.test;import com.yanghan.crud.bean.Department;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.dao.DepartmentMapper;import com.yanghan.crud.dao.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;/** * 测试dao层工作 * Spring的项目可以使用Spring的单元测试，可以自动注入我们需要的组件 * 1、导入SpringTest模块 * 2、@ContextConfiguration指定spring配置文件的位置 * 3、直接autowired要使用的组件即可 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession sqlSession; /** * 测试DepartmentMapper */ @Test public void testCRUD() &#123; //1、插入/删除部门// departmentMapper.insertSelective(new Department(null,\"测试1\"));// departmentMapper.insertSelective(new Department(null,\"测试2\"));// departmentMapper.deleteByPrimaryKey(3); //2、生成员工数据，测试员工插入// employeeMapper.insertSelective(new Employee(null,\"Jerry\",\"M\",\"Jerry@qq.com\",1)); //3、批量插入多个员工；使用可执行批量操作的sqlSession //for循环并非批量，是插入1000次，而sqlsession是预编译sql，然后修改参数进行插入 EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); String uid = \"initUid\"; int rid1 = 666; int rid2 = 666; for (int i = 0; i &lt; 100; i++) &#123; uid = UUID.randomUUID().toString().substring(0, 5)+i; rid1 = (int)(1+Math.random()*(2-1+1)); rid2 = (int)(1+Math.random()*(2-1+1)); mapper.insertSelective(new Employee(null,uid,(rid1==1)?(\"M\"):(\"W\"),uid+\"@test.com\",rid2)); &#125; &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SpringMVC(3)","slug":"SpringMVC-3","date":"2019-10-06T07:11:34.000Z","updated":"2019-10-06T07:11:34.539Z","comments":true,"path":"2019/10/06/SpringMVC-3/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringMVC(2)","slug":"SpringMVC-2","date":"2019-10-06T07:11:26.000Z","updated":"2019-10-06T14:28:25.267Z","comments":true,"path":"2019/10/06/SpringMVC-2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-2/","excerpt":"","text":"文件上传文件上传需要的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 1.传统方式实现文件上传2.SpringMVC实现本地服务器文件上传在springmvc.xml文件中配置 文件解析器 对象 12345&lt;!-- 配置文件解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--最大上传大小：10MB=10*1024*1024B--&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; 3.SpringMVC实现跨服务器文件上传跨服务器上传文件需要的2个jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 4.代码 index.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;SpringMVC方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;跨服务器方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.yanghan.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;@Controller@RequestMapping(\"/file\")public class FileController &#123; /** * 跨服务器文件上传 * @return */ @RequestMapping(\"/fileupload3\") public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"跨服务器文件上传...\"); // 定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 创建客户端的对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; &#125; /** * SpringMVC文件上传 * @return */ @RequestMapping(\"/fileupload2\") public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println(\"springmvc文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return \"success\"; &#125; /** * 文件上传 * @return */ @RequestMapping(\"/fileupload1\") public String fileupload1(HttpServletRequest request) throws Exception &#123; System.out.println(\"文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for(FileItem item:items)&#123; // 进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; // 说明普通表单向 &#125;else&#123; // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 item.write(new File(path,filename)); // 删除临时文件 item.delete(); &#125; &#125; return \"success\"; &#125;&#125; 异常处理 web.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 字符过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp【测试页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"ex/testException\"&gt;异常测试&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ExceptionController.java【处理器】 1234567891011121314151617181920212223242526package com.yanghan.controller;import com.yanghan.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/ex\")public class ExceptionController &#123; @RequestMapping(\"/testException\") public String testException() throws SysException &#123; System.out.println(\"testException执行了...\"); try &#123; // 模拟异常 int a = 10/0; &#125; catch (Exception e) &#123; // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new SysException(\"出现异常了...\"); &#125; return \"success\"; &#125;&#125; SysException.java【系统异常实体类】 1234567891011121314151617181920212223package com.yanghan.exception;/** * 自定义异常类 */public class SysException extends Exception&#123; // 存储提示信息的 private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; SysExceptionResolver.java【异常处理器】 12345678910111213141516171819202122232425262728293031323334package com.yanghan.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver&#123; //处理异常业务逻辑 public ModelAndView resolveException (HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // 获取到异常对象 SysException e = null; if(ex instanceof SysException)&#123; e = (SysException)ex; &#125;else&#123; e = new SysException(\"系统正在维护....\"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\",e.getMessage()); mv.setViewName(\"error\"); return mv; &#125;&#125; springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.yanghan\"/&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!--配置异常处理器--&gt; &lt;bean id=\"sysExceptionResolver\" class=\"com.yanghan.exception.SysExceptionResolver\"/&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; error.jsp【返回的错误信息页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;errorMsg&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"SpringMVC(1)","slug":"SpringMVC-1","date":"2019-10-05T12:17:55.000Z","updated":"2019-10-06T10:19:45.392Z","comments":true,"path":"2019/10/05/SpringMVC-1/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/SpringMVC-1/","excerpt":"","text":"1. SpringMVC1.1. 简介SpringMVC框架基于组件方式的执行流程 1.导包 2.写配置 配置前端控制器。指明springmvc的配置文件的位置 配置视图解析器，简化方法返回值（目标页面地址），实现前缀+返回值+后缀以拼接地址。 3.测试 1.2. 入门案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.orbit&lt;/groupId&gt; &lt;artifactId&gt;springmvc_01_newstart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_01_newstart Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvc_01_newstart&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;============================== web.xml ==============================&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置解决中文乱码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.orbit\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器对象:可以根据服务方法的返回值,自动的拼接最终的跳转路径--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持：自动配置处理器映射器和处理器适配器 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 1234567891011121314151617============================== FirstController.java ==============================package com.orbit.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class firstController &#123; @RequestMapping(path=\"/hello\") public String sayHello()&#123; System.out.println(\"hello,SpringMVC\"); return \"success\"; &#125;&#125; 12345678910111213141516171819202122232425============================== index,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;第一个springMVC程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;点我跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;============================== success,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 跳转成功！&lt;/body&gt;&lt;/html&gt; 1.3. 用到的注解@RequestMapping:表示请求的具体的模块 value=&quot;/xx&quot;或path=&quot;/xx&quot;：指定请求的url method={RequestMethod.GET}：指定请求方式，GET，POST，…，是一个枚举类型的数组 params={&quot;&quot;}：指定请求中必须包含的请求参数的表达式集，是一个String类型的数组 params={&quot;param1&quot;}：请求中必须包含请求参数params1 params={&quot;!param1&quot;}：请求中不能包含请求参数param1 params={&quot;param1=123&quot;}：请求中必须包含请求参数params1，且其值必须是123 params={&quot;param1!=123&quot;}：请求中包含的请求参数的值不能是123（也可不包含param1，此时param1=null） params={&quot;param1=123&quot;,&quot;param2=zs&quot;}：请求中必须包含请求参数params1和param2，且param1=123,param2=zs headers={&quot;k=v&quot;}：指定发送的请求中必须包含的请求头 @RequestParam：获取请求的参数值，相当于request.getParameter(&quot;user&quot;); value=&quot;user&quot;：指定请求参数的key required：是否必须包含请求参数，true表示url一定要包含该请求参数，false表示可不包含 defaultValue：设置该参数的默认值 RequestHeader：获取请求头的部分的值 @RequestBody：获取请求体内容 @PathVariable获取请求路径中对应占位符的值。例如：url中有/delete/{id}，{id}就是占位符 。注意：1个占位符只能占1层路径 @ModelAttribute：出现在方法上：表示当前方法会在控制器方法执行前线执行。出现在参数上：获取指定的数据给参数赋值。 @CookieValue·：用于获取指定cookie的名称的值 2. 请求参数绑定2.1. 传入POJO，级联12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970============================== Account.java ==============================package com.orbit.domain;public class Account &#123; private Integer id; private String pwd; private Double money; private User user; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; //getter setter toString&#125;package com.orbit.domain;public class User &#123; private String uname; private Integer uage; //getter setter toString&#125;============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"params/saveAccount\" method=\"post\"&gt;序号：&lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"pwd\"&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"user.uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"user.uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"list[0].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"list[0].uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"map['one'].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"map['one'].uage\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;============================== ParamsController.java ==============================package com.orbit.controller;import com.orbit.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/params\")public class ParamsController &#123; @RequestMapping(\"/saveAccount\") public String savaAccount(Account account)&#123; System.out.println(account); return \"success\"; &#125;&#125;============================== 其他页面同入门案例 ============================== 2.2. 数据输出的方式（1）传入原生API (方式1)SpringMVC的handler接收如下的ServletAPI类型的参数： 123456789• HttpServletRequest• HttpServletResponse• HttpSession• java.security.Principal• Locale• InputStream• OutputStream• Reader• Writer （2）Map，Model，ModelMap（方式2）处理方法返回时，Map中的数据会自动添加到模型中 （3）ModelAndView作为返回值输出（方式3） 方法的返回值可以是ModelAndView类型， 既包含视图信息（页面地址），也包含模型数据（携带到页面的数据），模型数据存放在请求域（requestScope）中。 （4）@SessionAttributes临时保存数据（方式4）(了解)@SessionAttributes只能标在类上，是SpringMVC提供的一种临时在session域中保存数据的方式。 value=&quot;xx&quot;：本类中以xx为key所对应的值，临时复制到session域中 规则：将该类中保存在 BindingAwareModelMap 或 ModelAndView 中的数据，临时复制一份到session域中。 （5）@ModelAttribute（6）@ResponseBody响应json数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152============================== pom.xml ============================== &lt;dependencies&gt; &lt;!-- 新增依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yanghan\"&gt;&lt;/context:component-scan&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 告诉前端控制器，哪些路径下的资源不拦截--&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\"/&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 页面加载，绑定单击事件 $(function()&#123; $(\"#btn\").click(function()&#123; // alert(\"hello btn\"); // 发送ajax请求 $.ajax(&#123; // 编写json格式，设置属性和值 url:\"demo/testAjax\", contentType:\"application/json;charset=UTF-8\", data:'&#123;\"uid\":\"10001\",\"uname\":\"zs\",\"upwd\":123&#125;', dataType:\"json\", type:\"post\", success:function(data)&#123; // data服务器端响应的json的数据，进行解析 alert(data); alert(data.uid); alert(data.uname); alert(data.upwd); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122============================== TestController.java ==============================package com.yanghan.controller;import com.yanghan.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(\"/demo\")public class TestController &#123; @RequestMapping(\"/testAjax\") public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println(user.toString()); user.setUname(\"张三\"); return user; &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"Spring框架——AOP","slug":"Spring框架——AOP","date":"2019-10-05T05:35:06.000Z","updated":"2019-10-05T12:22:59.679Z","comments":true,"path":"2019/10/05/Spring框架——AOP/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/Spring框架——AOP/","excerpt":"","text":"3. Spring中的AOP3.1. 引出问题（1）完善之前的account案例 （2）引出问题 （3）动态代理的2种实现方式 （4）解决问题 3.2. AOP的基本概述（1）AOP中的一些专业术语 连接点（Joinpoint）：业务层中所有的方法 切入点（Pointcut）：业务层中所要代理增强的方法 切入点一定是连接点，但连接点不一定是切入点 通知/增强（advice）：拦截到连接点后做的事情即通知。 通知类型：前置通知，后置通知，异常通知，最终通知，环绕通知 引介（Introduction）一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 目标对象（Target）代理的目标对象。 代理（Proxy）一个类被 AOP 织入增强后，就产生一个结果代理类。 切面（Aspect） 是切入点和通知（引介）的结合。 织入（Weaving）: 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 3.3. 基于XML的AOP配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day03_eesy_04adviceType&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.itheima.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\" &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154============================== AccountService.java ==============================package com.itheima.service;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /** * 删除账户 * @return */ int deleteAccount();&#125;============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService&#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125; ============================== Logger.java ============================== package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试AOP的配置 */public class AOPTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); //3.执行方法 as.saveAccount(); &#125;&#125; 3.4. 基于注解的AOP配置@Pointcut(&quot;execution(* com.xxx.service.impl.*.*(..))&quot;)：切入点表达式注解 private void pc(){} @Before(pc())：前置通知注解 @AfterReturning(&quot;pc()&quot;)：后置通知注解 @AfterThrowing(&quot;pc()&quot;)：异常通知注解 @After&quot;pc()&quot;)：最终通知注解 @Around(&quot;pc()&quot;)：环绕通知注解 注意： 使用注解AOP配置会先执行最终通知，后执行后置通知/异常通知； 使用环绕通知则按照正常顺序执行。 因此实际开发时应该注意这个细节，正确选择合适的注解。 12345678910111213141516171819202122============================== pom.xml ==============================......============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置spring开启注解aop的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119============================== AccountService.java ==============================......============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;import org.springframework.stereotype.Service;/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService&#123; public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125;============================== Logger.java ==============================package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 用于记录日志的工具类，它里面提供了公共的代码 */@Component(\"logger\")@Aspect //表示当前类是切面public class Logger &#123; @Pointcut(\"execution(* com.itheima.service.impl.*.*(..))\") private void pc()&#123;&#125; /** * 前置通知 */ @Before(\"pc()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ @AfterReturning(\"pc()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ @AfterThrowing(\"pc()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ @After(\"pc()\") public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pc()\") public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================......","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring——JdbcTemplate,事务控制","slug":"Spring——JdbcTemplate-事务控制","date":"2019-10-04T15:13:33.000Z","updated":"2019-10-05T05:33:44.980Z","comments":true,"path":"2019/10/04/Spring——JdbcTemplate-事务控制/","link":"","permalink":"https://cometorbityh.github.io/2019/10/04/Spring——JdbcTemplate-事务控制/","excerpt":"","text":"4. Spring中的JdbcTemlateJdbcTemplate 是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。 导包： spring-jdbc-5.0.2.RELEASE.jar （数据库相关） spring-tx-5.0.2.RELEASE.jar（事务相关） JdbcTemplate的基础案例： 123456789101112131415============================== Account.java ============================== package com.yanghan.domain;/** * 账户实体类 */public class Account &#123; private Integer id; private String name; private Float money; //get + set //toString()&#125; 12345678910111213141516171819202122232425262728293031323334353637============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yanghan&lt;/groupId&gt; &lt;artifactId&gt;spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5. Spring中的事务控制","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring框架——IOC","slug":"Spring框架——IOC","date":"2019-10-02T07:53:22.000Z","updated":"2019-10-05T05:34:40.467Z","comments":true,"path":"2019/10/02/Spring框架——IOC/","link":"","permalink":"https://cometorbityh.github.io/2019/10/02/Spring框架——IOC/","excerpt":"","text":"1. Spring框架的基本概述1.1. Spring是什么？ 2. Spring中的IOCIOC : invertion of control（控制反转）——把对象的创建交给spring（IOC容器）来处理 IOC容器的理解：读取一个全限定类名，反射创建一个对象，并且存入核心容器中，最后通过对应的id来将该对象取出来。 2.1. 基于XML的IOC配置2.1.1. IOC中的bean标签 作用： 用于配置对象让 spring 来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 * singleton :默认值，单例的. * prototype :多例的. * request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. * session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. * global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session. init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162------------------------------ AccountService.java ------------------------------package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125;------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;public class AccountServiceImpl implements AccountService &#123; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125;------------------------------ bean.xml ------------------------------ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); System.out.println(as); &#125;&#125;------------------------------ 输出结果 ------------------------------ com.yanghan.service.impl.AccountServiceImpl@26be92ad 2.1.2. IOC 中的 DI 依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。注入依赖。 （1）构造函数注入 顾名思义，就是使用类中的构造函数，给成员变量赋值。 注意：赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。 要求： 类中需要提供一个对应参数列表的构造函数。 （有参构造函数） 标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 （需记忆参数索引位置，因此不用） type :指定参数在构造函数中的数据类型 （若有2个数据类型一样的参数则无法辨别，因此不用） name:指定参数在构造函数中的名称 用这个找给谁赋值 （推荐使用） （==上面三个找要赋值的参数，下面两个是给参数赋值==） value:它能赋的值是基本数据类型和 String 类型 ref :它能赋的值是其他 bean 类型，引用关联的bean对象，必须得是在配置文件中配置过的 bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283------------------------------ AccountService.java ------------------------------ package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125; ------------------------------ AccountServiceImpl.java ------------------------------ package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"西门吹雪\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ 西门吹雪,18,Thu Oct 03 13:56:03 CST 2019 （2）set方法注入 前提：setter方法 + 无参构造函数 标签：property 属性： name：找的是类中 set 方法后面的部分 ref ：引用其他 bean 类型 value：基本数据类型和 string 类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- set方法注入 --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"菠萝吹雪\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"20\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ 输出结果 ------------------------------菠萝吹雪,20,Thu Oct 03 14:45:23 CST 2019 （3）集合数据的注入（set方法） 在注入集合数据时，只要结构相同，标签可以互换 用于给List 结构集合注入的标签： list，array，set 用于给Map结构集合注入的标签：map，props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.*;public class AccountServiceImpl implements AccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,Object&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, Object&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"myStrs\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"张三\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"李四\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ [AAA, BBB, CCC][AAA, BBB, CCC][AAA, BBB, CCC]&#123;name=张三, sex=男&#125;&#123;name=李四, sex=男&#125; 2.2. 基于注解的IOC配置spring中IOC的常用注解学习基于注解的 IoC 配置，注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 实际开发中，基于注解和XML的IOC配置混合使用。 根据作用分类 基于XML的IOC配置 基于注解的IOC配置 创建对象（将当前类对象存入spring容器中） &lt;bean&gt;标签 @Component(value=&quot;bean-id&quot;) 默认值为当前类名首字母小写@Controller(value=&quot;bean-id&quot;)：用于表现层@Service(value=&quot;bean-id&quot;)：用于业务层@Repository(value=&quot;bean-id&quot;)：用于持久层 注入数据 &lt;bean&gt;标签中的 &lt;property&gt;标签 （1）注入其他bean：@autowired 自动按照类型注入。即bean的class ＊若容器中有唯一的bean对象类型与要注入的变量类型匹配，则注入成功。 ＊若容器中没有bean对象类型与要注入的变量类型匹配，则注入失败，报错。 ＊若容器中有多个bean对象类型匹配与要注入的变量类型匹配，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 出现位置：变量上 ／ 方法上@qualifier(value=&quot;bean-id&quot;) 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。 在给字段注入时，不能独立使用，必须和@autowired一起使用； 在给方法参数注入时，可以独立使用。@resource(name=&quot;bean-id&quot;)（2）注入基本类型和String：@Value(value=&quot;具体数据&quot;)：可以使用spEL（spring的EL表达式）（3）注入集合类型：只能通过XML来实现 改变作用范围 &lt;bean&gt;标签中的 scope属性 @Scope(value=&quot;&quot;) 指定bean的作用范围； value的取值：singleton，prototype，request，session，globalsession 生命周期相关 &lt;bean&gt;标签中的 init-method属性 destory-method属性 2.3. IOC案例（持久层技术选择：dbutils）案例1：使用XML方式实现单表的CRUD操作案例2：使用XML方式和注解方式实现单表的CRUD操作案例3：使用纯注解的方式实现单表的CRUD操作（spring的一些新注解使用） @Configuration：表示该类是一个配置类 @ComponentScan( value=&quot;xxx&quot; )：指定spring在创建容器时要扫描的包 @ComponentScan( basePackages=”xxx” ) @Bean(name= &quot;bean-id&quot; )：把当前方法的返回值作为bean对象存入spring的ioc容器中 当我们用注解配置方法时，若方法有参数，spring框架会去容器中查找有无可用的bean对象，查找的方式与Autowired注解一致。 @Import( )：导入其他的配置类，value的值是配置类的字节码 带有Import注解的配置类称为父配置类，被导入的配置类称为子配置类 @PropertySource：导入配置文件 spring和Junit整合#","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"JavaWeb--ajax","slug":"JavaWeb-ajax","date":"2019-09-27T09:58:24.000Z","updated":"2019-09-30T14:41:13.904Z","comments":true,"path":"2019/09/27/JavaWeb-ajax/","link":"","permalink":"https://cometorbityh.github.io/2019/09/27/JavaWeb-ajax/","excerpt":"","text":"ajax简介1. 概念1.1. Ajax 【 Asynchronous JavaScript And XML 】【 异步的JavaScript和XML 】 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 1.2. 异步和同步的概念​ 同步：客户端给服务端发送请求，客户端必须等待服务器端的响应，在等待服务端处理请求的过程中，客户端无法进行其他操作； ​ 异步：客户端给服务端发送请求，客户端无需等待服务器端的响应，在等待服务端处理请求的过程中，客户端可以进行其他操作。 2. 实现方式2.1. 原生的JS实现方式（了解） XMLHttpRequest 用于在后台与服务器交换数据 XMLHttpRequest对象的2个方法 open 方法 １. 作用：与服务器建立连接。 ２. open方法的３个参数: (1). 请求方式(GET、POST) (2). 请求的URL： ＊若请求方式为GET，则将请求参数拼接在URL后方，send方法为空参或null ＊请求参数为POST，则将请求参数在send方法中定义 (3). 是否为异步请求，true为异步，false为同步send 方法 1. 作用：发送请求 2. send(xxx); XMLHttpRequest对象的2个属性 readyState（就绪状态） 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status（响应状态码） 200: “OK” 404: 未找到页面 2.2. JQuery实现方式（掌握） $.ajax( ) 语法：$.ajax({键值对});由于有很多内置键，因此举个例子介绍常用的几个键： $.get( ) 语法：$.get ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） $.post( ) 语法：$.post ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） —– 举个例子 —– ajax01.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;发送异步请求&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function fun1() &#123; $.ajax(&#123; url:\"ajaxServlet\", //请求路径 type:\"POST\", //请求方式 data:&#123;\"username\":\"Ajax\"&#125;, //请求参数 //data:\"username=jack\", success:function (data) &#123; //响应成功后的回调函数 alert(data); &#125;, error:function () &#123; alert(\"出错了\"); &#125;, &#125;); &#125; function fun2() &#123; $.get(\"ajaxServlet\",&#123;username:\"Get\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; function fun3() &#123; $.post(\"ajaxServlet\",&#123;username:\"Post\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"submit\" value=\"ajax方式发送异步请求\" onclick=\"fun1();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"get 方式发送异步请求\" onclick=\"fun2();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"post方式发送异步请求\" onclick=\"fun3();\"&gt;&lt;/body&gt;&lt;/html&gt; AjaxServlet.java 12345678910111213141516171819202122232425package com.test.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/ajaxServlet\")public class AjaxServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求参数 String username = request.getParameter(\"username\"); //2.处理业务逻辑 //3.打印username System.out.println(username); //4.响应 response.getWriter().write(\"hello:\"+username); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; JSON1. 概念 【JSON】【Javascript Object Notation】【JavaScript对象表示法】 进行数据的传输。是存储和交换文本信息的语法。 类似XML，但比XML更小更快，更易解析 2. JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 2.1. JSON定义数据的规则数据在名称/值对中 ＊键用引号（单双均可）括起来，也可以不使用引号 ＊JSON 值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 数据由逗号分隔：多个键值对用逗号隔开 花括号保存对象 方括号保存数组 2.2. JSON获取数据的规则 json对象的键名 json对象[“键名”] 数组对象[索引] 2.3. JSON遍历数据for ( var 键 in json对象 ) { ​ alert ( json对象 [ 键 ] ); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;script&gt; //1. 定义基本格式 var person = &#123;name:\"熊大\",age:23,gender:true&#125;; //alert(person.name); //遍历基本格式的json数据 for(var key in person)&#123; //key是字符串，person.key相当于person.\"xxx\"，因此不可取 alert(key + \":\" + person[key]); &#125; //2. 嵌套格式 （json对象中的数组） var persons = &#123; person:[ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ] &#125;; alert(persons.person[2].name); //3. 嵌套格式 （数组中的json对象） var persons2 = [ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ]; //alert(persons2[1].name); // 遍历数组中的json数据 for(var i=0;i&lt;persons2.length;i++)&#123; var p = persons2[i]; for(var key in p)&#123; alert(key + \":\" +p[key]); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JavaWeb项目——学生管理系统","slug":"JavaWeb项目——学生管理系统","date":"2019-09-06T08:31:03.000Z","updated":"2019-09-06T08:35:23.962Z","comments":true,"path":"2019/09/06/JavaWeb项目——学生管理系统/","link":"","permalink":"https://cometorbityh.github.io/2019/09/06/JavaWeb项目——学生管理系统/","excerpt":"","text":"1. 创建数据库123456CREATE TABLE `t_stu` (`id` int(10) NOT NULL AUTO_INCREMENT ,`uname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`upwd` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,PRIMARY KEY (`id`)) 2. 创建JDBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBC &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); System.out.println(\"驱动注册成功\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); System.out.println(\"数据库连接成功\"); stmt = conn.createStatement(); System.out.println(\"连接对象创建成功\"); String sql = \"select * from t_stu\"; rs = stmt.executeQuery(sql); if(rs.next()) &#123; System.out.print(rs.getInt(\"id\")+\" \"); System.out.print(rs.getString(\"uname\") + \" \"); System.out.println(rs.getString(\"upwd\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"项目","slug":"项目","permalink":"https://cometorbityh.github.io/tags/项目/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-09-03T08:55:59.000Z","updated":"2019-09-29T16:34:22.908Z","comments":true,"path":"2019/09/03/JDBC/","link":"","permalink":"https://cometorbityh.github.io/2019/09/03/JDBC/","excerpt":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。","text":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。 一、JDBC编程6步 注册驱动（作用：告知Java程序，指明将要连接的数据库品牌） 获取连接（打开JVM的进程和数据库的进程之间的通道，属于进程之间的通信，使用完需要关闭） 获取数据库操作对象（专门执行sql语句的对象） 执行sql语句（DQL，DML） 处理查询指令集（只有当第四步执行的是select语句的时候，才需要第五步，否则省略） 释放资源（关闭JVM的进程和数据库的进程之间的通信资源） 二、JDBC的基本使用本例使用的是Mysql数据库，其驱动为mysql-connector-java-5.1.47.jar. 新建java project——在项目下新建文件夹lib——导入Mysql驱动jar包，右键jar包，点击build path,add 即可。 1. 使用Statement对数据库进行 “增删改” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.orbit.jdbc;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class test01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; // 1.注册驱动 //方式一// Driver driver = new com.mysql.jdbc.Driver();// Driver driver = new com.oracle.Driver.OracleDriver();// DriverManager.registerDriver(driver); //方式二(常用，原因是参数是字符串，字符串可以写到properties文件中，起到解耦合的作用) //该方法无需接收返回值，因为我们只想用它的类加载动作 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.获取连接 // oracle的URL： jdbc:oracle://localhost:1521:xxx String url = \"jdbc:mysql://localhost:3306/orbit\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); //com.mysql.jdbc.JDBC4Connection@3d646c37 System.out.println(conn); // 3.获取数据库操作对象（Statement专门执行sql语句） stmt = conn.createStatement(); // 4.执行sql (JDBC中的sql语句不需要分号结尾)// String sql = \"insert into dept(dno,dname,dage) values(2,'LS',23)\"; String sql = \"delete from dept where dno = 2\";// String sql = \"update dept set dname='王五',dage='20' where dno=1\"; // 专门执行DML语句的（insert，delete，update），返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); // 5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源，为了保证资源一定释放，必须放到finally语句中关闭资源 // 并且要遵循从小到大依次关闭，分别对其try...catch try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注册驱动的方式二为什么能够用放射直接调用？** ​ 因为mysql的驱动包中的com.mysql.jdbc包下的Driver.java的静态块中已经注册了驱动 2. 从属性配置文件中获取连接在src文件下新建file，输入”db.properties” db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/orbituser=rootpassword=123456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"insert into dept(dno,dname,dage) values(3,'娜可露露',22)\"; int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3. 使用Statement对数据库进行 “查” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"select dno,dname,dage from dept\"; rs = stmt.executeQuery(sql); System.out.println(rs); while(rs.next()) &#123; //该行有元素 int eno = rs.getInt(1); String ename = rs.getString(2); int eage = rs.getInt(3); //第二种写法：在getString中直接写入列名// String eno = rs.getString(\"dno\"); // String ename = rs.getString(\"dname\");// String eage = rs.getString(\"dage\"); System.out.println(eno +\" \" + ename + \" \" +eage); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4. 实例（设计登录界面，并解决SQL注入）这里使用到一个工具“PowerDesigner16.5”，用以物理建模，它与MySQL所不同的是，PowerDesigner用于设计阶段的物理建模，而MySQL用于开发阶段的数据处理。 123456789101112131415161718drop table if exists t_user;/*==============================================================*//* Table: t_user *//*==============================================================*/create table t_user( id bigint auto_increment, loginName varchar(255), loginPwd varchar(255), realName varchar(255), primary key (id));insert into t_user(loginName,loginPwd,realName) values('Zhangsan','123','张三');insert into t_user(loginName,loginPwd,realName) values('LiSi','123','李四');insert into t_user(loginName,loginPwd,realName) values('Wangwu','123','王五');commit;select * from t_user; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest02 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; Statement stmt = null; ResultSet rs = null; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql String sql = \"select * from t_user where loginName = '\"+loginName+\"' and loginPwd = '\"+loginPwd+\"'\"; //5、处理查询结果集 //发生sql语句给DBMS，DBMS进行sql编译 rs = stmt.executeQuery(sql); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 但是此时的程序存在一个安全问题，请看下面案例： 该现象称为“SQL注入”，这是一个安全隐患，是黑客入侵常用手段。 发生sql注入的原因是什么？ 用户输入的信息中含有sql的关键字，并且这些关键字拼接在sql语句中，参与sql语句的编译过程，导致sql语句原意被扭曲，进而引起sql注入。 如何解决SQL注入？ 只要用户提供的信息不参与SQL语句的编译过程，问题即可解决。 即便用户提供的信息中包含SQL的关键字，但这些关键字没有参与编译，就不会起作用 要想用户信息不参与SQL编译，需要用到java.sql.PreparedStatement PreparedStatement接口继承了java.sql.Statement，是预编译数据库操作对象(作用：编译、 ) 其原理为：预先对SQL语句的框架进行编译，然后再给SQL语句传值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest03 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、执行sql语句框架 // ?表示一个占位符，用来接收值。注意？不加单引号 String sql = \"select * from t_user where loginName = ? and loginPwd = ?\"; //4、获取预编译数据库操作对象 ps = conn.prepareStatement(sql); //给占位符传值，若为字符串，其传值方法为setString(下标，值)； JDBC的下标都是从1开始的 ps.setString(1,loginName); //将对应下标的？替换为'xxxx' ps.setString(2,loginPwd); // ps.setString(3,100); 将对应下标的？替换为100 //5、处理查询结果集 rs = ps.executeQuery(); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 比较Statement和PreparedStatement Statement存在注入问题，PreparedStatement可以解决SQL注入问题 Statement是编译一次执行一次，PreparedStatement是编译一次执行N次；（多次执行相同的sql语句时，DBMS只会编译一次就可以执行多次。Statement的sql语句中包含可变的参数，每次执行都要重新编译，PreparedStatement中sql语句占位符是固定的符号，只需编译一次即可执行多次） PreparedStatement会在编译阶段做类型的安全检查，如setString()方法中输入了int型字符，系统会报错。 因此，PreparedStatement使用场景较多。但需要sql注入时就要用到Statement 5.实例（Statement实现输入升序降序）升序降序用PreparedStatement传值给占位符？是不可行的，因为desc,asc都是字符串，传进入的话会加上引号，无法识别，因此需要用到Statement来实现输入升序降序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.*;import java.util.Scanner;public class JDBCTest04 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(\"输入asc/desc进行升序/降序：\"); String keyWord = sc.nextLine(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); stmt = conn.createStatement(); String sql = \"select loginName from t_user order by loginName \"+ keyWord; rs = stmt.executeQuery(sql); while (rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 6.使用PreparedStatement增删改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.jdbc;import java.sql.*;public class JDBCTest05 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\");// String sql = \"insert into t_user(loginName,loginPwd,realName) values(?,?,?)\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"ZhaoLiu\");// ps.setString(2,\"123\");// ps.setString(3,\"赵六\");// String sql = \"delete from t_user set loginName = ? ,realName = ? where id = ?\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"WangBa\");// ps.setString(2,\"王八\");// ps.setInt(3,4); String sql = \"delete from t_user where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1,4); int count = ps.executeUpdate(); System.out.println(count + \"行受影响\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 7. JDBC事务问题(模拟账户转账)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); //空指针异常，会导致程序中途停止运行 //导致用户10001丢失10000元，而用户10002也没收到10000元 String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解决方案(3行重要代码) conn.setAutoCommit(false); 禁用自动提交事务，开启事务 conn.commit(); 手动提交事务，即在此处才执行sql语句，事务结束 conn.rollback(); 回滚事务，回到事务发生之前数据，事务结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //禁用自动提交事务 conn.setAutoCommit(false); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); //手动提交事务 conn.commit(); &#125; catch (Exception e) &#123; if(conn != null)&#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 8.简化代码为工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.orbit.jdbc.DBUtil;import java.sql.*;public class DBUtil &#123; /*工具类的构造方法都是私有的， * 因为工具类的方法都是静态的，无需new对象，直接使用类名调用*/ private DBUtil()&#123;&#125; //静态代码块在类加载时执行，且只执行一次 //注册驱动只需要执行一次，因此放在静态代码块中 static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; //Statement ps面向抽象编程 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627package com.orbit.jdbc;import com.orbit.jdbc.utils.DBUtil;import java.sql.*;public class JDBCTest07 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = \"select loginName from t_user where loginName like ?\"; ps = conn.prepareStatement(sql); ps.setString(1,\"%g%\"); rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtil.close(conn,ps,rs); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/tags/JDBC/"}]},{"title":"JSP——系统开发模型","slug":"JSP——系统开发模型","date":"2019-08-31T06:51:33.000Z","updated":"2019-09-03T15:06:52.679Z","comments":true,"path":"2019/08/31/JSP——系统开发模型/","link":"","permalink":"https://cometorbityh.github.io/2019/08/31/JSP——系统开发模型/","excerpt":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构","text":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构 开发模型1. 纯JSP将所有业务处理、数据显示功能全都放在JSP页面完成。 缺点：代码结构乱，显示功能与业务处理功能代码没有划分，维护和升级麻烦。 2. JSP+JavaBean的Model1该开发模型将大多数业务处理交给专门的JavaBean完成。JSP页面主要负责数据显示功能。相对于“纯JSP”来说，已经得到极大改进。但是对于客户端的请求的解析，对于JavaBean对象的选择和创建，还是由JSP页面处理，即JSP还负责大量的请求解析、业务处理功能。 JavaBean的介绍 JavaBean 广义JavaBean，一般的Java类，主要功能：承载数据，业务处理 数据承载Bean：实体类，专门用于承载数据（装数据）的类，如User，Student 业务处理Bean：Service或Dao对象，专门用以处理用户提交请求的类。 狭义JavaBean：符合SUN公司提出的“JavaBean规范”的Java类。JavaBean规范规定，该类需满足以下四点： 公共，public class 实现Serializable接口 具备无参构造器 若有成员变量，则成员变量应该是私有的，且提供getter和setter 实际项目中，实体类（广义JavaBean的数据承载Bean）一般会被定义成满足“JavaBean规范”的狭义JavaBean 3. MVC的Model2MVC Model（模型），承载数据，并对用户的请求进行计算的模块。分为数据承载Bean和业务处理Bean，其实就是JavaBean。 View（视图），为用户提供使用界面，与用户进行直接交互 Controller（控制器），将请求转发给相应的Model进行处理，即选择使用哪一个JavaBean来处理请求。并提供Model的计算结果向用户进行相应的响应。 4. MVC + 三层架构三层架构 View层 / 视图层 / 表现层 / web层，编写用于接收用户请求的代码 Service层 / 服务层 / 业务层 / 逻辑层，编写系统的业务逻辑 Dao层 / 持久层 / 数据访问层，编写直接操作数据库的代码，Data Access Object数据访问对象 为了更好的降低各层之间的耦合度，在三层架构程序设计中，采用面向抽象编程，即上层对下层的调用是通过接口实现的。下层对上层的真正服务者，是下层接口的实现类，服务标准（接口）是相同的，服务提供者（实现类）可更换，这就实现了层间解耦合。 MVC + 三层架构 “MVC + 三层架构”开发模型，主要是指将MVC的业务处理Model分成了2层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。 “MVC + 三层架构”开发模型，是传统的JavaWeb项目最常用的开发模型。 实例：学生登录系统","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——JSTL","slug":"JSP——JSTL","date":"2019-08-30T08:22:01.000Z","updated":"2019-08-31T06:49:16.550Z","comments":true,"path":"2019/08/30/JSP——JSTL/","link":"","permalink":"https://cometorbityh.github.io/2019/08/30/JSP——JSTL/","excerpt":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。","text":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。 JSTL中定义了5个标签库： 核心标签库：主要用于完成基本逻辑运算 格式化标签库：主要用于完成日期、数字的格式化显示 EL函数标签库：定义了16个EL函数 SQL操作标签库：完成SQL操作，现已废弃不用，Java代码即可完全实现SQL操作 XML操作标签库：完成XML操作，现已废弃不用，Java代码即可完全实现XML操作 1 核心标签库（遍历数据等）12&lt;!-- 使用前先导入标签库 --&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; c:set——为指定变量赋值123456789101112131415161718192021222324252627282930313233package com.orbit.beans;public class Information &#123; private String uname; private String gender; public Information() &#123; // TODO Auto-generated constructor stub &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Information(String uname, String gender) &#123; super(); this.uname = uname; this.gender = gender; &#125; @Override public String toString() &#123; return \"Information [uname=\" + uname + \", gender=\" + gender + \"]\"; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:set 为域中的指定变量赋值 --------------- &lt;br/&gt; &lt;!-- var是变量名，value是变量值，scope是变量所在域，默认是pageContext --&gt; &lt;c:set var=\"name\" value=\"小明\" scope=\"session\"/&gt; name = $&#123;name &#125;&lt;br/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为域中的Bean对象的属性赋值 --------------- &lt;br/&gt; &lt;% Information info = new Information(); pageContext.setAttribute(\"info\", info); %&gt; &lt;!-- property表示属性名，value表示属性值，target表示属性的范围 --&gt; &lt;c:set value=\"小李\" property=\"uname\" target=\"$&#123;pageScope.info &#125;\"/&gt; &lt;c:set value=\"男\" property=\"gender\" target=\"$&#123;pageScope.info &#125;\"/&gt; info = $&#123;info&#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为Map的键值赋值 --------------- &lt;br/&gt; &lt;% Map &lt;String,Object&gt; map = new HashMap(); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- property表示指定key，value表示key的值，target表示key的范围 --&gt; &lt;c:set value=\"网龙\" property=\"company\" target=\"$&#123;pageScope.map&#125;\"/&gt; &lt;c:set value=\"福建\" property=\"place\" target=\"$&#123;pageScope.map&#125;\"/&gt; map = $&#123;map &#125;&lt;/body&gt;&lt;/html&gt; c:remove——删除域中的属性1234567891011121314151617181920212223242526272829&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:remove 删除指定域中的指定属性 --------------- &lt;br/&gt; &lt;c:set var=\"name\" value=\"page_name\"/&gt; &lt;c:set var=\"name\" value=\"req_name\" scope=\"request\"/&gt; &lt;c:set var=\"name\" value=\"ses_name\" scope=\"session\"/&gt; &lt;c:set var=\"name\" value=\"app_name\" scope=\"application\"/&gt; &lt;c:remove var=\"name\" scope=\"session\"/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:remove 删除所有域中的指定属性 --------------- &lt;br/&gt; &lt;c:remove var=\"name\" /&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; c:out1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"test1\" value=\"&lt;h2&gt;hello,java!&lt;/h2&gt;\"/&gt; &lt;!-- value中EL的变量未定义时，默认输出default的值 --&gt; &lt;!-- value会原样输出其值，若该值带有html标签，可用escapeXml对该值进行解析 --&gt; &lt;c:out value=\"$&#123;test1 &#125;\" default=\"Hello,jsp!\" escapeXml=\"false\"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value=\"$&#123;test2 &#125;\" default=\"Hello,jsp!\"&gt;&lt;/c:out&gt;&lt;/body&gt;&lt;/html&gt; c:catch——捕获异常对象1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:catch var=\"math\"&gt; &lt;% int i = 7 / 0; %&gt; &lt;/c:catch&gt; $&#123;math.message &#125;&lt;/body&gt;&lt;/html&gt; c:if（掌握）——条件判断1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"name\" value=\"熊大\"/&gt; &lt;c:if test=\"$&#123;name=='熊大' &#125;\"&gt; &lt;href a=\"#\"&gt;我是熊大&lt;/href&gt; &lt;/c:if&gt; &lt;/body&gt;&lt;/html&gt; c:choose（掌握）——条件判断123456789101112131415161718192021222324252627282930313233&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"pageno\" value=\"2\"/&gt;&lt;c:set var=\"totalpage\" value=\"3\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;totalpage == 1 &#125;\"&gt; 首页 上一页 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == 1 &#125;\"&gt; 首页 上一页 &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == totalpage &#125;\"&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach（掌握）——遍历&lt;c:forEach items=”${names }” var=”name” begin=”0” end=”9” step=”2”varStatus=”status” &gt; begin、end、step分别表示：起始序号，结束序号，跳跃步伐 varStatus属性定义了一个status名的对象作为varStatus的绑定值，该绑定值也就是status封装了当前遍历的状态。可以方便我们实现一些与行数相关的功能，如：奇数行、偶数行差异；最后一行特殊处理等等。先就varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=\"text/css\"&gt; .odd&#123; background-color: #F8E2D3; &#125; .even&#123; background-color: #D3EE66; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;------------ c:forEach 例1 ------------&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"喜羊羊\"); names.add(\"美羊羊\"); names.add(\"懒羊羊\"); names.add(\"沸羊羊\"); names.add(\"暖羊羊\"); names.add(\"慢羊羊\"); names.add(\"灰太狼\"); names.add(\"红太狼\"); names.add(\"小灰灰\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name，step步长 --&gt; &lt;c:forEach items=\"$&#123;names &#125;\" var=\"name\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/c:forEach&gt;------------ c:forEach 例2 ------------&lt;br/&gt; &lt;c:forEach var=\"num\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;num &#125; &lt;/c:forEach&gt; &lt;br/&gt; ------------ c:forEach 例3 ------------&lt;br/&gt;&lt;% List&lt;Information&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Information(\"张三\",\"男\")); persons.add(new Information(\"李四\",\"不详\")); persons.add(new Information(\"王五\",\"男\")); persons.add(new Information(\"赵六\",\"女\")); persons.add(new Information(\"田七\",\"女\")); persons.add(new Information(\"王八\",\"男\")); pageContext.setAttribute(\"persons\", persons); %&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;persons &#125;\" var=\"person\" varStatus=\"vs\"&gt; &lt;tr class=\"$&#123;vs.count % 2==0 ? 'even':'odd'&#125;\"&gt; &lt;td&gt;$&#123;vs.count &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.uname &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.gender &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2 格式化标签库fmt:formatDate——日期格式fmt:parseDatefmt:formatNumberfmt:parseNumber12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;---------- 格式化日期 ----------&lt;br/&gt; &lt;% Date now = new Date(); pageContext.setAttribute(\"now\", now); %&gt; now = $&#123;now &#125;&lt;br/&gt; now = &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\"/&gt;&lt;br/&gt; &lt;!-- 将结果保留在var属性中 --&gt; &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\" var=\"time\"/&gt; birthday = $&#123;time &#125;&lt;br/&gt;----------将字符串转换为日期 ----------&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\"/&gt;&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\" var=\"day\"/&gt; ay = $&#123;day &#125; &lt;br/&gt;---------- 格式化数字 ----------&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" groupingUsed=\"false\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxIntegerDigits=\"8\" minIntegerDigits=\"6\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxFractionDigits=\"6\" minFractionDigits=\"5\"/&gt;&lt;br/&gt; &lt;br/&gt;----------将字符串转换为数字 ----------&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\"/&gt;&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\" var=\"num\"/&gt; num + 1 = $&#123;num + 1&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——自定义标签","slug":"JSP——自定义标签","date":"2019-08-28T11:59:55.000Z","updated":"2019-08-30T08:49:28.154Z","comments":true,"path":"2019/08/28/JSP——自定义标签/","link":"","permalink":"https://cometorbityh.github.io/2019/08/28/JSP——自定义标签/","excerpt":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。","text":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。 自定义标签的步骤： 定义标签处理器——定义一个类，继承SimpleTagSupport类，重写doTag( )方法 注册标签库，注册标签 导入标签库，使用标签 下面举2个案例来说明自定义标签。 2 定义带标签体的自定义标签（使用无标签体的标签完成：输出客户端IP） （使用有标签体的标签完成：小写转大写） 2-1 定义标签处理器 一个标签对应着一个类的一段代码。 一个类要实现自定义标签的功能，需要该类实现一个接口：Javax.servlet.jsp.tagext.SimpleTag，该接口有5个需要实现的方法，此时该类被称为标签处理器类。 ​ 123456789101112131415161718192021222324252627package com.orbit.tag;import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：获取客户端IPpublic class ClientIPTag extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //获取PageContext对象 PageContext pc = (PageContext) this.getJspContext(); //获取请求对象 ServletRequest request = pc.getRequest(); //获取客户端IP String ClientIp = request.getRemoteAddr(); //获取标准输出流 JspWriter out = pc.getOut(); //将客户端IP写入到输出流中 out.print(ClientIp); &#125;&#125; 12345678910111213141516171819202122232425262728package com.orbit.tag;import java.io.IOException;import java.io.StringWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：小写转大写public class LowerToUpper extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //创建一个输出流，该流中的内容可以通过其toString()方法获取到文本形式 StringWriter sw = new StringWriter(); //获取标签体对象 JspFragment jspBody = this.getJspBody(); //将标签体内容写入到输出流中 jspBody.invoke(sw); //以文本形式获取到输出流中的内容 String content = sw.toString(); //小写变大写 content = content.toUpperCase(); //将文本写入到标准输出流并打印 this.getJspContext().getOut().print(content);; &#125;&#125; 2-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;!-- 注册标签 --&gt; &lt;tag&gt; &lt;name&gt;clientIP&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ClientIPTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;tag&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.LowerToUpper&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- empty:当前标签没有标签体 scriptless:当前标签有标签体，但该标签中不能出现Java脚本，可以出现EL表达式 jsp:(已过时)，当前标签具有标签体，标签体内容原样显示到浏览器 tagdependent:当前标签有标签体，标签体内容原样显示到浏览器，即使是EL也一样 --&gt;&lt;/taglib&gt; 2-3 导入标签库，使用标签123456789101112131415161718192021222324252627&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用Java代码块获取IP --&gt; &lt;% String ip = request.getRemoteAddr(); out.println(\"ip = \" + ip); %&gt;&lt;br/&gt; &lt;!-- 使用无标签体的自定义标签获取IP --&gt; ip = &lt;tag:clientIP/&gt;&lt;br/&gt; &lt;!-- 使用有标签体的自定义标签完成小写转大写 --&gt; &lt;% String s = \"abc\"; pageContext.setAttribute(\"s\", s); %&gt; &lt;tag:LowerToUpper&gt;$&#123;s&#125;&lt;/tag:LowerToUpper&gt;&lt;br/&gt; &lt;tag:LowerToUpper&gt;are you kidding me?&lt;/tag:LowerToUpper&gt; &lt;/body&gt;&lt;/html&gt; 2-4 输出结果 3 定义带属性的自定义标签3-1 定义标签处理器1234567891011121314151617181920212223242526272829package com.orbit.tag;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;public class IfTag extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; if(test) &#123;// //获取标签体对象// JspFragment jspBody = this.getJspBody();// //将标签体加入到输出流// jspBody.invoke(this.getJspContext().getOut()); //invoke(null)等价于invoke(this.getJspContext().getOut()) this.getJspBody().invoke(null); &#125; &#125;&#125; 3-2 定义标签库，注册标签12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.IfTag&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 标签的属性 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性名 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true表示调用该标签时，必须要写该属性 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- runtime expression value运行时表达式值，true表示该属性的值支持EL与JSP表达式 --&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 3-3 导入标签库，使用标签123456789101112131415161718192021&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用带属性的自定义标签 --&gt; &lt;% boolean gender = true; pageContext.setAttribute(\"gender\", gender); %&gt; &lt;tag:if test=\"$&#123;gender &#125;\"&gt;男&lt;/tag:if&gt; &lt;tag:if test=\"$&#123;not gender &#125;\"&gt;女&lt;/tag:if&gt; &lt;/body&gt;&lt;/html&gt; #### 3-4 输出结果 4 自定义遍历List集合的forEachList标签4-1 定义标签处理器123456789101112131415161718192021222324252627282930package com.orbit.tag;import java.io.IOException;import java.util.List;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachListTag extends SimpleTagSupport&#123; private List items; private String var; //var代表当前对象要放入域中的属性名 public void setItems(List items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; for (Object obj : items) &#123; //EL只能处理四大域中的数据，因此将该遍历对象放入到四大域中 //key为var指定的名称（name）,value为当前遍历对象obj this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 4-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEachList&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachListTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 4-3 导入标签库，使用标签12345678910111213141516171819202122232425&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自定义标签 --&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEachList items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEachList&gt; &lt;/body&gt;&lt;/html&gt; 4-4 输出结果 5 自定义遍历集合和数组的forEach标签5-1 定义标签处理器(方法一) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.orbit.tag;import java.io.IOException;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; //判断items的类型 if(items instanceof List) &#123; List itemsList = (List) items; for (Object obj : itemsList) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Set) &#123; Set itemsSet = (Set) items; for (Object obj : itemsSet) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Map) &#123; Map itemsMap = (Map) items; for (Object obj : itemsMap.entrySet()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Object[]) &#123; Object[] itemsObject = (Object[]) items; for (Object obj : itemsObject) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125; &#125;&#125; （方法二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.tag;import java.io.IOException;import java.lang.reflect.Array;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var;// private Collection coll; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; public Collection getColl() &#123; if(items instanceof List) &#123; return (List) items; &#125;else if(items instanceof Set) &#123; return (Set) items; &#125;else if(items instanceof Map) &#123; return ((Map) items).entrySet(); &#125; /*该方法只能遍历非基本数据类型的数组*/// else if(items instanceof Object[]) &#123;// //将items强转为数组，数组再转为List集合（因为返回值是集合类型）// return Arrays.asList((Object[])items);// &#125; /*该方法能遍历任何数组*/ else if(items.getClass().isArray()) &#123; List nums = new ArrayList(); for(int i =0;i&lt;Array.getLength(items);i++) &#123; nums.add(Array.get(items, i)); &#125; return nums; &#125; return null; &#125; @Override public void doTag() throws JspException, IOException &#123; //遍历getColl()的返回值 for (Object obj : getColl()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 5-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEach&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 5-3 导入标签库，使用标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ===========遍历List===========&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEach items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Set===========&lt;br/&gt; &lt;% Set&lt;String&gt; cities = new HashSet&lt;&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"广州\"); pageContext.setAttribute(\"cities\", cities); %&gt; &lt;tag:forEach items=\"$&#123;cities &#125;\" var=\"city\"&gt; $&#123;city &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Map===========&lt;br/&gt; &lt;% Map&lt;String,Object&gt; infos = new HashMap&lt;&gt;(); infos.put(\"name\", \"张三\"); infos.put(\"age\", 24); infos.put(\"gender\", \"男\"); pageContext.setAttribute(\"infos\", infos); %&gt; &lt;tag:forEach items=\"$&#123;infos &#125;\" var=\"info\"&gt; $&#123;info &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型的数组===========&lt;br/&gt; &lt;% Object[] objs = &#123;\"元素1\",\"元素2\",\"元素3\"&#125;; pageContext.setAttribute(\"objs\", objs); %&gt; &lt;tag:forEach items=\"$&#123;objs &#125;\" var=\"obj\"&gt; $&#123;obj &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型及数据类型的数组===========&lt;br/&gt; &lt;% int[] ages = &#123;11,12,13&#125;; pageContext.setAttribute(\"ages\", ages); %&gt; &lt;tag:forEach items=\"$&#123;ages &#125;\" var=\"age\"&gt; $&#123;age &#125; &lt;br/&gt;&lt;/tag:forEach&gt; &lt;/body&gt;&lt;/html&gt; 5-4 输出结果 6 将自定义标签库打包发行右击项目名——Export——搜索JARfile——勾选需要打包的包名，其他的取消勾选，选择保存位置，命名为xxx.jar——将对应的tld文件复制到xxx.jar中的META-INF文件夹中——需要时导入即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"Next主题格式配置记录","slug":"Next主题格式配置记录","date":"2019-08-27T15:23:14.000Z","updated":"2019-08-27T15:48:58.046Z","comments":true,"path":"2019/08/27/Next主题格式配置记录/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/Next主题格式配置记录/","excerpt":"文章背景色","text":"文章背景色","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://cometorbityh.github.io/tags/next/"}]},{"title":"使用PicGo + 七牛云 快速创建图床","slug":"使用PicGo-七牛云-快速创建图床","date":"2019-08-27T12:04:12.000Z","updated":"2019-08-27T15:25:44.190Z","comments":true,"path":"2019/08/27/使用PicGo-七牛云-快速创建图床/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/使用PicGo-七牛云-快速创建图床/","excerpt":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。","text":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。 注册七牛云账号（https://www.qiniu.com/），并完成实名认证。 创建存储空间 下载并安装PicGo（https://github.com/Molunerfinn/PicGo/releases） 七牛图床设置 上传图片","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"JSP——EL表达式","slug":"JSP——EL表达式","date":"2019-08-26T06:14:53.000Z","updated":"2019-08-31T07:19:51.261Z","comments":true,"path":"2019/08/26/JSP——EL表达式/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/JSP——EL表达式/","excerpt":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值","text":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值 使用EL获取数据 从四大域中获取数据EL只能获取到四大域中的数据，因此要获取到某个数据，需要将其加入到某个域中，再使用EL表达式获取数据。 从四大域中依次查找数据 ${属性}EL01.jsp 12345678910&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;name&#125; &lt;/body&gt; 输出结果为page域的属性值（最小的域） 从指定域中获取数据 ${域scope.属性}依次从四大域查找属性效率过低，为了提高效率，我们应该想想如何从指定域中直接获取某个属性值。 EL有4个域属性空间相关的内置对象，分别为pageScope，requestScope，sessionScope，applicationScope。表示从对应域属性空间中查找指定key。 1234567891011121314&lt;!-- EL01.jsp --&gt;&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;pageScope.name&#125;&lt;br/&gt; name = $&#123;requestScope.name&#125;&lt;br/&gt; name = $&#123;sessionScope.name&#125;&lt;br/&gt; name = $&#123;applicationScope.name&#125;&lt;br/&gt;&lt;/body&gt; 获取Bean的属性 ${key.属性}创建一个Bean的对象，将这个Bean对象加入到域属性空间中，通过 ${key.属性} 可以访问该对象的属性值。 注意：若访问对象为null，则EL也不会报空指针异常，显示结果为”” 12345678910111213141516171819202122232425262728293031/* School.java */package com.orbit.el;public class School &#123; private String scname; private String scaddress; public School(String scname, String scaddress) &#123; super(); this.scname = scname; this.scaddress = scaddress; &#125; public String getScname() &#123; return scname; &#125; public void setScname(String scname) &#123; this.scname = scname; &#125; public String getScaddress() &#123; return scaddress; &#125; public void setScaddress(String scaddress) &#123; this.scaddress = scaddress; &#125; @Override public String toString() &#123; return \"School [scname=\" + scname + \", scaddress=\" + scaddress + \"]\"; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/* Student.java */package com.orbit.el;public class Student &#123; private String sname; private int sno; private School school; public Student(String sname, int sno, School school) &#123; super(); this.sname = sname; this.sno = sno; this.school = school; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSno() &#123; return sno; &#125; public void setSno(int sno) &#123; this.sno = sno; &#125; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return \"Student [sname=\" + sname + \", sno=\" + sno + \", school=\" + school + \"]\"; &#125; &#125; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School school = new School(\"清华大学\",\"北京\"); Student student = new Student(\"杨小杨\",10001,school); pageContext.setAttribute(\"student\", student); %&gt; &lt;!-- 若访问对象为null，则EL也不会报空指针异常，显示结果为\" \" --&gt;&gt; student = $&#123;student1&#125; student = $&#123;student&#125;&lt;br/&gt; student.sname = $&#123;student.sname&#125;&lt;br/&gt; student.sname = $&#123;student['sname']&#125;&lt;br/&gt; student.sno = $&#123;student.sno&#125;&lt;br/&gt; student.sno = $&#123;student['sno']&#125;&lt;br/&gt; student.school = $&#123;student.school&#125;&lt;br/&gt; student.school.scname = $&#123;student.school.scname&#125;&lt;br/&gt; student.school.scaddress = $&#123;student.school.scaddress&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 获取数组 ${array[i]}创建一个数组，将这个数组加入到域属性空间，通过 ${array[i]} 可以访问该数组的第 i+1个元素。 1234567891011121314151617181920212223&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School[] schools = new School[3]; schools[0] = new School(\"清华大学\",\"中国北京\"); schools[1] = new School(\"北京大学\",\"中国北京\"); schools[2] = new School(\"厦门大学\",\"中国福建\"); pageContext.setAttribute(\"schools\", schools); %&gt; school[2] = $&#123;schools[0]&#125;&lt;br/&gt; school[2].address = $&#123;schools[2].scaddress&#125;&lt;br/&gt; &lt;!-- 数组下标超出上限，EL不会报越界异常 --&gt; school[3] = $&#123;schools[3]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ​ ​ 获取List中的元素 ${list[i]}访问list与访问数组的方式一致。 注意：set是无序的，其中的元素没有索引，因此无法用该种方式访问。 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; names[1] = $&#123;names[1]&#125;&lt;br/&gt; names[10] = $&#123;names[10]&#125;&lt;/body&gt;&lt;/html&gt; 获取Map中的元素 ${map.元素}123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"school\", new School(\"厦门大学\",\"中国福建\")); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- map.school是Object类型的，map.school.scname是默认Object型强转为School型 --&gt; $&#123;map.school.scname &#125;&lt;br/&gt; $&#123;map.name &#125;&lt;/body&gt;&lt;/html&gt; ​ EL常见运算符 序号 类别 运算符 1 算术运算符 + - * / % 2 关系运算符 &gt; &lt; == &gt;= &lt;= != 3 逻辑运算符 &amp;&amp;(and) ||(or) !(not) 4 条件运算符 ？ ： 5 取值运算符 . [ ] 6 empty运算符 empty empty的用法 empty判空，四大域中的元素符合以下条件时empty的运算结果为true： 没有定义的属性 值为null的引用 值为空串的String引用 没有元素的数组或集合 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String b = null; String c = \"\"; List&lt;String&gt; d = new ArrayList&lt;&gt;(); pageContext.setAttribute(\"b\", b); pageContext.setAttribute(\"c\", c); pageContext.setAttribute(\"d\", d); %&gt; empty a = $&#123;empty a&#125;&lt;br/&gt; empty b = $&#123;empty b&#125;&lt;br/&gt; empty c = $&#123;empty c&#125;&lt;br/&gt; empty d = $&#123;empty d&#125;&lt;/body&gt;&lt;/html&gt; EL内置对象 EL有11个内置对象，除了前面的和4个域属性空间相关的内置对象之外，还有7个。 EL的内置对象中，除了pageContext之外，其他内置对象的类型均为java.util.Map类型。 此处介绍常用的四个内置对象： pageContext 是不是有点熟悉？没错，EL的pageContext和JSP的pageContext是同一个对象。 可以获取到JSP的request、response、session、servletContext、servletConfig等对象 注意获取到的这些内置对象是JSP的，不是EL的，EL中没有这些内置对象。 如何在EL中使用pageContext获取到JSP的内置对象？ 例如，获取request内置对象——${pageContext.request} 其底层实际调用的方法为 pageContext.getRequest()，其他内置对象同理 常用内置对象的方法？ ${pageContext.request.contextPath()}，用来获取当前项目路径，一般用在JSP页面的路径中。 1234567&gt; &lt;body&gt;&gt; &lt;!-- 可读性差 --&gt;&gt; &lt;form action=\"register\"&gt;&lt;/form&gt; &gt; &lt;!-- 可读性好 --&gt;&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/register\"&gt;&lt;/form&gt;&gt; &lt;/body&gt;&gt; param ${param.parameter}`获取request域（请求）中的指定参数的值。 底层调用的是：request.getparameter() paramValues ${paramValues.parameter[i]}` :获取request域（请求）中指定参数的所有值。 底层调用的是：request.getparameterValues() initParam 获取初始化参数 底层调用的是servletContext.getInitParameter() 1234567891011121314151617181920212223&lt;!-- index.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/show.jsp\" &gt; 姓名：&lt;input type=\"text\" name=\"uname\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"uage\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"uhobby\" value=\"sing\"/&gt;唱 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"dancing\"/&gt;跳 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"rap\"/&gt;RAP &lt;input type=\"checkbox\" name=\"uhobby\" value=\"basketball\"/&gt;篮球&lt;br/&gt; &lt;input type=\"submit\"value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!-- show.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;param.uname&#125;&lt;br/&gt; 年龄：$&#123;param.uage&#125;&lt;br/&gt; 爱好：$&#123;paramValues.uhobby[0]&#125; &amp;nbsp; $&#123;paramValues.uhobby[1]&#125;&amp;nbsp; $&#123;paramValues.uhobby[2]&#125;&amp;nbsp; $&#123;paramValues.uhobby[3]&#125;&lt;br/&gt; 学校：$&#123;initParam.school&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;display-name&gt;02-EL&lt;/display-name&gt;&lt;context-param&gt; &lt;param-name&gt;school&lt;/param-name&gt; &lt;param-value&gt;清华大学&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; EL自定义函数 EL函数只能处理四大域中的属性值及常量 步骤：定义函数——定义标签库——注册函数——使用函数 12345678910//ELFunctions.javapackage com.orbit.el;public class ELFunctions &#123; //小写转大写 public static String LowertoUpper(String source) &#123; return source.toUpperCase(); &#125;&#125; 12345678910111213141516171819&lt;!-- myFt.tld --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 定义标签库信息 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myFt&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/el/functions&lt;/uri&gt; &lt;!-- 注册函数 --&gt; &lt;function&gt; &lt;name&gt;IsLowertoUpper&lt;/name&gt; &lt;function-class&gt;com.orbit.el.ELFunctions&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String LowertoUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 12345678910111213141516171819202122&lt;!-- index.jsp --&gt;&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/el/functions\" prefix=\"myFt\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用函数：处理常量 --&gt; $&#123;myFt:IsLowertoUpper(\"no one can stop me!\") &#125; &lt;!-- 使用函数：处理四大域中的属性 --&gt; &lt;% String name=\"Selena\"; pageContext.setAttribute(\"name\", name); %&gt; $&#123;myFt:IsLowertoUpper(name) &#125;&lt;/body&gt;&lt;/html&gt; JSTL中的EL函数​ JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache定义好的一套标准的标签库规范。 ​ JSTL中，定义了一套关于字符串处理的函数标签库，这个函数标签库中包含16个处理字符串的函数。 ​ 在JSP页面中导入jstl.jar ，standard.jar，就可以直接使用。 ​ 导入jar包 jstl.jar下载地址： http://repo2.maven.org/maven2/javax/servlet/jstl/ standard.jar下载地址： http://repo2.maven.org/maven2/taglibs/standard/ ​ 查看目录 ​ 使用函数 1234567891011121314&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:substring(\"abcdefg\",2,5) &#125; $&#123;fn:substringBefore(\"abcdefg\",\"cd\") &#125; $&#123;fn:substringAfter(\"abcdefg\",\"cd\"\") &#125;&lt;/body&gt;&lt;/html&gt; 对于EL做出的总结 EL不能出现在Java代码块、表达式块等JSP的动态代码部分 EL只能从四大域属性空间中获取数据（pageContext,request,session,application） EL不会抛出空指针异常，若访问一个null对象的属性，则什么也不显示 EL不会抛出数组访问越界异常，若访问一个数组中不存在的元素，则什么也不显示 EL本身无法对字符串进行处理，要想进行处理，可以通过EL自定义函数和JSTL中的EL函数来处理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"解决hexo显示不出本地图片问题","slug":"解决hexo显示不出本地图片问题","date":"2019-08-26T05:45:45.000Z","updated":"2019-08-27T15:26:08.966Z","comments":true,"path":"2019/08/26/解决hexo显示不出本地图片问题/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/解决hexo显示不出本地图片问题/","excerpt":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。","text":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹 1hexo new \"博客名\" 将想要上传的图片先保存在文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 使用hexo g部署，进入public\\2019\\08\\26\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2019/08/26/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"Servlet","slug":"Servlet","date":"2019-08-24T11:40:33.000Z","updated":"2019-08-26T09:26:49.702Z","comments":true,"path":"2019/08/24/Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/08/24/Servlet/","excerpt":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层","text":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层 2. Servlet的作用：用来接收客户端的请求数据，然后调用底层service处理数据并生成结果，返回一个响应给浏览器。 利用他可以实现业务层和表现层的分离，同时又可以生成动态页面。 3 . Servlet执行业务的步骤浏览器http请求——》tomcat服务器——-》到达servlet—–》执行doget，dopost方法—-》返回数据&lt;1&gt;客户端发送请求到服务器端&lt;2&gt;服务器将请求信息发送至Servlet&lt;3&gt;Servlet生成响应内容并将其传给服务器。&lt;4&gt;服务器将响应返回给客户端。 4. 创建Servlet的三种方式 定义一个类实现javax.servlet.Servlet接口 定义一个类继承javax.servet.GenericServlet类 定义一个类继承javax.servlet.http.HttpServlet类 web应用我们自然基本上都是继承HttpServlet 5. Servlet的生命周期（Servlet实例对象从创建到销毁的整个过程）​ Servlet的生命周期由一套定义良好的生命周期规则来约束管理 ​ 其中定义了Servlet如何被加载实例化和初始化,处理客户端请求,以及何时结束服务 ​ 生命周期方法有: ​ void init(ServletConfig)； ​ void service(ServletRequest,ServletResponse)； ​ void destroy()；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://cometorbityh.github.io/tags/Servlet/"}]}]}