{"meta":{"title":"MY","subtitle":"IT IS MY LIFE","description":"每一天都在进步...","author":"杨涵","url":"https://cometorbityh.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-24T06:54:16.000Z","updated":"2019-08-24T08:45:36.335Z","comments":true,"path":"categories/index.html","permalink":"https://cometorbityh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-24T06:54:02.000Z","updated":"2019-08-24T08:47:48.572Z","comments":true,"path":"tags/index.html","permalink":"https://cometorbityh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaWeb--ajax","slug":"JavaWeb-ajax","date":"2019-09-27T09:58:24.000Z","updated":"2019-09-29T01:58:04.581Z","comments":true,"path":"2019/09/27/JavaWeb-ajax/","link":"","permalink":"https://cometorbityh.github.io/2019/09/27/JavaWeb-ajax/","excerpt":"","text":"ajax简介1. 概念（1） Ajax ——【 Asynchronous JavaScript And XML 】【 异步的JavaScript和XML 】 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 （2）异步和同步的概念 ​ 同步：客户端给服务端发送请求，客户端必须等待服务器端的响应，在等待服务端处理请求的过程中，客户端无法进行其他操作； ​ 异步：客户端给服务端发送请求，客户端无需等待服务器端的响应，在等待服务端处理请求的过程中，客户端可以进行其他操作。 2. 实现方式（1）. 原生的JS实现方式（了解）XMLHttpRequest 用于在后台与服务器交换数据 XMLHttpRequest对象的2个方法： open方法的作用：建立连接。其参数： (1).请求方式(GET、POST) (2).请求的URL： 若请求方式为GET，则将请求参数拼接在URL后方，send方法为空参或null 若请求参数为POST，则将请求参数在send方法中定义 (3).是否为异步请求，true为异步，false为同步 send方法的作用：发送请求 XMLHttpRequest对象的2个属性： readyState（就绪状态）——存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status（响应状态码） 200: “OK” 404: 未找到页面 XMLHttpRequest对象的2个方法 open方法的作用：建立连接。 其参数:(1).请求方式(GET、POST)(2).请求的URL： ——若请求方式为GET，则将请求参数拼接在URL后方，send方法为空参或null ——请求参数为POST，则将请求参数在send方法中定义 (3).是否为异步请求，true为异步，false为同步 点击显/隐内容 点击显/隐内容 （2）. JQuery实现方式（掌握）（2.1）$.ajax( )（2.2）$.get( )#####（2.3）$post( )","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JavaWeb项目——学生管理系统","slug":"JavaWeb项目——学生管理系统","date":"2019-09-06T08:31:03.000Z","updated":"2019-09-06T08:35:23.962Z","comments":true,"path":"2019/09/06/JavaWeb项目——学生管理系统/","link":"","permalink":"https://cometorbityh.github.io/2019/09/06/JavaWeb项目——学生管理系统/","excerpt":"","text":"1. 创建数据库123456CREATE TABLE `t_stu` (`id` int(10) NOT NULL AUTO_INCREMENT ,`uname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`upwd` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,PRIMARY KEY (`id`)) 2. 创建JDBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBC &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); System.out.println(\"驱动注册成功\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); System.out.println(\"数据库连接成功\"); stmt = conn.createStatement(); System.out.println(\"连接对象创建成功\"); String sql = \"select * from t_stu\"; rs = stmt.executeQuery(sql); if(rs.next()) &#123; System.out.print(rs.getInt(\"id\")+\" \"); System.out.print(rs.getString(\"uname\") + \" \"); System.out.println(rs.getString(\"upwd\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"项目","slug":"项目","permalink":"https://cometorbityh.github.io/tags/项目/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-09-03T08:55:59.000Z","updated":"2019-09-29T01:47:26.070Z","comments":true,"path":"2019/09/03/JDBC/","link":"","permalink":"https://cometorbityh.github.io/2019/09/03/JDBC/","excerpt":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。","text":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。 一、JDBC编程6步 注册驱动（作用：告知Java程序，指明将要连接的数据库品牌） 获取连接（打开JVM的进程和数据库的进程之间的通道，属于进程之间的通信，使用完需要关闭） 获取数据库操作对象（专门执行sql语句的对象） 执行sql语句（DQL，DML） 处理查询指令集（只有当第四步执行的是select语句的时候，才需要第五步，否则省略） 释放资源（关闭JVM的进程和数据库的进程之间的通信资源） 二、JDBC的基本使用本例使用的是Mysql数据库，其驱动为mysql-connector-java-5.1.47.jar. 新建java project——在项目下新建文件夹lib——导入Mysql驱动jar包，右键jar包，点击build path,add 即可。 1. 使用Statement对数据库进行 “增删改” 操作点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.orbit.jdbc;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class test01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; // 1.注册驱动 //方式一// Driver driver = new com.mysql.jdbc.Driver();// Driver driver = new com.oracle.Driver.OracleDriver();// DriverManager.registerDriver(driver); //方式二(常用，原因是参数是字符串，字符串可以写到properties文件中，起到解耦合的作用) //该方法无需接收返回值，因为我们只想用它的类加载动作 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.获取连接 // oracle的URL： jdbc:oracle://localhost:1521:xxx String url = \"jdbc:mysql://localhost:3306/orbit\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); //com.mysql.jdbc.JDBC4Connection@3d646c37 System.out.println(conn); // 3.获取数据库操作对象（Statement专门执行sql语句） stmt = conn.createStatement(); // 4.执行sql (JDBC中的sql语句不需要分号结尾)// String sql = \"insert into dept(dno,dname,dage) values(2,'LS',23)\"; String sql = \"delete from dept where dno = 2\";// String sql = \"update dept set dname='王五',dage='20' where dno=1\"; // 专门执行DML语句的（insert，delete，update），返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); // 5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源，为了保证资源一定释放，必须放到finally语句中关闭资源 // 并且要遵循从小到大依次关闭，分别对其try...catch try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 点击显/隐内容 注册驱动的方式二为什么能够用放射直接调用？** ​ 因为mysql的驱动包中的com.mysql.jdbc包下的Driver.java的静态块中已经注册了驱动 2. 从属性配置文件中获取连接在src文件下新建file，输入”db.properties” db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/orbituser=rootpassword=123456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"insert into dept(dno,dname,dage) values(3,'娜可露露',22)\"; int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3. 使用Statement对数据库进行 “查” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"select dno,dname,dage from dept\"; rs = stmt.executeQuery(sql); System.out.println(rs); while(rs.next()) &#123; //该行有元素 int eno = rs.getInt(1); String ename = rs.getString(2); int eage = rs.getInt(3); //第二种写法：在getString中直接写入列名// String eno = rs.getString(\"dno\"); // String ename = rs.getString(\"dname\");// String eage = rs.getString(\"dage\"); System.out.println(eno +\" \" + ename + \" \" +eage); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4. 实例（设计登录界面，并解决SQL注入）这里使用到一个工具“PowerDesigner16.5”，用以物理建模，它与MySQL所不同的是，PowerDesigner用于设计阶段的物理建模，而MySQL用于开发阶段的数据处理。 123456789101112131415161718drop table if exists t_user;/*==============================================================*//* Table: t_user *//*==============================================================*/create table t_user( id bigint auto_increment, loginName varchar(255), loginPwd varchar(255), realName varchar(255), primary key (id));insert into t_user(loginName,loginPwd,realName) values('Zhangsan','123','张三');insert into t_user(loginName,loginPwd,realName) values('LiSi','123','李四');insert into t_user(loginName,loginPwd,realName) values('Wangwu','123','王五');commit;select * from t_user; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest02 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; Statement stmt = null; ResultSet rs = null; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql String sql = \"select * from t_user where loginName = '\"+loginName+\"' and loginPwd = '\"+loginPwd+\"'\"; //5、处理查询结果集 //发生sql语句给DBMS，DBMS进行sql编译 rs = stmt.executeQuery(sql); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 但是此时的程序存在一个安全问题，请看下面案例： 该现象称为“SQL注入”，这是一个安全隐患，是黑客入侵常用手段。 发生sql注入的原因是什么？ 用户输入的信息中含有sql的关键字，并且这些关键字拼接在sql语句中，参与sql语句的编译过程，导致sql语句原意被扭曲，进而引起sql注入。 如何解决SQL注入？ 只要用户提供的信息不参与SQL语句的编译过程，问题即可解决。 即便用户提供的信息中包含SQL的关键字，但这些关键字没有参与编译，就不会起作用 要想用户信息不参与SQL编译，需要用到java.sql.PreparedStatement PreparedStatement接口继承了java.sql.Statement，是预编译数据库操作对象(作用：编译、 ) 其原理为：预先对SQL语句的框架进行编译，然后再给SQL语句传值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest03 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、执行sql语句框架 // ?表示一个占位符，用来接收值。注意？不加单引号 String sql = \"select * from t_user where loginName = ? and loginPwd = ?\"; //4、获取预编译数据库操作对象 ps = conn.prepareStatement(sql); //给占位符传值，若为字符串，其传值方法为setString(下标，值)； JDBC的下标都是从1开始的 ps.setString(1,loginName); //将对应下标的？替换为'xxxx' ps.setString(2,loginPwd); // ps.setString(3,100); 将对应下标的？替换为100 //5、处理查询结果集 rs = ps.executeQuery(); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 比较Statement和PreparedStatement Statement存在注入问题，PreparedStatement可以解决SQL注入问题 Statement是编译一次执行一次，PreparedStatement是编译一次执行N次；（多次执行相同的sql语句时，DBMS只会编译一次就可以执行多次。Statement的sql语句中包含可变的参数，每次执行都要重新编译，PreparedStatement中sql语句占位符是固定的符号，只需编译一次即可执行多次） PreparedStatement会在编译阶段做类型的安全检查，如setString()方法中输入了int型字符，系统会报错。 因此，PreparedStatement使用场景较多。但需要sql注入时就要用到Statement 5.实例（Statement实现输入升序降序）升序降序用PreparedStatement传值给占位符？是不可行的，因为desc,asc都是字符串，传进入的话会加上引号，无法识别，因此需要用到Statement来实现输入升序降序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.*;import java.util.Scanner;public class JDBCTest04 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(\"输入asc/desc进行升序/降序：\"); String keyWord = sc.nextLine(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); stmt = conn.createStatement(); String sql = \"select loginName from t_user order by loginName \"+ keyWord; rs = stmt.executeQuery(sql); while (rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 6.使用PreparedStatement增删改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.jdbc;import java.sql.*;public class JDBCTest05 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\");// String sql = \"insert into t_user(loginName,loginPwd,realName) values(?,?,?)\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"ZhaoLiu\");// ps.setString(2,\"123\");// ps.setString(3,\"赵六\");// String sql = \"delete from t_user set loginName = ? ,realName = ? where id = ?\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"WangBa\");// ps.setString(2,\"王八\");// ps.setInt(3,4); String sql = \"delete from t_user where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1,4); int count = ps.executeUpdate(); System.out.println(count + \"行受影响\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 7. JDBC事务问题(模拟账户转账)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); //空指针异常，会导致程序中途停止运行 //导致用户10001丢失10000元，而用户10002也没收到10000元 String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解决方案(3行重要代码) conn.setAutoCommit(false); 禁用自动提交事务，开启事务 conn.commit(); 手动提交事务，即在此处才执行sql语句，事务结束 conn.rollback(); 回滚事务，回到事务发生之前数据，事务结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //禁用自动提交事务 conn.setAutoCommit(false); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); //手动提交事务 conn.commit(); &#125; catch (Exception e) &#123; if(conn != null)&#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 8.简化代码为工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.orbit.jdbc.DBUtil;import java.sql.*;public class DBUtil &#123; /*工具类的构造方法都是私有的， * 因为工具类的方法都是静态的，无需new对象，直接使用类名调用*/ private DBUtil()&#123;&#125; //静态代码块在类加载时执行，且只执行一次 //注册驱动只需要执行一次，因此放在静态代码块中 static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; //Statement ps面向抽象编程 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627package com.orbit.jdbc;import com.orbit.jdbc.utils.DBUtil;import java.sql.*;public class JDBCTest07 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = \"select loginName from t_user where loginName like ?\"; ps = conn.prepareStatement(sql); ps.setString(1,\"%g%\"); rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtil.close(conn,ps,rs); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/tags/JDBC/"}]},{"title":"JSP——系统开发模型","slug":"JSP——系统开发模型","date":"2019-08-31T06:51:33.000Z","updated":"2019-09-03T15:06:52.679Z","comments":true,"path":"2019/08/31/JSP——系统开发模型/","link":"","permalink":"https://cometorbityh.github.io/2019/08/31/JSP——系统开发模型/","excerpt":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构","text":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构 开发模型1. 纯JSP将所有业务处理、数据显示功能全都放在JSP页面完成。 缺点：代码结构乱，显示功能与业务处理功能代码没有划分，维护和升级麻烦。 2. JSP+JavaBean的Model1该开发模型将大多数业务处理交给专门的JavaBean完成。JSP页面主要负责数据显示功能。相对于“纯JSP”来说，已经得到极大改进。但是对于客户端的请求的解析，对于JavaBean对象的选择和创建，还是由JSP页面处理，即JSP还负责大量的请求解析、业务处理功能。 JavaBean的介绍 JavaBean 广义JavaBean，一般的Java类，主要功能：承载数据，业务处理 数据承载Bean：实体类，专门用于承载数据（装数据）的类，如User，Student 业务处理Bean：Service或Dao对象，专门用以处理用户提交请求的类。 狭义JavaBean：符合SUN公司提出的“JavaBean规范”的Java类。JavaBean规范规定，该类需满足以下四点： 公共，public class 实现Serializable接口 具备无参构造器 若有成员变量，则成员变量应该是私有的，且提供getter和setter 实际项目中，实体类（广义JavaBean的数据承载Bean）一般会被定义成满足“JavaBean规范”的狭义JavaBean 3. MVC的Model2MVC Model（模型），承载数据，并对用户的请求进行计算的模块。分为数据承载Bean和业务处理Bean，其实就是JavaBean。 View（视图），为用户提供使用界面，与用户进行直接交互 Controller（控制器），将请求转发给相应的Model进行处理，即选择使用哪一个JavaBean来处理请求。并提供Model的计算结果向用户进行相应的响应。 4. MVC + 三层架构三层架构 View层 / 视图层 / 表现层 / web层，编写用于接收用户请求的代码 Service层 / 服务层 / 业务层 / 逻辑层，编写系统的业务逻辑 Dao层 / 持久层 / 数据访问层，编写直接操作数据库的代码，Data Access Object数据访问对象 为了更好的降低各层之间的耦合度，在三层架构程序设计中，采用面向抽象编程，即上层对下层的调用是通过接口实现的。下层对上层的真正服务者，是下层接口的实现类，服务标准（接口）是相同的，服务提供者（实现类）可更换，这就实现了层间解耦合。 MVC + 三层架构 “MVC + 三层架构”开发模型，主要是指将MVC的业务处理Model分成了2层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。 “MVC + 三层架构”开发模型，是传统的JavaWeb项目最常用的开发模型。 实例：学生登录系统","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——JSTL","slug":"JSP——JSTL","date":"2019-08-30T08:22:01.000Z","updated":"2019-08-31T06:49:16.550Z","comments":true,"path":"2019/08/30/JSP——JSTL/","link":"","permalink":"https://cometorbityh.github.io/2019/08/30/JSP——JSTL/","excerpt":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。","text":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。 JSTL中定义了5个标签库： 核心标签库：主要用于完成基本逻辑运算 格式化标签库：主要用于完成日期、数字的格式化显示 EL函数标签库：定义了16个EL函数 SQL操作标签库：完成SQL操作，现已废弃不用，Java代码即可完全实现SQL操作 XML操作标签库：完成XML操作，现已废弃不用，Java代码即可完全实现XML操作 1 核心标签库（遍历数据等）12&lt;!-- 使用前先导入标签库 --&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; c:set——为指定变量赋值123456789101112131415161718192021222324252627282930313233package com.orbit.beans;public class Information &#123; private String uname; private String gender; public Information() &#123; // TODO Auto-generated constructor stub &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Information(String uname, String gender) &#123; super(); this.uname = uname; this.gender = gender; &#125; @Override public String toString() &#123; return \"Information [uname=\" + uname + \", gender=\" + gender + \"]\"; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:set 为域中的指定变量赋值 --------------- &lt;br/&gt; &lt;!-- var是变量名，value是变量值，scope是变量所在域，默认是pageContext --&gt; &lt;c:set var=\"name\" value=\"小明\" scope=\"session\"/&gt; name = $&#123;name &#125;&lt;br/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为域中的Bean对象的属性赋值 --------------- &lt;br/&gt; &lt;% Information info = new Information(); pageContext.setAttribute(\"info\", info); %&gt; &lt;!-- property表示属性名，value表示属性值，target表示属性的范围 --&gt; &lt;c:set value=\"小李\" property=\"uname\" target=\"$&#123;pageScope.info &#125;\"/&gt; &lt;c:set value=\"男\" property=\"gender\" target=\"$&#123;pageScope.info &#125;\"/&gt; info = $&#123;info&#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为Map的键值赋值 --------------- &lt;br/&gt; &lt;% Map &lt;String,Object&gt; map = new HashMap(); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- property表示指定key，value表示key的值，target表示key的范围 --&gt; &lt;c:set value=\"网龙\" property=\"company\" target=\"$&#123;pageScope.map&#125;\"/&gt; &lt;c:set value=\"福建\" property=\"place\" target=\"$&#123;pageScope.map&#125;\"/&gt; map = $&#123;map &#125;&lt;/body&gt;&lt;/html&gt; c:remove——删除域中的属性1234567891011121314151617181920212223242526272829&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:remove 删除指定域中的指定属性 --------------- &lt;br/&gt; &lt;c:set var=\"name\" value=\"page_name\"/&gt; &lt;c:set var=\"name\" value=\"req_name\" scope=\"request\"/&gt; &lt;c:set var=\"name\" value=\"ses_name\" scope=\"session\"/&gt; &lt;c:set var=\"name\" value=\"app_name\" scope=\"application\"/&gt; &lt;c:remove var=\"name\" scope=\"session\"/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:remove 删除所有域中的指定属性 --------------- &lt;br/&gt; &lt;c:remove var=\"name\" /&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; c:out1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"test1\" value=\"&lt;h2&gt;hello,java!&lt;/h2&gt;\"/&gt; &lt;!-- value中EL的变量未定义时，默认输出default的值 --&gt; &lt;!-- value会原样输出其值，若该值带有html标签，可用escapeXml对该值进行解析 --&gt; &lt;c:out value=\"$&#123;test1 &#125;\" default=\"Hello,jsp!\" escapeXml=\"false\"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value=\"$&#123;test2 &#125;\" default=\"Hello,jsp!\"&gt;&lt;/c:out&gt;&lt;/body&gt;&lt;/html&gt; c:catch——捕获异常对象1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:catch var=\"math\"&gt; &lt;% int i = 7 / 0; %&gt; &lt;/c:catch&gt; $&#123;math.message &#125;&lt;/body&gt;&lt;/html&gt; c:if（掌握）——条件判断1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"name\" value=\"熊大\"/&gt; &lt;c:if test=\"$&#123;name=='熊大' &#125;\"&gt; &lt;href a=\"#\"&gt;我是熊大&lt;/href&gt; &lt;/c:if&gt; &lt;/body&gt;&lt;/html&gt; c:choose（掌握）——条件判断123456789101112131415161718192021222324252627282930313233&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"pageno\" value=\"2\"/&gt;&lt;c:set var=\"totalpage\" value=\"3\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;totalpage == 1 &#125;\"&gt; 首页 上一页 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == 1 &#125;\"&gt; 首页 上一页 &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == totalpage &#125;\"&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach（掌握）——遍历&lt;c:forEach items=”${names }” var=”name” begin=”0” end=”9” step=”2”varStatus=”status” &gt; begin、end、step分别表示：起始序号，结束序号，跳跃步伐 varStatus属性定义了一个status名的对象作为varStatus的绑定值，该绑定值也就是status封装了当前遍历的状态。可以方便我们实现一些与行数相关的功能，如：奇数行、偶数行差异；最后一行特殊处理等等。先就varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=\"text/css\"&gt; .odd&#123; background-color: #F8E2D3; &#125; .even&#123; background-color: #D3EE66; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;------------ c:forEach 例1 ------------&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"喜羊羊\"); names.add(\"美羊羊\"); names.add(\"懒羊羊\"); names.add(\"沸羊羊\"); names.add(\"暖羊羊\"); names.add(\"慢羊羊\"); names.add(\"灰太狼\"); names.add(\"红太狼\"); names.add(\"小灰灰\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name，step步长 --&gt; &lt;c:forEach items=\"$&#123;names &#125;\" var=\"name\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/c:forEach&gt;------------ c:forEach 例2 ------------&lt;br/&gt; &lt;c:forEach var=\"num\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;num &#125; &lt;/c:forEach&gt; &lt;br/&gt; ------------ c:forEach 例3 ------------&lt;br/&gt;&lt;% List&lt;Information&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Information(\"张三\",\"男\")); persons.add(new Information(\"李四\",\"不详\")); persons.add(new Information(\"王五\",\"男\")); persons.add(new Information(\"赵六\",\"女\")); persons.add(new Information(\"田七\",\"女\")); persons.add(new Information(\"王八\",\"男\")); pageContext.setAttribute(\"persons\", persons); %&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;persons &#125;\" var=\"person\" varStatus=\"vs\"&gt; &lt;tr class=\"$&#123;vs.count % 2==0 ? 'even':'odd'&#125;\"&gt; &lt;td&gt;$&#123;vs.count &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.uname &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.gender &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2 格式化标签库fmt:formatDate——日期格式fmt:parseDatefmt:formatNumberfmt:parseNumber12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;---------- 格式化日期 ----------&lt;br/&gt; &lt;% Date now = new Date(); pageContext.setAttribute(\"now\", now); %&gt; now = $&#123;now &#125;&lt;br/&gt; now = &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\"/&gt;&lt;br/&gt; &lt;!-- 将结果保留在var属性中 --&gt; &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\" var=\"time\"/&gt; birthday = $&#123;time &#125;&lt;br/&gt;----------将字符串转换为日期 ----------&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\"/&gt;&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\" var=\"day\"/&gt; ay = $&#123;day &#125; &lt;br/&gt;---------- 格式化数字 ----------&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" groupingUsed=\"false\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxIntegerDigits=\"8\" minIntegerDigits=\"6\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxFractionDigits=\"6\" minFractionDigits=\"5\"/&gt;&lt;br/&gt; &lt;br/&gt;----------将字符串转换为数字 ----------&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\"/&gt;&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\" var=\"num\"/&gt; num + 1 = $&#123;num + 1&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——自定义标签","slug":"JSP——自定义标签","date":"2019-08-28T11:59:55.000Z","updated":"2019-08-30T08:49:28.154Z","comments":true,"path":"2019/08/28/JSP——自定义标签/","link":"","permalink":"https://cometorbityh.github.io/2019/08/28/JSP——自定义标签/","excerpt":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。","text":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。 自定义标签的步骤： 定义标签处理器——定义一个类，继承SimpleTagSupport类，重写doTag( )方法 注册标签库，注册标签 导入标签库，使用标签 下面举2个案例来说明自定义标签。 2 定义带标签体的自定义标签（使用无标签体的标签完成：输出客户端IP） （使用有标签体的标签完成：小写转大写） 2-1 定义标签处理器 一个标签对应着一个类的一段代码。 一个类要实现自定义标签的功能，需要该类实现一个接口：Javax.servlet.jsp.tagext.SimpleTag，该接口有5个需要实现的方法，此时该类被称为标签处理器类。 ​ 123456789101112131415161718192021222324252627package com.orbit.tag;import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：获取客户端IPpublic class ClientIPTag extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //获取PageContext对象 PageContext pc = (PageContext) this.getJspContext(); //获取请求对象 ServletRequest request = pc.getRequest(); //获取客户端IP String ClientIp = request.getRemoteAddr(); //获取标准输出流 JspWriter out = pc.getOut(); //将客户端IP写入到输出流中 out.print(ClientIp); &#125;&#125; 12345678910111213141516171819202122232425262728package com.orbit.tag;import java.io.IOException;import java.io.StringWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：小写转大写public class LowerToUpper extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //创建一个输出流，该流中的内容可以通过其toString()方法获取到文本形式 StringWriter sw = new StringWriter(); //获取标签体对象 JspFragment jspBody = this.getJspBody(); //将标签体内容写入到输出流中 jspBody.invoke(sw); //以文本形式获取到输出流中的内容 String content = sw.toString(); //小写变大写 content = content.toUpperCase(); //将文本写入到标准输出流并打印 this.getJspContext().getOut().print(content);; &#125;&#125; 2-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;!-- 注册标签 --&gt; &lt;tag&gt; &lt;name&gt;clientIP&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ClientIPTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;tag&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.LowerToUpper&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- empty:当前标签没有标签体 scriptless:当前标签有标签体，但该标签中不能出现Java脚本，可以出现EL表达式 jsp:(已过时)，当前标签具有标签体，标签体内容原样显示到浏览器 tagdependent:当前标签有标签体，标签体内容原样显示到浏览器，即使是EL也一样 --&gt;&lt;/taglib&gt; 2-3 导入标签库，使用标签123456789101112131415161718192021222324252627&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用Java代码块获取IP --&gt; &lt;% String ip = request.getRemoteAddr(); out.println(\"ip = \" + ip); %&gt;&lt;br/&gt; &lt;!-- 使用无标签体的自定义标签获取IP --&gt; ip = &lt;tag:clientIP/&gt;&lt;br/&gt; &lt;!-- 使用有标签体的自定义标签完成小写转大写 --&gt; &lt;% String s = \"abc\"; pageContext.setAttribute(\"s\", s); %&gt; &lt;tag:LowerToUpper&gt;$&#123;s&#125;&lt;/tag:LowerToUpper&gt;&lt;br/&gt; &lt;tag:LowerToUpper&gt;are you kidding me?&lt;/tag:LowerToUpper&gt; &lt;/body&gt;&lt;/html&gt; 2-4 输出结果 3 定义带属性的自定义标签3-1 定义标签处理器1234567891011121314151617181920212223242526272829package com.orbit.tag;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;public class IfTag extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; if(test) &#123;// //获取标签体对象// JspFragment jspBody = this.getJspBody();// //将标签体加入到输出流// jspBody.invoke(this.getJspContext().getOut()); //invoke(null)等价于invoke(this.getJspContext().getOut()) this.getJspBody().invoke(null); &#125; &#125;&#125; 3-2 定义标签库，注册标签12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.IfTag&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 标签的属性 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性名 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true表示调用该标签时，必须要写该属性 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- runtime expression value运行时表达式值，true表示该属性的值支持EL与JSP表达式 --&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 3-3 导入标签库，使用标签123456789101112131415161718192021&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用带属性的自定义标签 --&gt; &lt;% boolean gender = true; pageContext.setAttribute(\"gender\", gender); %&gt; &lt;tag:if test=\"$&#123;gender &#125;\"&gt;男&lt;/tag:if&gt; &lt;tag:if test=\"$&#123;not gender &#125;\"&gt;女&lt;/tag:if&gt; &lt;/body&gt;&lt;/html&gt; #### 3-4 输出结果 4 自定义遍历List集合的forEachList标签4-1 定义标签处理器123456789101112131415161718192021222324252627282930package com.orbit.tag;import java.io.IOException;import java.util.List;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachListTag extends SimpleTagSupport&#123; private List items; private String var; //var代表当前对象要放入域中的属性名 public void setItems(List items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; for (Object obj : items) &#123; //EL只能处理四大域中的数据，因此将该遍历对象放入到四大域中 //key为var指定的名称（name）,value为当前遍历对象obj this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 4-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEachList&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachListTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 4-3 导入标签库，使用标签12345678910111213141516171819202122232425&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自定义标签 --&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEachList items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEachList&gt; &lt;/body&gt;&lt;/html&gt; 4-4 输出结果 5 自定义遍历集合和数组的forEach标签5-1 定义标签处理器(方法一) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.orbit.tag;import java.io.IOException;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; //判断items的类型 if(items instanceof List) &#123; List itemsList = (List) items; for (Object obj : itemsList) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Set) &#123; Set itemsSet = (Set) items; for (Object obj : itemsSet) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Map) &#123; Map itemsMap = (Map) items; for (Object obj : itemsMap.entrySet()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Object[]) &#123; Object[] itemsObject = (Object[]) items; for (Object obj : itemsObject) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125; &#125;&#125; （方法二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.tag;import java.io.IOException;import java.lang.reflect.Array;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var;// private Collection coll; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; public Collection getColl() &#123; if(items instanceof List) &#123; return (List) items; &#125;else if(items instanceof Set) &#123; return (Set) items; &#125;else if(items instanceof Map) &#123; return ((Map) items).entrySet(); &#125; /*该方法只能遍历非基本数据类型的数组*/// else if(items instanceof Object[]) &#123;// //将items强转为数组，数组再转为List集合（因为返回值是集合类型）// return Arrays.asList((Object[])items);// &#125; /*该方法能遍历任何数组*/ else if(items.getClass().isArray()) &#123; List nums = new ArrayList(); for(int i =0;i&lt;Array.getLength(items);i++) &#123; nums.add(Array.get(items, i)); &#125; return nums; &#125; return null; &#125; @Override public void doTag() throws JspException, IOException &#123; //遍历getColl()的返回值 for (Object obj : getColl()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 5-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEach&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 5-3 导入标签库，使用标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ===========遍历List===========&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEach items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Set===========&lt;br/&gt; &lt;% Set&lt;String&gt; cities = new HashSet&lt;&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"广州\"); pageContext.setAttribute(\"cities\", cities); %&gt; &lt;tag:forEach items=\"$&#123;cities &#125;\" var=\"city\"&gt; $&#123;city &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Map===========&lt;br/&gt; &lt;% Map&lt;String,Object&gt; infos = new HashMap&lt;&gt;(); infos.put(\"name\", \"张三\"); infos.put(\"age\", 24); infos.put(\"gender\", \"男\"); pageContext.setAttribute(\"infos\", infos); %&gt; &lt;tag:forEach items=\"$&#123;infos &#125;\" var=\"info\"&gt; $&#123;info &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型的数组===========&lt;br/&gt; &lt;% Object[] objs = &#123;\"元素1\",\"元素2\",\"元素3\"&#125;; pageContext.setAttribute(\"objs\", objs); %&gt; &lt;tag:forEach items=\"$&#123;objs &#125;\" var=\"obj\"&gt; $&#123;obj &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型及数据类型的数组===========&lt;br/&gt; &lt;% int[] ages = &#123;11,12,13&#125;; pageContext.setAttribute(\"ages\", ages); %&gt; &lt;tag:forEach items=\"$&#123;ages &#125;\" var=\"age\"&gt; $&#123;age &#125; &lt;br/&gt;&lt;/tag:forEach&gt; &lt;/body&gt;&lt;/html&gt; 5-4 输出结果 6 将自定义标签库打包发行右击项目名——Export——搜索JARfile——勾选需要打包的包名，其他的取消勾选，选择保存位置，命名为xxx.jar——将对应的tld文件复制到xxx.jar中的META-INF文件夹中——需要时导入即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"Next主题格式配置记录","slug":"Next主题格式配置记录","date":"2019-08-27T15:23:14.000Z","updated":"2019-08-27T15:48:58.046Z","comments":true,"path":"2019/08/27/Next主题格式配置记录/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/Next主题格式配置记录/","excerpt":"文章背景色","text":"文章背景色","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://cometorbityh.github.io/tags/next/"}]},{"title":"使用PicGo + 七牛云 快速创建图床","slug":"使用PicGo-七牛云-快速创建图床","date":"2019-08-27T12:04:12.000Z","updated":"2019-08-27T15:25:44.190Z","comments":true,"path":"2019/08/27/使用PicGo-七牛云-快速创建图床/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/使用PicGo-七牛云-快速创建图床/","excerpt":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。","text":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。 注册七牛云账号（https://www.qiniu.com/），并完成实名认证。 创建存储空间 下载并安装PicGo（https://github.com/Molunerfinn/PicGo/releases） 七牛图床设置 上传图片","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"JSP——EL表达式","slug":"JSP——EL表达式","date":"2019-08-26T06:14:53.000Z","updated":"2019-08-31T07:19:51.261Z","comments":true,"path":"2019/08/26/JSP——EL表达式/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/JSP——EL表达式/","excerpt":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值","text":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值 使用EL获取数据 从四大域中获取数据EL只能获取到四大域中的数据，因此要获取到某个数据，需要将其加入到某个域中，再使用EL表达式获取数据。 从四大域中依次查找数据 ${属性}EL01.jsp 12345678910&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;name&#125; &lt;/body&gt; 输出结果为page域的属性值（最小的域） 从指定域中获取数据 ${域scope.属性}依次从四大域查找属性效率过低，为了提高效率，我们应该想想如何从指定域中直接获取某个属性值。 EL有4个域属性空间相关的内置对象，分别为pageScope，requestScope，sessionScope，applicationScope。表示从对应域属性空间中查找指定key。 1234567891011121314&lt;!-- EL01.jsp --&gt;&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;pageScope.name&#125;&lt;br/&gt; name = $&#123;requestScope.name&#125;&lt;br/&gt; name = $&#123;sessionScope.name&#125;&lt;br/&gt; name = $&#123;applicationScope.name&#125;&lt;br/&gt;&lt;/body&gt; 获取Bean的属性 ${key.属性}创建一个Bean的对象，将这个Bean对象加入到域属性空间中，通过 ${key.属性} 可以访问该对象的属性值。 注意：若访问对象为null，则EL也不会报空指针异常，显示结果为”” 12345678910111213141516171819202122232425262728293031/* School.java */package com.orbit.el;public class School &#123; private String scname; private String scaddress; public School(String scname, String scaddress) &#123; super(); this.scname = scname; this.scaddress = scaddress; &#125; public String getScname() &#123; return scname; &#125; public void setScname(String scname) &#123; this.scname = scname; &#125; public String getScaddress() &#123; return scaddress; &#125; public void setScaddress(String scaddress) &#123; this.scaddress = scaddress; &#125; @Override public String toString() &#123; return \"School [scname=\" + scname + \", scaddress=\" + scaddress + \"]\"; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/* Student.java */package com.orbit.el;public class Student &#123; private String sname; private int sno; private School school; public Student(String sname, int sno, School school) &#123; super(); this.sname = sname; this.sno = sno; this.school = school; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSno() &#123; return sno; &#125; public void setSno(int sno) &#123; this.sno = sno; &#125; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return \"Student [sname=\" + sname + \", sno=\" + sno + \", school=\" + school + \"]\"; &#125; &#125; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School school = new School(\"清华大学\",\"北京\"); Student student = new Student(\"杨小杨\",10001,school); pageContext.setAttribute(\"student\", student); %&gt; &lt;!-- 若访问对象为null，则EL也不会报空指针异常，显示结果为\" \" --&gt;&gt; student = $&#123;student1&#125; student = $&#123;student&#125;&lt;br/&gt; student.sname = $&#123;student.sname&#125;&lt;br/&gt; student.sname = $&#123;student['sname']&#125;&lt;br/&gt; student.sno = $&#123;student.sno&#125;&lt;br/&gt; student.sno = $&#123;student['sno']&#125;&lt;br/&gt; student.school = $&#123;student.school&#125;&lt;br/&gt; student.school.scname = $&#123;student.school.scname&#125;&lt;br/&gt; student.school.scaddress = $&#123;student.school.scaddress&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 获取数组 ${array[i]}创建一个数组，将这个数组加入到域属性空间，通过 ${array[i]} 可以访问该数组的第 i+1个元素。 1234567891011121314151617181920212223&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School[] schools = new School[3]; schools[0] = new School(\"清华大学\",\"中国北京\"); schools[1] = new School(\"北京大学\",\"中国北京\"); schools[2] = new School(\"厦门大学\",\"中国福建\"); pageContext.setAttribute(\"schools\", schools); %&gt; school[2] = $&#123;schools[0]&#125;&lt;br/&gt; school[2].address = $&#123;schools[2].scaddress&#125;&lt;br/&gt; &lt;!-- 数组下标超出上限，EL不会报越界异常 --&gt; school[3] = $&#123;schools[3]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ​ ​ 获取List中的元素 ${list[i]}访问list与访问数组的方式一致。 注意：set是无序的，其中的元素没有索引，因此无法用该种方式访问。 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; names[1] = $&#123;names[1]&#125;&lt;br/&gt; names[10] = $&#123;names[10]&#125;&lt;/body&gt;&lt;/html&gt; 获取Map中的元素 ${map.元素}123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"school\", new School(\"厦门大学\",\"中国福建\")); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- map.school是Object类型的，map.school.scname是默认Object型强转为School型 --&gt; $&#123;map.school.scname &#125;&lt;br/&gt; $&#123;map.name &#125;&lt;/body&gt;&lt;/html&gt; ​ EL常见运算符 序号 类别 运算符 1 算术运算符 + - * / % 2 关系运算符 &gt; &lt; == &gt;= &lt;= != 3 逻辑运算符 &amp;&amp;(and) ||(or) !(not) 4 条件运算符 ？ ： 5 取值运算符 . [ ] 6 empty运算符 empty empty的用法 empty判空，四大域中的元素符合以下条件时empty的运算结果为true： 没有定义的属性 值为null的引用 值为空串的String引用 没有元素的数组或集合 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String b = null; String c = \"\"; List&lt;String&gt; d = new ArrayList&lt;&gt;(); pageContext.setAttribute(\"b\", b); pageContext.setAttribute(\"c\", c); pageContext.setAttribute(\"d\", d); %&gt; empty a = $&#123;empty a&#125;&lt;br/&gt; empty b = $&#123;empty b&#125;&lt;br/&gt; empty c = $&#123;empty c&#125;&lt;br/&gt; empty d = $&#123;empty d&#125;&lt;/body&gt;&lt;/html&gt; EL内置对象 EL有11个内置对象，除了前面的和4个域属性空间相关的内置对象之外，还有7个。 EL的内置对象中，除了pageContext之外，其他内置对象的类型均为java.util.Map类型。 此处介绍常用的四个内置对象： pageContext 是不是有点熟悉？没错，EL的pageContext和JSP的pageContext是同一个对象。 可以获取到JSP的request、response、session、servletContext、servletConfig等对象 注意获取到的这些内置对象是JSP的，不是EL的，EL中没有这些内置对象。 如何在EL中使用pageContext获取到JSP的内置对象？ 例如，获取request内置对象——${pageContext.request} 其底层实际调用的方法为 pageContext.getRequest()，其他内置对象同理 常用内置对象的方法？ ${pageContext.request.contextPath()}，用来获取当前项目路径，一般用在JSP页面的路径中。 1234567&gt; &lt;body&gt;&gt; &lt;!-- 可读性差 --&gt;&gt; &lt;form action=\"register\"&gt;&lt;/form&gt; &gt; &lt;!-- 可读性好 --&gt;&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/register\"&gt;&lt;/form&gt;&gt; &lt;/body&gt;&gt; param ${param.parameter}`获取request域（请求）中的指定参数的值。 底层调用的是：request.getparameter() paramValues ${paramValues.parameter[i]}` :获取request域（请求）中指定参数的所有值。 底层调用的是：request.getparameterValues() initParam 获取初始化参数 底层调用的是servletContext.getInitParameter() 1234567891011121314151617181920212223&lt;!-- index.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/show.jsp\" &gt; 姓名：&lt;input type=\"text\" name=\"uname\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"uage\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"uhobby\" value=\"sing\"/&gt;唱 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"dancing\"/&gt;跳 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"rap\"/&gt;RAP &lt;input type=\"checkbox\" name=\"uhobby\" value=\"basketball\"/&gt;篮球&lt;br/&gt; &lt;input type=\"submit\"value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!-- show.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;param.uname&#125;&lt;br/&gt; 年龄：$&#123;param.uage&#125;&lt;br/&gt; 爱好：$&#123;paramValues.uhobby[0]&#125; &amp;nbsp; $&#123;paramValues.uhobby[1]&#125;&amp;nbsp; $&#123;paramValues.uhobby[2]&#125;&amp;nbsp; $&#123;paramValues.uhobby[3]&#125;&lt;br/&gt; 学校：$&#123;initParam.school&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;display-name&gt;02-EL&lt;/display-name&gt;&lt;context-param&gt; &lt;param-name&gt;school&lt;/param-name&gt; &lt;param-value&gt;清华大学&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; EL自定义函数 EL函数只能处理四大域中的属性值及常量 步骤：定义函数——定义标签库——注册函数——使用函数 12345678910//ELFunctions.javapackage com.orbit.el;public class ELFunctions &#123; //小写转大写 public static String LowertoUpper(String source) &#123; return source.toUpperCase(); &#125;&#125; 12345678910111213141516171819&lt;!-- myFt.tld --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 定义标签库信息 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myFt&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/el/functions&lt;/uri&gt; &lt;!-- 注册函数 --&gt; &lt;function&gt; &lt;name&gt;IsLowertoUpper&lt;/name&gt; &lt;function-class&gt;com.orbit.el.ELFunctions&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String LowertoUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 12345678910111213141516171819202122&lt;!-- index.jsp --&gt;&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/el/functions\" prefix=\"myFt\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用函数：处理常量 --&gt; $&#123;myFt:IsLowertoUpper(\"no one can stop me!\") &#125; &lt;!-- 使用函数：处理四大域中的属性 --&gt; &lt;% String name=\"Selena\"; pageContext.setAttribute(\"name\", name); %&gt; $&#123;myFt:IsLowertoUpper(name) &#125;&lt;/body&gt;&lt;/html&gt; JSTL中的EL函数​ JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache定义好的一套标准的标签库规范。 ​ JSTL中，定义了一套关于字符串处理的函数标签库，这个函数标签库中包含16个处理字符串的函数。 ​ 在JSP页面中导入jstl.jar ，standard.jar，就可以直接使用。 ​ 导入jar包 jstl.jar下载地址： http://repo2.maven.org/maven2/javax/servlet/jstl/ standard.jar下载地址： http://repo2.maven.org/maven2/taglibs/standard/ ​ 查看目录 ​ 使用函数 1234567891011121314&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:substring(\"abcdefg\",2,5) &#125; $&#123;fn:substringBefore(\"abcdefg\",\"cd\") &#125; $&#123;fn:substringAfter(\"abcdefg\",\"cd\"\") &#125;&lt;/body&gt;&lt;/html&gt; 对于EL做出的总结 EL不能出现在Java代码块、表达式块等JSP的动态代码部分 EL只能从四大域属性空间中获取数据（pageContext,request,session,application） EL不会抛出空指针异常，若访问一个null对象的属性，则什么也不显示 EL不会抛出数组访问越界异常，若访问一个数组中不存在的元素，则什么也不显示 EL本身无法对字符串进行处理，要想进行处理，可以通过EL自定义函数和JSTL中的EL函数来处理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"解决hexo显示不出本地图片问题","slug":"解决hexo显示不出本地图片问题","date":"2019-08-26T05:45:45.000Z","updated":"2019-08-27T15:26:08.966Z","comments":true,"path":"2019/08/26/解决hexo显示不出本地图片问题/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/解决hexo显示不出本地图片问题/","excerpt":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。","text":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹 1hexo new \"博客名\" 将想要上传的图片先保存在文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 使用hexo g部署，进入public\\2019\\08\\26\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2019/08/26/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"Servlet","slug":"Servlet","date":"2019-08-24T11:40:33.000Z","updated":"2019-08-26T09:26:49.702Z","comments":true,"path":"2019/08/24/Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/08/24/Servlet/","excerpt":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层","text":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层 2. Servlet的作用：用来接收客户端的请求数据，然后调用底层service处理数据并生成结果，返回一个响应给浏览器。 利用他可以实现业务层和表现层的分离，同时又可以生成动态页面。 3 . Servlet执行业务的步骤浏览器http请求——》tomcat服务器——-》到达servlet—–》执行doget，dopost方法—-》返回数据&lt;1&gt;客户端发送请求到服务器端&lt;2&gt;服务器将请求信息发送至Servlet&lt;3&gt;Servlet生成响应内容并将其传给服务器。&lt;4&gt;服务器将响应返回给客户端。 4. 创建Servlet的三种方式 定义一个类实现javax.servlet.Servlet接口 定义一个类继承javax.servet.GenericServlet类 定义一个类继承javax.servlet.http.HttpServlet类 web应用我们自然基本上都是继承HttpServlet 5. Servlet的生命周期（Servlet实例对象从创建到销毁的整个过程）​ Servlet的生命周期由一套定义良好的生命周期规则来约束管理 ​ 其中定义了Servlet如何被加载实例化和初始化,处理客户端请求,以及何时结束服务 ​ 生命周期方法有: ​ void init(ServletConfig)； ​ void service(ServletRequest,ServletResponse)； ​ void destroy()；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://cometorbityh.github.io/tags/Servlet/"}]}]}