{"meta":{"title":"Young Blog","subtitle":"一只在学习中不断成长的小白","description":"每一天都在进步...","author":"杨涵","url":"https://cometorbityh.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-24T06:54:16.000Z","updated":"2019-08-24T08:45:36.335Z","comments":true,"path":"categories/index.html","permalink":"https://cometorbityh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-24T06:54:02.000Z","updated":"2019-08-24T08:47:48.572Z","comments":true,"path":"tags/index.html","permalink":"https://cometorbityh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JSP——JSTL","slug":"JSP——JSTL","date":"2019-08-30T08:22:01.000Z","updated":"2019-08-30T08:43:22.933Z","comments":true,"path":"2019/08/30/JSP——JSTL/","link":"","permalink":"https://cometorbityh.github.io/2019/08/30/JSP——JSTL/","excerpt":"","text":"核心标签库格式化标签库格式化标签库c:setc:removec:outc:catchc:ifc:choosec:forEach## ## ## #### ## #### 3 EL函数标签库4 XML操作标签库5 SQL操作标签库","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——自定义标签","slug":"JSP——自定义标签","date":"2019-08-28T11:59:55.000Z","updated":"2019-08-30T08:49:28.154Z","comments":true,"path":"2019/08/28/JSP——自定义标签/","link":"","permalink":"https://cometorbityh.github.io/2019/08/28/JSP——自定义标签/","excerpt":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。","text":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。 自定义标签的步骤： 定义标签处理器——定义一个类，继承SimpleTagSupport类，重写doTag( )方法 注册标签库，注册标签 导入标签库，使用标签 下面举2个案例来说明自定义标签。 2 定义带标签体的自定义标签（使用无标签体的标签完成：输出客户端IP） （使用有标签体的标签完成：小写转大写） 2-1 定义标签处理器 一个标签对应着一个类的一段代码。 一个类要实现自定义标签的功能，需要该类实现一个接口：Javax.servlet.jsp.tagext.SimpleTag，该接口有5个需要实现的方法，此时该类被称为标签处理器类。 ​ 123456789101112131415161718192021222324252627package com.orbit.tag;import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：获取客户端IPpublic class ClientIPTag extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //获取PageContext对象 PageContext pc = (PageContext) this.getJspContext(); //获取请求对象 ServletRequest request = pc.getRequest(); //获取客户端IP String ClientIp = request.getRemoteAddr(); //获取标准输出流 JspWriter out = pc.getOut(); //将客户端IP写入到输出流中 out.print(ClientIp); &#125;&#125; 12345678910111213141516171819202122232425262728package com.orbit.tag;import java.io.IOException;import java.io.StringWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：小写转大写public class LowerToUpper extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //创建一个输出流，该流中的内容可以通过其toString()方法获取到文本形式 StringWriter sw = new StringWriter(); //获取标签体对象 JspFragment jspBody = this.getJspBody(); //将标签体内容写入到输出流中 jspBody.invoke(sw); //以文本形式获取到输出流中的内容 String content = sw.toString(); //小写变大写 content = content.toUpperCase(); //将文本写入到标准输出流并打印 this.getJspContext().getOut().print(content);; &#125;&#125; 2-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;!-- 注册标签 --&gt; &lt;tag&gt; &lt;name&gt;clientIP&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ClientIPTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;tag&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.LowerToUpper&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- empty:当前标签没有标签体 scriptless:当前标签有标签体，但该标签中不能出现Java脚本，可以出现EL表达式 jsp:(已过时)，当前标签具有标签体，标签体内容原样显示到浏览器 tagdependent:当前标签有标签体，标签体内容原样显示到浏览器，即使是EL也一样 --&gt;&lt;/taglib&gt; 2-3 导入标签库，使用标签123456789101112131415161718192021222324252627&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用Java代码块获取IP --&gt; &lt;% String ip = request.getRemoteAddr(); out.println(\"ip = \" + ip); %&gt;&lt;br/&gt; &lt;!-- 使用无标签体的自定义标签获取IP --&gt; ip = &lt;tag:clientIP/&gt;&lt;br/&gt; &lt;!-- 使用有标签体的自定义标签完成小写转大写 --&gt; &lt;% String s = \"abc\"; pageContext.setAttribute(\"s\", s); %&gt; &lt;tag:LowerToUpper&gt;$&#123;s&#125;&lt;/tag:LowerToUpper&gt;&lt;br/&gt; &lt;tag:LowerToUpper&gt;are you kidding me?&lt;/tag:LowerToUpper&gt; &lt;/body&gt;&lt;/html&gt; 2-4 输出结果 3 定义带属性的自定义标签3-1 定义标签处理器1234567891011121314151617181920212223242526272829package com.orbit.tag;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;public class IfTag extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; if(test) &#123;// //获取标签体对象// JspFragment jspBody = this.getJspBody();// //将标签体加入到输出流// jspBody.invoke(this.getJspContext().getOut()); //invoke(null)等价于invoke(this.getJspContext().getOut()) this.getJspBody().invoke(null); &#125; &#125;&#125; 3-2 定义标签库，注册标签12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.IfTag&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 标签的属性 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性名 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true表示调用该标签时，必须要写该属性 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- runtime expression value运行时表达式值，true表示该属性的值支持EL与JSP表达式 --&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 3-3 导入标签库，使用标签123456789101112131415161718192021&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用带属性的自定义标签 --&gt; &lt;% boolean gender = true; pageContext.setAttribute(\"gender\", gender); %&gt; &lt;tag:if test=\"$&#123;gender &#125;\"&gt;男&lt;/tag:if&gt; &lt;tag:if test=\"$&#123;not gender &#125;\"&gt;女&lt;/tag:if&gt; &lt;/body&gt;&lt;/html&gt; #### 3-4 输出结果 4 自定义遍历List集合的forEachList标签4-1 定义标签处理器123456789101112131415161718192021222324252627282930package com.orbit.tag;import java.io.IOException;import java.util.List;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachListTag extends SimpleTagSupport&#123; private List items; private String var; //var代表当前对象要放入域中的属性名 public void setItems(List items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; for (Object obj : items) &#123; //EL只能处理四大域中的数据，因此将该遍历对象放入到四大域中 //key为var指定的名称（name）,value为当前遍历对象obj this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 4-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEachList&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachListTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 4-3 导入标签库，使用标签12345678910111213141516171819202122232425&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自定义标签 --&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEachList items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEachList&gt; &lt;/body&gt;&lt;/html&gt; 4-4 输出结果 5 自定义遍历集合和数组的forEach标签5-1 定义标签处理器(方法一) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.orbit.tag;import java.io.IOException;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; //判断items的类型 if(items instanceof List) &#123; List itemsList = (List) items; for (Object obj : itemsList) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Set) &#123; Set itemsSet = (Set) items; for (Object obj : itemsSet) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Map) &#123; Map itemsMap = (Map) items; for (Object obj : itemsMap.entrySet()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Object[]) &#123; Object[] itemsObject = (Object[]) items; for (Object obj : itemsObject) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125; &#125;&#125; （方法二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.tag;import java.io.IOException;import java.lang.reflect.Array;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var;// private Collection coll; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; public Collection getColl() &#123; if(items instanceof List) &#123; return (List) items; &#125;else if(items instanceof Set) &#123; return (Set) items; &#125;else if(items instanceof Map) &#123; return ((Map) items).entrySet(); &#125; /*该方法只能遍历非基本数据类型的数组*/// else if(items instanceof Object[]) &#123;// //将items强转为数组，数组再转为List集合（因为返回值是集合类型）// return Arrays.asList((Object[])items);// &#125; /*该方法能遍历任何数组*/ else if(items.getClass().isArray()) &#123; List nums = new ArrayList(); for(int i =0;i&lt;Array.getLength(items);i++) &#123; nums.add(Array.get(items, i)); &#125; return nums; &#125; return null; &#125; @Override public void doTag() throws JspException, IOException &#123; //遍历getColl()的返回值 for (Object obj : getColl()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 5-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEach&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 5-3 导入标签库，使用标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ===========遍历List===========&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEach items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Set===========&lt;br/&gt; &lt;% Set&lt;String&gt; cities = new HashSet&lt;&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"广州\"); pageContext.setAttribute(\"cities\", cities); %&gt; &lt;tag:forEach items=\"$&#123;cities &#125;\" var=\"city\"&gt; $&#123;city &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Map===========&lt;br/&gt; &lt;% Map&lt;String,Object&gt; infos = new HashMap&lt;&gt;(); infos.put(\"name\", \"张三\"); infos.put(\"age\", 24); infos.put(\"gender\", \"男\"); pageContext.setAttribute(\"infos\", infos); %&gt; &lt;tag:forEach items=\"$&#123;infos &#125;\" var=\"info\"&gt; $&#123;info &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型的数组===========&lt;br/&gt; &lt;% Object[] objs = &#123;\"元素1\",\"元素2\",\"元素3\"&#125;; pageContext.setAttribute(\"objs\", objs); %&gt; &lt;tag:forEach items=\"$&#123;objs &#125;\" var=\"obj\"&gt; $&#123;obj &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型及数据类型的数组===========&lt;br/&gt; &lt;% int[] ages = &#123;11,12,13&#125;; pageContext.setAttribute(\"ages\", ages); %&gt; &lt;tag:forEach items=\"$&#123;ages &#125;\" var=\"age\"&gt; $&#123;age &#125; &lt;br/&gt;&lt;/tag:forEach&gt; &lt;/body&gt;&lt;/html&gt; 5-4 输出结果 6 将自定义标签库打包发行右击项目名——Export——搜索JARfile——勾选需要打包的包名，其他的取消勾选，选择保存位置，命名为xxx.jar——将对应的tld文件复制到xxx.jar中的META-INF文件夹中——需要时导入即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"Next主题格式配置记录","slug":"Next主题格式配置记录","date":"2019-08-27T15:23:14.000Z","updated":"2019-08-27T15:48:58.046Z","comments":true,"path":"2019/08/27/Next主题格式配置记录/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/Next主题格式配置记录/","excerpt":"文章背景色","text":"文章背景色","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://cometorbityh.github.io/tags/next/"}]},{"title":"使用PicGo + 七牛云 快速创建图床","slug":"使用PicGo-七牛云-快速创建图床","date":"2019-08-27T12:04:12.000Z","updated":"2019-08-27T15:25:44.190Z","comments":true,"path":"2019/08/27/使用PicGo-七牛云-快速创建图床/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/使用PicGo-七牛云-快速创建图床/","excerpt":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。","text":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。 注册七牛云账号（https://www.qiniu.com/），并完成实名认证。 创建存储空间 下载并安装PicGo（https://github.com/Molunerfinn/PicGo/releases） 七牛图床设置 上传图片","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"JSP——EL表达式","slug":"JSP——EL表达式","date":"2019-08-26T06:14:53.000Z","updated":"2019-08-28T11:52:57.797Z","comments":true,"path":"2019/08/26/JSP——EL表达式/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/JSP——EL表达式/","excerpt":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值","text":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值 使用EL获取数据 从四大域中获取数据EL只能获取到四大域中的数据，因此要获取到某个数据，需要将其加入到某个域中，再使用EL表达式获取数据。 从四大域中依次查找数据 ${属性}EL01.jsp 12345678910&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;name&#125; &lt;/body&gt; 输出结果为page域的属性值（最小的域） 从指定域中获取数据 ${域scope.属性}依次从四大域查找属性效率过低，为了提高效率，我们应该想想如何从指定域中直接获取某个属性值。 EL有4个域属性空间相关的内置对象，分别为pageScope，requestScope，sessionScope，applicationScope。表示从对应域属性空间中查找指定key。 1234567891011121314&lt;!-- EL01.jsp --&gt;&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;pageScope.name&#125;&lt;br/&gt; name = $&#123;requestScope.name&#125;&lt;br/&gt; name = $&#123;sessionScope.name&#125;&lt;br/&gt; name = $&#123;applicationScope.name&#125;&lt;br/&gt;&lt;/body&gt; 获取Bean的属性 ${key.属性}创建一个Bean的对象，将这个Bean对象加入到域属性空间中，通过 ${key.属性} 可以访问该对象的属性值。 注意：若访问对象为null，则EL也不会报空指针异常，显示结果为”” 12345678910111213141516171819202122232425262728293031/* School.java */package com.orbit.el;public class School &#123; private String scname; private String scaddress; public School(String scname, String scaddress) &#123; super(); this.scname = scname; this.scaddress = scaddress; &#125; public String getScname() &#123; return scname; &#125; public void setScname(String scname) &#123; this.scname = scname; &#125; public String getScaddress() &#123; return scaddress; &#125; public void setScaddress(String scaddress) &#123; this.scaddress = scaddress; &#125; @Override public String toString() &#123; return \"School [scname=\" + scname + \", scaddress=\" + scaddress + \"]\"; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/* Student.java */package com.orbit.el;public class Student &#123; private String sname; private int sno; private School school; public Student(String sname, int sno, School school) &#123; super(); this.sname = sname; this.sno = sno; this.school = school; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSno() &#123; return sno; &#125; public void setSno(int sno) &#123; this.sno = sno; &#125; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return \"Student [sname=\" + sname + \", sno=\" + sno + \", school=\" + school + \"]\"; &#125; &#125; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School school = new School(\"清华大学\",\"北京\"); Student student = new Student(\"杨小杨\",10001,school); pageContext.setAttribute(\"student\", student); %&gt; &lt;!-- 若访问对象为null，则EL也不会报空指针异常，显示结果为\" \" --&gt;&gt; student = $&#123;student1&#125; student = $&#123;student&#125;&lt;br/&gt; student.sname = $&#123;student.sname&#125;&lt;br/&gt; student.sname = $&#123;student['sname']&#125;&lt;br/&gt; student.sno = $&#123;student.sno&#125;&lt;br/&gt; student.sno = $&#123;student['sno']&#125;&lt;br/&gt; student.school = $&#123;student.school&#125;&lt;br/&gt; student.school.scname = $&#123;student.school.scname&#125;&lt;br/&gt; student.school.scaddress = $&#123;student.school.scaddress&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 获取数组 ${array[i]}创建一个数组，将这个数组加入到域属性空间，通过 ${array[i]} 可以访问该数组的第 i+1个元素。 1234567891011121314151617181920212223&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School[] schools = new School[3]; schools[0] = new School(\"清华大学\",\"中国北京\"); schools[1] = new School(\"北京大学\",\"中国北京\"); schools[2] = new School(\"厦门大学\",\"中国福建\"); pageContext.setAttribute(\"schools\", schools); %&gt; school[2] = $&#123;schools[0]&#125;&lt;br/&gt; school[2].address = $&#123;schools[2].scaddress&#125;&lt;br/&gt; &lt;!-- 数组下标超出上限，EL不会报越界异常 --&gt; school[3] = $&#123;schools[3]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ​ ​ 获取List中的元素 ${list[i]}访问list与访问数组的方式一致。 注意：set是无序的，其中的元素没有索引，因此无法用该种方式访问。 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; names[1] = $&#123;names[1]&#125;&lt;br/&gt; names[10] = $&#123;names[10]&#125;&lt;/body&gt;&lt;/html&gt; 获取Map中的元素 ${map.元素}123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"school\", new School(\"厦门大学\",\"中国福建\")); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- map.school是Object类型的，map.school.scname是默认Object型强转为School型 --&gt; $&#123;map.school.scname &#125;&lt;br/&gt; $&#123;map.name &#125;&lt;/body&gt;&lt;/html&gt; ​ EL常见运算符 序号 类别 运算符 1 算术运算符 + - * / % 2 关系运算符 &gt; &lt; == &gt;= &lt;= != 3 逻辑运算符 &amp;&amp;(and) ||(or) !(not) 4 条件运算符 ？ ： 5 取值运算符 . [ ] 6 empty运算符 empty empty的用法 empty判空，四大域中的元素符合以下条件时empty的运算结果为true： 没有定义的属性 值为null的引用 值为空串的String引用 没有元素的数组或集合 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String b = null; String c = \"\"; List&lt;String&gt; d = new ArrayList&lt;&gt;(); pageContext.setAttribute(\"b\", b); pageContext.setAttribute(\"c\", c); pageContext.setAttribute(\"d\", d); %&gt; empty a = $&#123;empty a&#125;&lt;br/&gt; empty b = $&#123;empty b&#125;&lt;br/&gt; empty c = $&#123;empty c&#125;&lt;br/&gt; empty d = $&#123;empty d&#125;&lt;/body&gt;&lt;/html&gt; EL内置对象 EL有11个内置对象，除了前面的和4个域属性空间相关的内置对象之外，还有7个。 EL的内置对象中，除了pageContext之外，其他内置对象的类型均为java.util.Map类型。 此处介绍常用的四个内置对象： pageContext 是不是有点熟悉？没错，EL的pageContext和JSP的pageContext是同一个对象。 可以获取到JSP的request、response、session、servletContext、servletConfig等对象 注意获取到的这些内置对象是JSP的，不是EL的，EL中没有这些内置对象。 如何在EL中使用pageContext获取到JSP的内置对象？ 例如，获取request内置对象——${pageContext.request} 其底层实际调用的方法为 pageContext.getRequest()，其他内置对象同理 常用内置对象的方法？ ${pageContext.request.contextPath()}，用来获取当前项目路径，一般用在JSP页面的路径中。 1234567&gt; &lt;body&gt;&gt; &lt;!-- 可读性差 --&gt;&gt; &lt;form action=\"register\"&gt;&lt;/form&gt; &gt; &lt;!-- 可读性好 --&gt;&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/register\"&gt;&lt;/form&gt;&gt; &lt;/body&gt;&gt; param ${param.parameter}`获取request域（请求）中的指定参数的值。 底层调用的是：request.getparameter() paramValues ${paramValues.parameter[i]}` :获取request域（请求）中指定参数的所有值。 底层调用的是：request.getparameterValues() initParam 获取初始化参数 底层调用的是servletContext.getInitParameter() 1234567891011121314151617181920212223&lt;!-- index.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/show.jsp\" &gt; 姓名：&lt;input type=\"text\" name=\"uname\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"uage\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"uhobby\" value=\"sing\"/&gt;唱 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"dancing\"/&gt;跳 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"rap\"/&gt;RAP &lt;input type=\"checkbox\" name=\"uhobby\" value=\"basketball\"/&gt;篮球&lt;br/&gt; &lt;input type=\"submit\"value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!-- show.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;param.uname&#125;&lt;br/&gt; 年龄：$&#123;param.uage&#125;&lt;br/&gt; 爱好：$&#123;paramValues.uhobby[0]&#125; &amp;nbsp; $&#123;paramValues.uhobby[1]&#125;&amp;nbsp; $&#123;paramValues.uhobby[2]&#125;&amp;nbsp; $&#123;paramValues.uhobby[3]&#125;&lt;br/&gt; 学校：$&#123;initParam.school&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;display-name&gt;02-EL&lt;/display-name&gt;&lt;context-param&gt; &lt;param-name&gt;school&lt;/param-name&gt; &lt;param-value&gt;清华大学&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; EL自定义函数 EL函数只能处理四大域中的属性值及常量 步骤：定义函数——定义标签库——注册函数——使用函数 12345678910//ELFunctions.javapackage com.orbit.el;public class ELFunctions &#123; //小写转大写 public static String LowertoUpper(String source) &#123; return source.toUpperCase(); &#125;&#125; 12345678910111213141516171819&lt;!-- myFt.tld --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 定义标签库信息 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myFt&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/el/functions&lt;/uri&gt; &lt;!-- 注册函数 --&gt; &lt;function&gt; &lt;name&gt;IsLowertoUpper&lt;/name&gt; &lt;function-class&gt;com.orbit.el.ELFunctions&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String LowertoUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 12345678910111213141516171819202122&lt;!-- index.jsp --&gt;&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/el/functions\" prefix=\"myFt\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用函数：处理常量 --&gt; $&#123;myFt:IsLowertoUpper(\"no one can stop me!\") &#125; &lt;!-- 使用函数：处理四大域中的属性 --&gt; &lt;% String name=\"Selena\"; pageContext.setAttribute(\"name\", name); %&gt; $&#123;myFt:IsLowertoUpper(name) &#125;&lt;/body&gt;&lt;/html&gt; JSTL中的EL函数​ JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache定义好的一套标准的标签库规范。 ​ JSTL中，定义了一套关于字符串处理的函数标签库，这个函数标签库中包含16个处理字符串的函数。 ​ 在JSP页面中导入jstl.jar ，standard.jar，就可以直接使用。 ​ 导入jar包 jstl.jar下载地址： http://repo2.maven.org/maven2/javax/servlet/jstl/ standard.jar下载地址： http://repo2.maven.org/maven2/taglibs/standard/ ​ 查看目录 ​ 使用函数 1234567891011121314&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:substring(\"abcdefg\",2,5) &#125; $&#123;fn:substringBefore(\"abcdefg\",\"cd\") &#125; $&#123;fn:substringAfter(\"abcdefg\",\"cd\"\") &#125;&lt;/body&gt;&lt;/html&gt; 对于EL做出的总结 EL不能出现在Java代码块、表达式块等JSP的动态代码部分 EL只能从四大域属性空间中获取数据（pageContext,request,session,application） EL不会抛出空指针异常，若访问一个null对象的属性，则什么也不显示 EL不会抛出数组访问越界异常，若访问一个数组中不存在的元素，则什么也不显示 EL本身无法对字符串进行处理，要想进行处理，可以通过EL自定义函数和JSTL中的EL函数来处理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"解决hexo显示不出本地图片问题","slug":"解决hexo显示不出本地图片问题","date":"2019-08-26T05:45:45.000Z","updated":"2019-08-27T15:26:08.966Z","comments":true,"path":"2019/08/26/解决hexo显示不出本地图片问题/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/解决hexo显示不出本地图片问题/","excerpt":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。","text":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹 1hexo new \"博客名\" 将想要上传的图片先保存在文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 使用hexo g部署，进入public\\2019\\08\\26\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2019/08/26/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"Servlet","slug":"Servlet","date":"2019-08-24T11:40:33.000Z","updated":"2019-08-26T09:26:49.702Z","comments":true,"path":"2019/08/24/Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/08/24/Servlet/","excerpt":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层","text":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层 2. Servlet的作用：用来接收客户端的请求数据，然后调用底层service处理数据并生成结果，返回一个响应给浏览器。 利用他可以实现业务层和表现层的分离，同时又可以生成动态页面。 3 . Servlet执行业务的步骤浏览器http请求——》tomcat服务器——-》到达servlet—–》执行doget，dopost方法—-》返回数据&lt;1&gt;客户端发送请求到服务器端&lt;2&gt;服务器将请求信息发送至Servlet&lt;3&gt;Servlet生成响应内容并将其传给服务器。&lt;4&gt;服务器将响应返回给客户端。 4. 创建Servlet的三种方式 定义一个类实现javax.servlet.Servlet接口 定义一个类继承javax.servet.GenericServlet类 定义一个类继承javax.servlet.http.HttpServlet类 web应用我们自然基本上都是继承HttpServlet 5. Servlet的生命周期（Servlet实例对象从创建到销毁的整个过程）​ Servlet的生命周期由一套定义良好的生命周期规则来约束管理 ​ 其中定义了Servlet如何被加载实例化和初始化,处理客户端请求,以及何时结束服务 ​ 生命周期方法有: ​ void init(ServletConfig)； ​ void service(ServletRequest,ServletResponse)； ​ void destroy()；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://cometorbityh.github.io/tags/Servlet/"}]}]}