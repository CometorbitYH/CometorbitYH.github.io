{"meta":{"title":"MY","subtitle":"IT IS MY LIFE","description":"每一天都在进步...","author":"杨涵","url":"https://cometorbityh.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-08-24T06:54:02.000Z","updated":"2019-08-24T08:47:48.572Z","comments":true,"path":"tags/index.html","permalink":"https://cometorbityh.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-24T06:54:16.000Z","updated":"2019-08-24T08:45:36.335Z","comments":true,"path":"categories/index.html","permalink":"https://cometorbityh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"191013——JAVA之IO流","slug":"191013——JAVA之IO流","date":"2019-11-13T07:18:02.000Z","updated":"2019-11-14T15:17:43.450Z","comments":true,"path":"2019/11/13/191013——JAVA之IO流/","link":"","permalink":"https://cometorbityh.github.io/2019/11/13/191013——JAVA之IO流/","excerpt":"","text":"File类##1. 基本描述 操作对象：文件和文件夹 概述：java.io.File 类是文件和目录路径名的抽象表示形式，主要用于文件和目录的创建、查找和删除等操作。 java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件/文件夹 删除文件/文件夹 获取文件/文件夹 判断文件/文件夹是否存在 对文件夹进行遍历 获取文件的大小 File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法 重点:记住这三个单词 file:文件 directory:文件夹/目录 path:路径##2. [复习]路径的写法 ###路径 路径可以是以文件结尾,也可以是以文件夹结尾路径可以是相对路径,也可以是绝对路径路径可以是存在,也可以是不存在创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况 ###路径的分类 绝对路径:是一个完整的路径 以盘符(c:,D:)开始的路径 c:\\\\a.txt C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan\\\\123.txt D:\\\\demo\\\\b.txt 相对路径:是一个简化的路径 相对指的是相对于当前项目的根目录(C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan) 如果使用当前项目的根目录,路径可以简化书写 C:\\\\Users\\itcast\\\\IdeaProjects\\\\shungyuan\\\\123.txt--&gt;简化为: 123.txt(可以省略项目的根目录) 注意: 1.路径是不区分大小写 2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠 ##3. 静态成员变量及常用方法 ###静态成员方法 变量 描述 static String pathSeparator 路径分隔符（1个字符串）：Windows为分号，Linux为冒号 static char pathSeparatorChar 路径分隔符（字符）：与上述功能一致 static String separator 默认名称分隔符（1个字符串）：Windows为反斜杠，Linux为正斜杠 static char separatorChar 默认名称分隔符（字符）：与上述功能一致 构造方法 public File(String pathname） 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 public File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 public File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 1234567891011121314151617181920212223242526272829package com.young.io;import java.io.File;public class FileDemo &#123; public static void main(String[] args) &#123; // 文件路径名 File f1 = new File(\"C:\\\\IO\"); File f2 = new File(\"C:\\\\IO\\\\demo1.txt\"); System.out.println(f1); System.out.println(f2); // 通过父路径和子路径字符串 File f3 = new File(\"C:\\\\IO\", \"demo2.txt\"); System.out.println(f3); // 通过父级File对象和子路径字符串 File f4 = new File(f1, \"demo3.txt\"); System.out.println(f4); &#125;&#125;------------控制台-------------C:\\IOC:\\IO\\demo1.txtC:\\IO\\demo2.txtC:\\IO\\demo3.txt 常用方法####获取功能的方法 public String getAbsolutePath() 返回此File的绝对路径名字符串 public String getPath() 将此File转换为路径名字符串 public String getName() 返回由此File表示的文件或目录的名称 public long length() 返回由此File表示的文件的长度（单位：字节） 判断功能的方法 public boolean exists() 此File表示的文件或目录是否实际存在 public boolean isDirectory() 判断构造方法中给定的路径是否以文件夹结尾（） public boolean isFile() 判断构造方法中给定的路径是否以文件结尾（使用前提：路径存在） 123456789101112131415161718192021package com.young.io;import java.io.File;public class FileDemo &#123; public static void main(String[] args) &#123; File f1 = new File(\"F:\\\\IO\"); File f2 = new File(\"F:\\\\IO\\\\aaa.txt\"); if(f1.exists())&#123; System.out.println(f1.isFile()); //false System.out.println(f1.isDirectory()); //true &#125; //若不存在，则没必要获取 if (f2.exists())&#123; System.out.println(f2.isFile()); //true System.out.println(f2.isDirectory()); //false &#125; &#125;&#125; 注意：isDirectory()和isFile()的使用前提：路径存在，否则都会返回false","categories":[],"tags":[]},{"title":"191111——JavaWeb之Session+Cookie","slug":"191111——JavaWeb之Session-Cookie","date":"2019-11-11T12:43:17.000Z","updated":"2019-11-13T07:14:12.260Z","comments":true,"path":"2019/11/11/191111——JavaWeb之Session-Cookie/","link":"","permalink":"https://cometorbityh.github.io/2019/11/11/191111——JavaWeb之Session-Cookie/","excerpt":"","text":"会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 Cookie本意“小饼干”，是客户端会话技术，将数据保存在客户端。 实现原理 基于响应头set-cookie和请求头cookie实现 Cookie的执行步骤： 步骤 方法 1. 创建Cookie对象 Cookie cookie = new Cookie(String name, String value) 2. 发送Cookie response.addCookie(Cookie cookie); 3. 获取Cookie,而后遍历Cookie Cookie[] cookies = request.getCookies(); 分别访问2个Servlet，Servlet发送Cookie，Servlet2获取Cookie并遍历，前提是浏览器不能关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.young.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo01\")public class CookieDemo01 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie cookie1 = new Cookie(\"msg\", \"success\"); Cookie cookie2 = new Cookie(\"code\", \"404\"); //2.发送Cookie response.addCookie(cookie1); response.addCookie(cookie2); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;package com.young.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo02\")public class CookieDemo02 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //3.获取Cookie Cookie[] cookies = request.getCookies(); for (Cookie cookie:cookies)&#123; String name = cookie.getName(); String value = cookie.getValue(); System.out.println(name + \"---\" + value); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;-------------控制台----------------msg---successcode---404device---11 有关Cookie的问题 一次可不可以发送多个cookie? 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ ​ 默认情况下，当浏览器关闭后，Cookie数据被销毁 ​ 实现持久化存储：在发送Cookie前加入方法setMaxAge(int seconds)即可。second的取值为： 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ ​ 在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3) ​ 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题 同Tomcat服务器的多个web项目： 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，则可以将path设置为“/“ 不同Tomcat服务器的多个web项目： setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 1. cookie存储数据在客户端浏览器，因此不安全 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别JSP：入门学习1. 概念： * Java Server Pages： java服务器端页面 * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 * 用于简化书写！！！ 2. 原理 * JSP本质上就是一个Servlet 3. JSP的脚本：JSP定义Java代码的方式 1. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 4. JSP的内置对象： * 在jsp页面中不需要获取和创建，可以直接使用的对象 * jsp一共有9个内置对象。 * 今天学习3个： * request * response * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前 5. 案例:改造Cookie案例Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门： 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： 获取数据：Object getAttribute(String name) 存储数据：void setAttribute(String name, Object value) 移除数据：void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(“JSESSIONID”,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化（序列化）： 在服务器正常关闭之前，将session对象序列化到硬盘上 session的活化（反序列化）： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 `&lt;session-timeout&gt;30&lt;/session-timeout&gt;` session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有","categories":[],"tags":[]},{"title":"191107——JavaWeb之Response","slug":"191107——Javaweb之Response","date":"2019-11-11T07:00:21.000Z","updated":"2019-11-11T08:39:14.054Z","comments":true,"path":"2019/11/11/191107——Javaweb之Response/","link":"","permalink":"https://cometorbityh.github.io/2019/11/11/191107——Javaweb之Response/","excerpt":"","text":"#Http（二） 响应消息：服务器端发送给客户端的数据 响应字符串格式 ​ HTTP/1.1 200 OK​ Content-Type: text/html;charset=UTF-8​ Content-Length: 101​ Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; ##响应消息的数据格式 ###（1）响应行 ​ 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告知客户端浏览器本次请求和响应的一个状态（3位数字） 分类 描述 举例 1xx 服务器接收客户端消息，但没有接收完成， 等待一段时间后，发送1xx多状态码 2xx 成功 200：响应成功 3xx 重定向 302 重定向； 304 本地缓存（客户端本地已有，访问缓存即可） 4xx 客户端错误 404：请求路径没有对应资源 405：请求方式没有对应的doxxx方法 5xx 服务器端错误 500：服务器内部出现异常 ###（2）响应头 ​ 格式：头名称：值 常见的响应头 描述 Content-Type 服务器告知客户端本次响应体的数据格式 + 编码格式 Content-Length 响应体长度 Content-Disposition 服务器告知客户端以何种格式打开响应体数据* in-line：默认值，在当前页面内打开* attachment；filename=xxx：以附件形式打开响应体。如文件下载 ###（3）响应空行 ###（4）响应体 ​ 响应体包含的是：真实传输的数据 Response对象##功能1：设置响应消息 ###（1）设置响应行 作用 方法 设置响应状态码 setStatus(int sc) （2）设置响应头 作用 方法 设置/修改响应体 setHeader(String name,String value) （3）设置响应体​ 步骤： 获取输出流 类型 方法 字符输出流 PrintWriter getWriter() 字节输出流 ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 功能2：重定向重定向：资源跳转的方式 ###（1）方法 步骤 方法 1.设置状态码为302 response.setStatus(302); 2.设置响应头location，其值为重定向的路径 response.setHeader(“location”,”/demo/responseDemo2”); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546--- FirstServlet----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); //重定向 response.setStatus(302); response.setHeader(\"location\",\"/demo01/secondServlet\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;--- SecondServlet----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 这2个方法中，302和location都是固定值，只有重定向的路径是变量，每次写起来有点麻烦，因此Response类提供了一个方法，用来简化书写。 作用 方法 重定向 sendRedirect(String path) 1response.sendRedirect(\"/demo01/secondServlet\"); ###（2）特点 地址栏路径改变，路径为重定向后的url 重定向可以访问服务器外部的资源 response.sendRedirect(&quot;http://www.baidu.com&quot;); 重定向是2次请求（因此不能使用request域来共享数据） ###（3）重定向与请求转发 案例 ###（1）输出字符数据 服务器获取字符输出流输出到浏览器页面， 步骤：1. 获取字符输出流 2. 输出数据 注意：输出到浏览器时，可能会产生中文乱码，只要是因为服务器和浏览器的编码不一致导致的， 因此在获取输出流之前需要：①设置该流的默认编码 ② 告知浏览器响应体使用的编码。 使用response.setContentType(&quot;text/html;charset=utf-8&quot;);方法可解决中文乱码问题。 123456789101112131415161718192021222324252627282930313233package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/responseServlet\")public class ResponseServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码，防止浏览器乱码 //设置流的默认编码 //response.setCharacterEncoding(\"utf-8\"); //方式1 //告知浏览器，服务器发送的消息体数据的编码，建议浏览器使用该编码解码（其中也设置了流编码） //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //方式2 response.setContentType(\"text/html;charset=utf-8\"); //2.获取字符输出流对象，获取的流的默认编码是ISO-8859-1 PrintWriter pw = response.getWriter(); //3.输出数据 pw.write(\"你好，response\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; ###（2）输出字节数据 服务器获取字节输出流输出到浏览器页面。 步骤：1. 获取字节输出流 2. 输出数据 中文乱码的解决方法与输出字符数据一致。 1234567891011121314151617181920212223242526package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/responseServlet\")public class ResponseServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码，防止浏览器乱码 response.setContentType(\"text/html;charset=utf-8\"); //2.获取字节输出流对象 ServletOutputStream sos = response.getOutputStream(); //3.输出数据 sos.write(\"你好，response\".getBytes(\"utf-8\")); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;","categories":[],"tags":[]},{"title":"191107——JavaWeb之Request","slug":"191107——Javaweb之Request","date":"2019-11-07T07:00:13.000Z","updated":"2019-11-11T12:40:46.803Z","comments":true,"path":"2019/11/07/191107——Javaweb之Request/","link":"","permalink":"https://cometorbityh.github.io/2019/11/07/191107——Javaweb之Request/","excerpt":"","text":"Http（一）Hyper Text Transfer Protocol超文本传输协议 传输协议：数据的传输协议/规则，定义了客户端和服务端通信时，发送数据的格式（请求消息和响应消息的格式） 特点 基于TCP／IP的高级协议（TCP是安全的协议，因此Http也是安全的协议） 默认端口号：80 基于请求/响应模型：一次请求对应一次响应，请求和响应一一对应。 无状态的协议：请求之间相互独立，不能交互数据 历史版本 1.0：每次请求都会建立一个新的连接。比如访问百度时，需要 获取到很多css和图片，每次请求到一张图片后都会断开连接，这样出现的结果就是耗时且耗费连接资源 1.1：复用上次请求的连接。每次请求到一张图片后会等待一段时间，若这段时间内还有数据要发送，就默认使用刚才那个连接，知道最后一个请求之后等待一段时间，发现没有数据需要发送了，即断开连接。 ##请求消息的数据格式 请求行 请求方式 请求url 请求协议/版本 请求方式：Http协议有7种请求方式，常用的有get和post GET POST 请求参数在请求行的url后 请求参数在请求体中 请求的url长度有限制， 请求的url长度无限制 不太安全 相对安全 请求头（键值对的格式） 请求头名称：请求头值 常见请求头 解释 作用 User-Agent 浏览器告知服务器，其使用的浏览器版本信息 在服务器端获取该头的信息，解决浏览器兼容问题（不同浏览器解析数据方法不一样， 使得用户用不同的浏览器访问同一个资源看到相同的界面） Accept 告知服务器，其可解析可接收的文件格式 Accept-Language 支持的语言环境 Accept-Encoding 支持的压缩格式 Referer 告知服务器，当前请求的来源 防盗链做统计工作 Connection 连接：keep-alive，保持活着，表示的是该连接可被复用 Upgrade-insecure 升级信息 请求空行 分隔POST的请求头和请求体 请求体（只有Post有请求体，Get没有） 封装POST请求消息的请求参数 Request请求回忆之前创建Servlet类时，service方法中有2个参数，ServletRequest req和ServletResponse res，这2个参数分别封装了请求信息和响应消息。 1. request对象和response对象的原理request和response对象是由服务器创建的，而我们的任务就是使用它们； request对象是来获取请求信息的，response对象是来设置响应消息的 2. request对象的继承体系结构ServletRequest接口，HttpServletRequest接口继承自ServletRequest接口，而org.apache.catalina.connector.RequestFacade类继承HttpServletRequest接口，这个类是tomcat定义的，tomcat创建这个request对象，并传递给service方法 ##3. request对象的功能 3.1. 获取请求消息数据（*3）####（1）获取请求行数据 GET /ProjectName/demo1?name=zhangsan HTTP/1.1 方法 含义 String getMethod() 获取请求方式 ：GET String getContextPath() 获取虚拟目录：/ProjectName String getServletPath() 获取Servlet路径: /demo1 String getQueryString() 获取get方式请求参数：name=zhangsan String getRequestURI() 获取请求URI：/ProjectName/demo1 StringBuffer getRequestURL() 获取请求URL：http://localhost/ProjectName/demo1 String getRemoteAddr() 获取客户机的IP地址： String getProtocol() 获取协议及版本：HTTP/1.1 URI ：统一资源标识符 ： /ProjectName/demo1——共和国 URL：统一资源定位符 ：http://localhost/ProjectName/demo1——中华人民共和国 1234567891011121314151617181920212223242526package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"获取请求方式method：\"+request.getMethod()); System.out.println(\"获取虚拟目录：\"+request.getContextPath()); System.out.println(\"获取Servlet路径：\"+request.getServletPath()); System.out.println(\"获取get方式的请求参数：\"+request.getQueryString()); System.out.println(\"获取请求的URI：\"+request.getRequestURI()); System.out.println(\"获取请求的URL：\"+request.getRequestURL()); System.out.println(\"获取客户机IP地址：\"+request.getRemoteAddr()); System.out.println(\"获取客户机协议及版本：\"+request.getProtocol()); &#125;&#125; （2）获取请求头数据 String getHeader(String name) 通过请求头的名称获取请求头的值 Enumeration getHeaderNames() 获取所有的请求头名称；注意该枚举类型实际是迭代器 12345678910111213141516171819202122232425262728293031323334353637383940package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取所有请求头的名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); //根据名称获取对应请求头的值 while(headerNames.hasMoreElements())&#123; String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name + \"---\" + value); &#125; &#125;&#125;--- 控制台数据----------------------------------------host---localhost:8080connection---keep-alivecache-control---max-age=0upgrade-insecure-requests---1user-agent---Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36accept---text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3accept-encoding---gzip, deflate, braccept-language---zh-CN,zh;q=0.9,en;q=0.8cookie---JSESSIONID=B2F7464DCB3037A05D6AF248ED2F938E; device=11 123456789101112131415161718192021222324252627282930313233package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求头数据：user-agent String agent = request.getHeader(\"user-agent\"); System.out.println(agent); //根据agent判断浏览器版本 if(agent.contains(\"Chrome\"))&#123; System.out.println(\"It is Chrome\"); &#125;else if(agent.contains(\"firefox\"))&#123; System.out.println(\"It is FireFox\"); &#125; &#125;&#125;--- 控制台数据----------------------------------------Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36It is Chrome ####（3）获取请求体数据 请求体中封装了POST请求的请求参数，只有POST方式有请求体； request对象将请求体封装成流，因此需要用获取流的方式来获取请求体的内容 获取步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据（文件，图片等） 从流对象中获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--- index.jsp----------------------------------------&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo01/requestDemo\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;--- RequestDemo.java----------------------------------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求消息的请求体 //1.读取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125;--- 控制台数据----------------------------------------username=zhangsan&amp;password=123456 3.2. 其他功能（1）获取请求参数通用方式（GET、POST均可） String getParameter(String name) 通过参数名获取参数值 String getParameterValues(String name) 根据参数名获取参数值的数组（复选框） Enumeration&lt;String.&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的map集合 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo01/requestDemo\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;游戏 &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;学习 &lt;input type=\"checkbox\" name=\"hobby\" value=\"sing\"&gt;唱歌&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.young.servlet;import com.sun.xml.internal.ws.client.sei.ValueSetter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.bind.ValidationEvent;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;import java.util.Map;import java.util.Set;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); System.out.println(\"getParameter ---&gt; \"+ \"username:\" + username + \",\" + \"password:\" + password); /*-------------------------------*/ String[] hobbies = request.getParameterValues(\"hobby\"); System.out.print(\"getParameterValues ---&gt; \" + \"hobby:\"); for (String hobby:hobbies)&#123; System.out.print(hobby + \" \"); &#125; System.out.println(); /*-------------------------------*/ Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); System.out.print(\"getParameterNames ---&gt; \"); while (parameterNames.hasMoreElements())&#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); System.out.print(name + \":\" + value + \" \"); &#125; System.out.println(); /*-------------------------------*/ Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); System.out.println(\"getParameterMap ---&gt;\"); //遍历Map的Key Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset)&#123; System.out.print(name + \":\"); //获取key对应的value数组 String[] values = parameterMap.get(name); for (String value : values)&#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; ####（2）获取请求参数中文乱码解决 get方式：tomcat8 已经将中文乱码问题解决，不会出现中文乱码 post方式：未解决。 解决方案：获取参数前，设置request的编码 方法 含义 request.setCharacterEncoding(“utf-8”); 设置request的编码为utf-8 ####（3）请求转发 一种在服务器内部的资源跳转的方式。因此不会改变地址栏url 步骤 方法 通过request对象获取请求转发器对象 request.getRequestDispatcher(String path) 使用请求转发器对象来进行资源转发 forward(ServletRequest request, ServletResponse response) 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;--------------------------------------------------- package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); request.getRequestDispatcher(\"/secondServlet\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 特点： 浏览器地址不发生变化 只能转发到服务器内部的资源；如下代码无法转发到百度服务器 request.getRequestDispatcher(&quot;http://www.baidu.com&quot;).forward(request,response); 转发是一次请求，不是两次请求 ####（4）共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 request域的三个方法 方法 含义 void setAttribute(String name,Object obj) 在request域中存储数据 Object getAttribute(String name) 在request域中通过键获取值 void removeAttribute(String name) 在request域中移除键所对应的键值对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455---------------FirstServlet.java-----------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/firstServlet\")public class FirstServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"this is firstServlet...\"); request.setAttribute(\"msg\",\"success!\"); request.getRequestDispatcher(\"/secondServlet\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;---------------SecondServlet.java-----------------package com.young.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/secondServlet\")public class SecondServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object msg = request.getAttribute(\"msg\"); System.out.println(\"msg --&gt;\" + msg); System.out.println(\"this is secondServlet...\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;---------------控制台-----------------this is firstServlet...msg --&gt;success!this is secondServlet... ####（5）获取ServletContext对象 方法 含义 ServletContext getServletContext() 获取ServletContext对象 123456789101112131415161718192021222324252627282930313233---------------RequestDemo.java-----------------package com.young.servlet;import com.sun.xml.internal.ws.client.sei.ValueSetter;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.bind.ValidationEvent;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;import java.util.Map;import java.util.Set;@WebServlet(\"/requestDemo\")public class RequestDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext servletContext = request.getServletContext(); System.out.println(servletContext); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125;---------------控制台-----------------org.apache.catalina.core.ApplicationContextFacade@3060c493 ServletContext对象概念：代表整个web应用，可以和程序的容器(服务器)来通信 ##1. 获取方式（2种） 获取方式 方法 通过request对象获取 request.getServletContext() 通过HttpServlet获取 this.getServletContext() ##2. ServletContext的功能 ###（1）获取MIME类型 MIME类型：在互联网通信过程中定义的一种文件数据类型的标准 格式： 大类型/小类型 （例：text/html， image/jpeg） 获取：String getMimeType(String file) ###（2）域对象：共享数据 ServletContext对象范围：共享所有用户所有请求的数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ###（3）获取文件的真实(服务器)路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.young.servlet;import javax.servlet.Servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo\")public class ServletContextDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取ServletContext对象 ServletContext context1 = request.getServletContext(); ServletContext context2 = this.getServletContext(); System.out.println(context1); System.out.println(context2); //获取MIME类型 String mimeType = context2.getMimeType(\"a.jpg\"); System.out.println(mimeType); //获取文件真实路径 String test01 = context2.getRealPath(\"/WEB-INF/classes/test01.txt\"); //src目录下访问资源 System.out.println(test01); String test02 = context2.getRealPath(\"/WEB-INF/test02.txt\"); //WEB-INF目录下访问资源 System.out.println(test02); String test03 = context2.getRealPath(\"/test03.txt\"); //web目录下访问资源 System.out.println(test03); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125;-------- 控制台输出结果 ----------------------org.apache.catalina.core.ApplicationContextFacade@1f5b43b6org.apache.catalina.core.ApplicationContextFacade@1f5b43b6image/jpegC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\WEB-INF\\classes\\test01.txtC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\WEB-INF\\test02.txtC:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\out\\artifacts\\demo01_war_exploded\\test03.txt","categories":[],"tags":[]},{"title":"191106——JavaWeb之Servlet","slug":"191106——JavaWeb之Servlet","date":"2019-11-06T09:16:13.000Z","updated":"2019-11-11T07:02:46.303Z","comments":true,"path":"2019/11/06/191106——JavaWeb之Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/11/06/191106——JavaWeb之Servlet/","excerpt":"","text":"Servlet1. Servlet简介servlet = server applet，字面意思是：运行在服务器端的小程序 servlet就是一个接口，定义了Java类被浏览器访问到的规则。 ##2. 实现Servlet及其执行原理 查看Java EE8文档，发现servlet定义了5个方法。当一个类实现Servlet接口时，需要重写Servlet的方法。 定义一个类实现Servlet接口的4个步骤： （1）创建JAVA EE项目 （2）定义一个类，实现Servlet接口 （3）实现Servlet接口的抽象方法 （4）配置Servlet（在web.xml中配置） 执行原理： 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径； 查找web.xml文件，是否有&lt;url-pattern&gt;标签体内容； 若有，则找到对应的&lt;servlet-class&gt;全类名； tomcat会将字节码文件加载进内存，并且创建其对象，调用其方法。（反射操作） 3. Servlet的生命周期 方法 作用 生命周期 void init 初始化的方法，在Servlet被创建时执行，只执行一次 被创建 void service 提供服务的方法，每一个Servlet被访问时都会被执行，可执行多次 提供服务 void destroy 销毁的方法，在服务器正常关闭时执行，只执行一次 被销毁 其他2个方法 ServletConfig getServletConfig 获取ServletConfig对象，servlet的配置对象 String getServletInfo 获取Servlet的一些信息：版本、作者… Servlet对象什么时候被创建？ 默认情况：第一次被访问时创建。 特殊情况：在服务器启动时创建。配置web.xml下的&lt;servlet&gt;中的&lt;load-on-startup&gt;。 当值为负整数时，第一次被访问时创建。 当值为正整数或0时，在服务器启动时创建。值的范围为[0,10] 一个servlet在内存中有几个对象？ Servlet的init方法只执行1次，说明一个Servlet在内存中只存在一个对象，因此servlet是单例的。 多个用户同时访问时，可能存在安全问题。因此尽量不在Servlet中定义成员变量。若定义了成员变量，也不要有修改值的操作，因为这个变量会被所有用户访问到。 destroy方法是在servlet对象被销毁之前执行还是之后执行？ 好比临终遗言般，destroy应该是在Servlet销毁之前执行，一般用于释放资源。 4. Servlet 3.0注解配置Servlet 3.0加入了注解配置，使得Servlet可以不用配置web.xml文件，直接在Servlet类上添加注解@WebServlet(&quot;/demo&quot;)，其中/demo是url-pattern，这样子就大大简化了代码，也不需要配置servlet-name了。 urlpartten：Servlet访问路径，是个数组，因此可以设置多个路径 一个Servlet可以设置多个访问路径：@WebServlet({&quot;/aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;}) 路径配置规则（*是通配符，优先级是最低的） /xxx：单层路径（/*随意起名都可访问该Servlet类） /xxx/xxx：双层路径（/xxx/*表示第二层随意起名都可访问该Servlet类） *.do（注意前面不加“/”） 5. Servlet的体系结构通过之前的小案例，了解了Servlet的基本操作。但是发现每次实现Servlet接口都要重写其5个方法，单往往我们只需要其中的service方法，其他4个方法一般不会使用。因此有没有什么方式能让我们只需要重写service方法就行了呢？有！ 我们去看下Servlet接口的继承结构： Servlet接口有一个实现类GenericServlet，这个类是个抽象类。而抽象类GenericServlet还有一个子类，名为HttpServlet，也是一个抽象类。这2个抽象类都能更简便的让我们重写Servlet的某些方法，而不是重写所有方法。 GenericServlet抽象类将Serrvlet接口中其他的方法做了默认空实现，只保留service( )方法作为抽象，也就是说，定义一个继承GenericServlet的Servlet类时，只需重写service（）方法即可，其他方法可以选择性的按照需求重写。 虽然GenericServlet抽象类很方便，但是我们实际开发时也很少使用GenericServlet，通常我们会使用HttpServlet抽象类 HttpServlet继承自GenericServlet抽象类，是Http协议的一种封装，可以简化操作 查看源码Service源码中获取了请求的方法，判断这个请求方式执行的方法， 因此我们无需像GenericServlet类一样重写service方法，而是重写对应的请求方法执行的方法，如doGet()、doPost()等7种。 定义类继承HttpServlet 复写doGet() / doPost()方法，当请求方法是get时，调用doGet方法，当请求是Post时，调用doPost方法，我们现在已知的post请求只有一种（表单method = post），其余均为get请求。","categories":[],"tags":[]},{"title":"191106——Git基本操作","slug":"191106——Git基本操作","date":"2019-11-03T12:00:46.000Z","updated":"2019-11-06T13:45:04.679Z","comments":true,"path":"2019/11/03/191106——Git基本操作/","link":"","permalink":"https://cometorbityh.github.io/2019/11/03/191106——Git基本操作/","excerpt":"","text":"1. 版本控制工具集中式版本控制工具：SVN、CVS、VSS… 分布式版本控制工具：Git、Mercurial、Bazaar、Darcs… 2. Git2.1. Git的优势 大部分操作在本地完成，无需联网（分布式版本控制，相当于本地仓库，因此无需联网） 完整性保证 尽可能添加数据而不是删除或修改数据（删除修改都是不可逆的操作） 分支操作非常快加流畅 与Linux命令全面兼容（他俩一个爹：Linux） 2.2. Git结构 ##2.3. Git 和代码托管中心 2.3.1 代码托管中心的任务：维护远程库 局域网环境下 GitLab 服务器 外网环境下 GitHub 码云 3. 本地库及其命令3.1 本地库和远程库（1）团队内部协作 （2）跨团队协作 ##3.2. 本地库操作命令 3.2.1 本地库初始化 + 签名本地库初始化命令： git init 注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要随意修改。 设置签名作用：区分不同开发人员的身份 格式：（举例，用户名与Email无实际联系） 用户名：tom Email：goodMorning@hello.com 注意：该签名和用于登录远程库（即代码托管中心）的账号密码无任何关系。 命令： 项目级别/仓库级别：只在当前本地库范围生效（信息保存在.git目录下的config文件中） git config user.name tom_pro git config user.email goodMorning_pro@hello.com 系统用户级别：登录当前操作系统的用户范围 （信息保存位置：系统~家目录下的.gitconfig文件） git config --global user.name tom_glb git config --global user.email goodMorning_glb@hello.com 级别优先级： 就近原则（项目级别 &gt; 系统级别，二者都有时采用项目级别的签名） 若只有系统级别的签名：以系统用户级别的签名为准 当二者都没有是不允许的。 ###3.2.2. 基本操作 新建一个文件，工作区添加到暂存区，提交到本地库 修改一个文件，添加到暂存区，提交到本地库 查看提交日志 前进后退版本 索引值能前进后退版本，^和~只能后退版本。 该命令中存在hard参数，在reset命令中，还有soft和mixed参数 soft参数：仅在本地库移动HEAD指针 mixed参数：在本地库移动HEAD指针，重置暂存区 hard参数：在本地库移动HEAD指针，重置暂存区，重置工作区 删除文件找回 前提：删除前，文件存在时的状态提交到了本地库 （之前已经把要找回的文件提交到了本地库） git reset --hard [指针位置]: 指针位置： 删除操作已提交到本地库，指针位置指向历史记录（永久删除文件后找回） 删除操作未提交到本地库，指针位置指向HEAD（添加到暂存区的删除文件找回） 永久删除文件后找回 添加到暂存区的删除文件找回 比较差异（比较不同版本的同一文件的差异） git diff [文件名]：将工作区的文件和暂存区进行比较 git diff [本地库历史版本] [文件名]：将工作区中的文件和本地库历史记录比较 不带文件名 比较多个文件 3.2.3. 分支管理查看分支 git branch -v 创建分支 git branch [分支名] 切换分支 git checkout [分支名] 合并分支 ​ 切换到接收修改的分支上（被合并的，变更内容的分支） git checkout [被合并的分支名] ​ 执行merge命令 git merge [有新内容的分支名] 分支冲突：2个分支同时修改了文件，git不清楚盖如何合并，导致分支冲突 解决： 编辑文件，删除特殊符号，修改文件内容后保存退出； 文件添加到暂存区，提交到本地库（注意此步操作不加文件名） #4. Git基本原理 4.1. 哈希算法哈希是一系列的算法，不同hash算法的加密强度不同。哈希算法不可逆。 Git底层采用的是SHA-1算法，哈希算法可以用来验证文件 ##4.2. Git 保存版本的机制 Git 的文件管理机制 Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。 Git 文件管理机制细节  Git 的“提交对象” 提交对象及其父对象形成的链条 Git 分支管理机制 5.3.1 分支的创建 分支的切换 总而言之，创建分支是创建新的指针，切换分支是切换指针的位置，因此非常高效 #5. 远程库操作命令 5.1. GitHub创建仓库1.注册账号并登录 2.创建仓库（远程库） 5.2. 本地库推送到远程库本地库连接远程库，执行推送操作 刷新远程库，可以看到刚才提交的文件了，点击可查看内容 ##5.3. 从远程库克隆项目到本地 另一个人执行的克隆操作 复制地址 克隆项目 这样用户2就克隆了用户1的远程库到本地了。 ##5.4. 修改内容重新推送到远程库 现在，用户2想修改用户1的内容并重新发回到用户1的本地库该怎么弄？ 之前图里看到过，直接推送是不行的， 需要用户1批准用户2，邀请用户2加入团队成为团队成员才能进行推送操作。 此时用户1成功邀请2成为团队成员 用户2就可以推送操作了 ###远程库修改的拉取 pull = fetch + merge 分为2步。git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名]/[远程分支名] ##5.5. 协同开发的冲突的解决 当用户1和用户2同时修改了某个文件的同一位置时，分别推送到远程库会出现冲突，即先推送的能成功，后推送的失败，因为远程库根据哈希值比较，若不同则认为你的本地库不是最新的了，因此用户2需要先拉取到本地，进行内容的修改，再进行推送。 如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 ##5.6. 跨团队协作操作 用户1和用户2是团队A的，用户3是团队B的，现在A对需要把项目给B队去优化，应该怎么做？ 首先团队B的成员要把团队A的远程库fork成自己的远程库，再克隆到本地，修改完成后push，发起pull request 团队1接受pull request 之后团队1就可以拉取远程库了。 5.7. SSH免密登录可以实现免GitHub账号登录，因此使用SSH可以免密登录，需要注意的是这样只能一个账号登陆 6. Git图形化&lt;eclipse版&gt;##6.1. 新建项目提交到本地库（忽略特定文件） 以eclipse为例： 点击Window——&gt; Preferences ——&gt; Team——&gt; Git——&gt;Configuration 新建一个Maven项目 将eclipse工程初始化为本地库 右击工程——&gt;Team——&gt;Share Project ——&gt;Git 解决追踪文件，首先要忽略一些特定文件 概念：Eclipse 特定文件 这些都是 Eclipse 为了管理我们创建的工程而维护的文件，和开发的代码没有 直接关系。最好不要在 Git 中进行追踪，也就是把它们忽略。 .classpath 文件 .project 文件 .settings 目录下所有文件 为什么要忽略 Eclipse 特定文件呢？ 同一个团队中很难保证大家使用相同的 IDE 工具，而 IDE 工具不同时，相关工程特定文件就有可能不同。如果这些文件加入版本控制，那么开发时很可能需要为了这些文件解决冲突 在家目录的本机用户的.gitconfig同级目录下新建一个java.gitignore，该文件的内容位于 https://github.com/github/gitignore/blob/master/Java.gitignore 在.gitconfig中添加： 这样，无论做任何版本操作，这些特定的文件都不会受任何干扰了 将项目添加到暂存区，右击项目——&gt;Team——&gt;add to Index 将项目提交到本地库，右击项目——&gt;Team——&gt;commit 若再添加新文件，可以直接对其commir，不用add。这就是图形化界面的优势 6.2. 推送到远程库新建远程库，复制链接 右击项目——&gt;Team——&gt;remote——&gt;push 添加所有分支 成功后，回到远程库可查看 6.3. 克隆工程操作右击空白处，import——&gt; Git——&gt;Project from Git——&gt;next——&gt;Clone URI——&gt;粘贴URI——&gt;master——&gt;next——&gt;更改保存路径——&gt;完成 克隆结束后，发现项目文件不完整，因为之前忽略了一些特定文件，所以还需要一些操作 右击项目，——&gt; configure ——&gt; convert to Maven Project，这样就能自动生成为Maven项目了。 ##6.4. 在eclipse解决冲突 分别提交 推送到远程库，第二个推送的人会产生冲突 解决：用户2先拉取（pull）,右击项目——&gt;Team——&gt;pull 右击冲突文件——&gt;Team——&gt;Merge Tool，可以看到对比 打开提交界面 此时文件图标恢复正常，到远程库即可。 查看远程库，推送成功！ 7. Git工作流（略）概念 在项目开发过程中使用 Git 的方式 分类 集中式工作流 GitFlow 工作流 Forking 工作流","categories":[{"name":"Git","slug":"Git","permalink":"https://cometorbityh.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cometorbityh.github.io/tags/Git/"}]},{"title":"191101——SpringMVC小结（1）","slug":"191101——SpringMVC小结（1）","date":"2019-11-01T01:18:58.000Z","updated":"2019-11-01T16:18:25.284Z","comments":true,"path":"2019/11/01/191101——SpringMVC小结（1）/","link":"","permalink":"https://cometorbityh.github.io/2019/11/01/191101——SpringMVC小结（1）/","excerpt":"","text":"2019.11.01记录帖SpringMVC简介SpringMVC是Spring框架的一个模块 1. 回忆MVC2. 第一个SpringMVC程序 若前端控制器没有配置init-param（没有说明springmvc配置文件的路径，有默认位置），则springmvc配置文件的默认位置应该在WEB-INF文件夹下，默认名为springDispatcherServlet-servlet.xml。","categories":[],"tags":[]},{"title":"记录独自做SSM论坛系统的错误、解决方案以及心得","slug":"记录独自做SSM论坛系统的错误、解决方案以及心得","date":"2019-10-27T08:55:47.000Z","updated":"2019-11-07T09:06:16.502Z","comments":true,"path":"2019/10/27/记录独自做SSM论坛系统的错误、解决方案以及心得/","link":"","permalink":"https://cometorbityh.github.io/2019/10/27/记录独自做SSM论坛系统的错误、解决方案以及心得/","excerpt":"","text":"1. 如何在文章下加入评论由于自己用的分页插件pageHelper只支持List，因此想用map插入实在很难解决（可能是我不懂哈哈）， 之前试过4表查询，结果只能得到有评论的文章。 因此在纠结了2天之后，我终于找到方法，就是查到所有评论，在控制层中按照文章的序号加入对应的评论，这样我就可以把对应的评论加入到对应文章的List中，从而解决了使用插件的难题。很开心，这样在之后插入也可以一个模块一个模块加入到文章bean中。 2. 添加文章时出现400错误代码在点击提交添加的按钮那边，一直出现400，很着急，按照百度的说法，有很多原因，有写是因为Date类型格式无法识别的，有说是int与Integer未转换，我一一试了一遍。都不行。最后在谷歌浏览器的控制台发现：我遍历出来的文章类型是类型名，但是我数据库中文章有关类型的字段是类型ID，看到这里我真的感觉很尴尬，我仿佛已经看到我要重构项目的时候了，郁闷。为什么当初要用Mybatis逆向工程，啊啊啊啊！！！不过好在解决了这个问题，这样发帖子功能也实现了，虽然没实现添加图片的功能，不过这个功能先放一放，后面再写。 3. 添加文章时，类型错误在添加带图片的文章时，由于图片是file类型的，因此后台一直获取不到这个数据。找了很多方法，最后在Controller方法的参数前加上@requestParam注解得以解决。 4. 收藏文章的思路需求：点击收藏按钮时变红（收藏），再次点击收藏时变灰（取消收藏），并且显示当前收藏数 思路： 先去数据库查出该文章被收藏的条目，在控制层中将其加入到各文章的LIst中，这样该文章的收藏数就是这些收藏条目的长度了。 在前端页面中，使用ajax遍历文章 用户未登录，且当前文章不是是当前登录用户的，收藏按钮显示为“请登录” 用户已登录，且当前文章不是是当前登录用户的（ 当前登录的用户ID和文章ID ） 未收藏（当前登录用户ID和文章ID 不等于 传到页面的Articles的该Article的Collection中的每条数据） 点击时收藏（调用收藏操作，执行添加收藏方法，并使收藏按钮变红） 已收藏（当前登录用户ID和文章ID 等于 传到页面的Articles的该Article的Collection中的某条数据） 点击时取消收藏（调用取消收藏操作，执行取消收藏方法，并使收藏按钮变灰） 5.重大消息今天发现之前跟着视频用分页做的逻辑居然如此好用，里面有个to_page()方法，它用了Ajax刷新了整个页面，但我居然不知道去使用，知道今天才发现，害我写了N多的重复代码，真的想哭。不过好在及时发现了这个神器，嘻嘻，再也不用重复写相同的逻辑了。这样的话之前的代码就需要重构了，不过没事，能简化代码我很开心呢。嗷嗷嗷嗷嗷嗷！","categories":[],"tags":[]},{"title":"191024——java多线程","slug":"191024——java多线程","date":"2019-10-24T08:04:02.000Z","updated":"2019-10-24T09:56:19.525Z","comments":true,"path":"2019/10/24/191024——java多线程/","link":"","permalink":"https://cometorbityh.github.io/2019/10/24/191024——java多线程/","excerpt":"","text":"多线程概述1.1. 概念进程：正在运行的程序 多进程：计算机同时支持运行多个进程，可以提高CPU的利用率 线程：一个进程可以执行多个任务，每一个任务都被称为一个线程，线程是程序的执行单元/执行路径。 多线程：提高应用程序的使用率。 多线程的意义：程序的执行本质是在抢CPU的资源，CPU的执行权。多进程是在抢占这个资源，而其中的某一个进程如果执行路径较多，就会有更高的几率抢到CPU执行权。但是线程的执行有随机性，无法保证一定抢到。 1.2. JAVA程序运行原理Java命令会启动JVM，等于启动一个应用程序，即启动一个进程。该进程会自动启动一个“主线程”，该主线程会自动调用某个类的main方法，因此main方法运行在主线程中。 问：JVM的启动是单线程还是多线程的？ 答：多线程，JVM启动后最少会有２个线程，一个主线程，一个垃圾回收线程（为了防止出现内存溢出）。 多线程实现方案Java提供类Thread来实现多线程，有2种方式实现多线程程序。 2.1. 方式1：继承Thread类2.1.1. 步骤： 自定义类MyThread继承Thread类 MyThread类重写run方法（只有run方法中的代码才会被线程执行） 创建MyThread对象 启动线程（start方法） 为什么启动线程是用start方法而不是run方法？ ​ 因为run方法只是封装了被线程执行的代码，直接调用是普通方法。 ​ 而start方法是先启动了线程，再由jvm去调用该线程的run方法 一个线程能调用2次start方法吗？ ​ 不能。这样相当于启动了2次一样的线程，一个线程同时只能启动一次。 如何获取和设置线程名称？ ​ public final String getName()：获取线程名称 ​ 线程类的无参构造方法创建的对象 + public final String setName()：设置线程名称 ​ 线程类的有参构造方法：设置线程名称 如何获得main方法所在线程对象的名称？ ​ Thread.currentThread().getName(); //Thread.currentThread()返回当前正在执行的线程对象 1234567891011121314151617181920package demo.test.thread;public class MyThread extends Thread&#123; @Override public void run() &#123; //需要被执行的代码 for(int x=0;x&lt;100;x++) &#123; System.out.println(getName()+\"---\"+x); &#125; &#125; public MyThread() &#123; // TODO Auto-generated constructor stub &#125; //有参构造方法：用来直接设置线程名称 public MyThread(String name) &#123; super(name); &#125;&#125; 1234567891011121314151617package demo.test.thread;public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建线程对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); //MyThread t3 = new MyThread(\"3号线程\"); t1.setName(\"1号线程\"); t2.setName(\"2号线程\"); //启动线程 t1.start(); t2.start(); &#125;&#125; ### 线程调度和线程控制3.1. 线程调度线程调度有2种模型。 分时调度模型，所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片 抢占式调度模型（java使用的）：优先使优先级高的线程使用CPU，若优先级相同，则会随机选择一个。注意：优先级高的线程获取CPU时间片相对多一些。 如何设置线程的优先级？ setPriority(10)：线程的默认优先级为5，其取值范围为[1，10]； 优先级仅仅表示线程获取的CPU的时间片的几率高。 3.2. 线程控制 线程睡眠：Thread.sleep(ms) 加入线程：join()：优先执行该线程 线程礼让：Thread.yield():暂停当前正在执行的线程对象，并执行其他线程对象（使线程执行更有规律，但无法保证一个线程执行一次） 守护线程： 中断线程： 线程生命周期 线程同步死锁线程间通信定时器的使用","categories":[],"tags":[]},{"title":"JAVA——集合类","slug":"JAVA——集合类","date":"2019-10-23T06:59:40.000Z","updated":"2019-10-23T10:29:08.254Z","comments":true,"path":"2019/10/23/JAVA——集合类/","link":"","permalink":"https://cometorbityh.github.io/2019/10/23/JAVA——集合类/","excerpt":"","text":"集合：也称容器。是一种可以装任何类型的容器 集合与数组的区别：数组长度不可变。集合长度可变 List特点：有序可重复，容器保存的数据可以是多种类型的，但是当我们存储了很多不同类型的数据后，取数据就需要转成对应的类型，导致很麻烦，那么有没有什么办法可以规定该List只能存储一种数据类型呢？ 我们使用泛型来规定数据类型，未规定泛型的集合里面可以存储任意类型的数据或对象，规定泛型之后，该集合只能存储对应数据类型的数据或对象。 注意：泛型可以用引用数据类型代替，而不是指基本数据类型。如List&lt;Integer&gt;而不是List&lt;int&gt;。 ArrayList的常用方法常用方法： 增删改查：add(E e) ,remove(index),set(index,value),get(index),size() 其他方法：addAll(list2) 并集， removeAll(list2)差集， retainAll（list2) 交集 ​ indexOf() , lastIndexOf(), contains() List=subList() ​ isEmpty() clear() ensureCapacity() iterator()迭代器 ​ toArray(T[] x); TrimToSize(); add ——存 remove(int index)——删除对应索引的元素 set(int index,E value)——对应索引的元素改成新元素 inr size()——返回该list的有效元素个数 list1.addAll(Collection&lt;? extends E&gt; list2)：将list2的所有元素添加到list1中，注意如果2个List都有泛型，那么list2的泛型应该与list1的泛型相同或是list1的泛型的子类，若泛型无关联，则无法添加。(并集) list1.addAll(int index, Collection&lt;? extends E&gt; list2)：将list2的所有元素添加到list1中，在索引处前开始插入。注意如果2个List都有泛型，那么list2的泛型应该与list1的泛型相同或是list1的泛型的子类，若泛型无关联，则无法添加。 E get(int index)——取出对应索引位置的元素，返回值为规定的泛型 clear()——清除list中的所有元素 boolean contains(Object)——判断是否包含该元素 int indexOf(Object o)——判断该元素第一次在list中出现的索引 int lastIndexOf(Object o)——判断该元素最后一次在list中出现的索引 boolean isEmpty() ——判断list是否为空 system.out.println(list)：遍历对象，说明List重写了toString()方法 Iterator iterator()——迭代器 removeAll(list2)——差集 retainAll(list2)——交集 ArrayList Vector LinkedList 底层数据结构 动态数组（扩容1.5倍） 动态数组（扩容2倍） 双向链表 特点 有序可重复，适合遍历和查询 有序可重复，适合遍历和查询 有序可重复，适合增加和删除 线程不同步，安全性低，效率高 线程同步，安全性高，效率低 Set接口实现Collection接口，以value形式存在 无序无重复， 无序：set集合使用hash算法对元素进行排列，不是按照存储顺序排列，因此无序 HashSet TreeSet 底层数据结构 HashMap（散列表=数组+链表） TreeMap（红黑二叉树） 特点 无序无重复 无序无重复 无重复原则有2个方法同时起作用* equals hashCode* 默认比较2个对象的地址，若第二个对象地址与第一个一致，则不存入* 若i想改变其规则，则可重写上述2个方法 无重复原则有1个方法在起作用* compareTo* 该方法并非所有对象都有，若想将1个对象存入TreeSet中，需让对象所属的类实现接口COmparable，再将compareTo重写，返回值int，负数靠前排布，整数排列靠后 Map&lt;K,V&gt;接口Map，直译为地图，在Java中表示映射，可以通过某个key直接定位到对应的value值 存储的方式：键值对（key-value)，key无序无重复，value无序可重复。就像账号和密码，账号是唯一的，密码可能会一样。 HashMap&lt;K,V&gt;类3.1. 所属包：java.util 3.2. 如何创建对象 12//创建一个HashMap对象，该方法：初始容器16，当容量达到容量的0.75倍时自动扩容HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); 3.3. 基本方法 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243package demo.test.collection;import java.util.HashMap;import java.util.Iterator;import java.util.Set;public class TestHashMap &#123; public static void main(String[] args) &#123; //创建一个HashMap对象，该方法：初始容器16，当容量达到容量的0.75倍时自动扩容 HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); /*==== 增删改查 ====*/ map.put(1, \"aaa\"); map.put(4, \"ddd\"); map.put(2, \"aaa\"); //key不同，value相同 map.put(3, \"bbb\"); map.put(3, \"xxx\"); //key相同，value不同 System.out.println(map); /* * 无序：存元素的顺序与取元素的顺序无关 key不能重复：若重复，则后添加的覆盖前添加的 value可重复：不同的key可以有相同的value */ map.remove(3); map.put(2, \"我是2号key\"); System.out.println(\"map的有效元素个数：\"+map.size()); System.out.println(map); /*==== 遍历 ====*/ //获取map集合的全部key Set&lt;Integer&gt; keys = map.keySet(); //通过迭代器遍历keys Iterator&lt;Integer&gt; it = keys.iterator(); while(it.hasNext()) &#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+\"-----\"+value); &#125; &#125;&#125; 其他方法 ​","categories":[],"tags":[]},{"title":"SSM图片上传并回显","slug":"SSM图片上传并回显","date":"2019-10-19T15:27:08.000Z","updated":"2019-10-20T04:26:26.653Z","comments":true,"path":"2019/10/19/SSM图片上传并回显/","link":"","permalink":"https://cometorbityh.github.io/2019/10/19/SSM图片上传并回显/","excerpt":"","text":"最近做一个SSM项目需要用到图片上传，在网上找了很多教程，配置了几遍，终于弄出来了，在此记录一贴留念。 本文使用的工具是idea，数据库是Mysql，框架是SSM。 1. 项目结构新建一个maven项目，进行ssm整合之后，添加以下文件： 2. 前期准备在本地找个盘建个文件夹用来存放图片，如我在E盘下新建文件夹“upload”（忽略图片，测试时用的）: idea创建好一个Maven项目，配置好Tomcat，将放图片的文件夹也加入： 当启动tomcat时，会部署2个目录分支，这样前期工作就准备好了。 3. 新建数据库123456DROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `pid` int(11) NOT NULL AUTO_INCREMENT, `pimage` varchar(255) DEFAULT NULL, PRIMARY KEY (`pid`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 4. 具体代码1. pom.xml123456789101112&lt;!-- 上传下载需要涉及到的jar包 --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 2. SpringMVC.xml12345678&lt;!-- 定义文件上传解析器 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"&gt;&lt;/property&gt; &lt;!-- 其他的大家可以自行配置，不影响主功能--&gt;&lt;/bean&gt; 3. Product.java123456789101112131415161718192021222324252627package com.young.bean;public class Product &#123; private Integer pid; private String pimage; public Integer getPid() &#123; return pid; &#125; public void setPid(Integer pid) &#123; this.pid = pid; &#125; public String getPimage() &#123; return pimage; &#125; public void setPimage(String pimage) &#123; this.pimage = pimage; &#125; @Override public String toString() &#123; return \"Product [pid=\" + pid + \", pimage=\" + pimage + \"]\"; &#125;&#125; 4. ProductMapper.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.young.dao.ProductMapper\"&gt; &lt;!-- 添加商品图片 --&gt; &lt;insert id=\"save\" parameterType=\"com.young.bean.Product\" &gt; insert into product(pimage) values (#&#123;pimage&#125;) &lt;/insert&gt; &lt;!-- 查询商品--&gt; &lt;select id=\"list\" resultType=\"com.young.bean.Product\"&gt; select * from product &lt;/select&gt;&lt;/mapper&gt; 5.ProductMapper.java123456789101112package com.young.dao;import com.young.bean.Product;import java.util.List;public interface ProductMapper &#123; //保存商品 void save(Product product); //查询商品 List&lt;Product&gt; list();&#125; 6. ProductService.java123456789101112package com.young.service;import com.young.bean.Product;import java.util.List;public interface ProductService &#123; List&lt;Product&gt; list(); void save(Product product);&#125; 7. ProductServiceImpl.java12345678910111213141516171819202122232425262728293031323334package com.young.service.impl;import com.young.bean.Product;import com.young.dao.ProductMapper;import com.young.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.ui.ModelMap;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID;@Service@Transactionalpublic class ProductServiceImpl implements ProductService &#123; //注入ProductMapper @Autowired private ProductMapper productMapper; @Override public List&lt;Product&gt; list() &#123; return productMapper.list(); &#125; @Override public void save(Product product) &#123; productMapper.save(product); &#125;&#125; 8.ProductController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.young.controller;import com.young.bean.Product;import com.young.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID;@Controllerpublic class ProductController &#123; //注入ProductService @Autowired private ProductService productService; //查询 @RequestMapping(\"/list.do\") public String listUser( Model model)&#123; List&lt;Product&gt; list= productService.list(); model.addAttribute(\"list\",list); System.out.println(list); return \"list\"; &#125; @RequestMapping(\"/addProduct.do\") public String fileUpload(MultipartFile file,Product product, ModelMap map) throws IOException &#123; /** * 上传图片 */ //图片上传成功后，将图片的地址写到数据库 String filePath = \"E:\\\\upload\";//保存图片的路径,tomcat中有配置 //获取原始图片的拓展名 String originalFilename = file.getOriginalFilename(); //新的文件名字，使用uuid随机生成数+原始图片名字，这样不会重复 String newFileName = UUID.randomUUID()+\"_\"+originalFilename; //封装上传文件位置的全路径，就是硬盘路径+文件名 File targetFile = new File(filePath,newFileName); //把本地文件上传到已经封装好的文件位置的全路径就是上面的targetFile file.transferTo(targetFile); product.setPimage(newFileName);//文件名保存到实体类对应属性上 /** * 保存商品 */ productService.save(product); return \"redirect:/list.do\"; //重定向到查询 &#125;&#125; 9. index.jsp123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"addProduct.do\" method=\"post\" enctype=\"multipart/form-data\"&gt; 图片：&lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10. list.jsp这里有一个地方需要注意：此处填选的是tomcat中加入部署的文件夹时起的名字 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"/&gt; &lt;script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=\"text/css\"&gt; #images&#123; width: 50px; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table class=\"table table-bordered table-hover\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;图片&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"product\" &gt; &lt;tr&gt; &lt;th&gt;$&#123;product.pid &#125;&lt;/th&gt; &lt;th&gt;&lt;c:if test=\"$&#123;product.pimage !=null &#125;\"&gt; &lt;img id=\"images\" alt=\"\" src=\"/upload/$&#123;product.pimage &#125;\"&gt; &lt;/c:if&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5. 测试结果启动tomcat，开始测试 至此，大功告成！","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM文件上传","slug":"SSM文件上传","permalink":"https://cometorbityh.github.io/tags/SSM文件上传/"}]},{"title":"","slug":"JAVA——多线程","date":"2019-10-17T12:04:38.212Z","updated":"2019-10-18T07:40:29.836Z","comments":true,"path":"2019/10/17/JAVA——多线程/","link":"","permalink":"https://cometorbityh.github.io/2019/10/17/JAVA——多线程/","excerpt":"","text":"2 1. 概念理解1.1. 并发与并行1.2. 程序，进程，线程1.3. 线程调度，分时调度 描述 举例 并发 多个事件交替执行(单核)，效率低 一个人同时吃2个包子，一个包子吃一口 并行 多个事件同时执行(多核)，效率高 两个人吃2个包子 程序 QQ程序 进程 运行中的(进入到内存中)应用程序 开启1个QQ或多个QQ，这些QQ叫进程 线程 是进程的一个执行单元。进程中的操作 360可以同时清理垃圾，扫描病毒，这些操作都叫线程 多线程 效率高，线程之间互不影响 线程调度（2种） 分时调度 每个线程占用的时间相等 抢占式调度(java采用的) 优先级越高的线程被执行的几率就大 一个程序至少包含1个进程，一个进程可以包含多个线程 2. 多线程的创建方式 java中的程序只有1个线程，从main方法开始执行，即主线程； 当程序之间有一个异常时，后面的程序都不会执行到，因此我们需要引入多线程来执行异常后的代码。 2.1. 创建Thread的子类2.2.实现Runnable接口 创建一个Runnable的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法 2.3. Thread和Runnable的区别一个类继承Thread类，则不适合资源共享 一个类实现Runnable接口，很容易就可实现资源共享 实现Runnable接口创建多线程程序的好处： 适合多个相同的程序代码的线程去共享同一个资源 可避免Java的单继承的局限性（实现Runnable接口还可以实现其他类或接口） 增加程序的健壮性，实现解耦操作，代码可被多个线程共享，代码和线程独立 实现Runnable，把设置线程任务和开启新线程进行分离（解耦） 实现类重写了run方法：用来设置线程任务 创建Thread类对象，调用start方法，用来开启新线程 线程池只能放入实现Runnable或Callable类的线程，而不能直接放入继承Thread的类 在Java中，程序每次运行至少启动2个线程，一个main线程。一个是垃圾收集线程， 因为每当使用Java命令执行一个类时，实际上都会启动一个JVM，每一个JVM其实就是在操作系统中启动了一个进程。 2.4. 用匿名内部类来创建线程匿名：没有名字 内部类：写在其他类内部的类 匿名内部类的作用：简化代码 把【子类继承父类，重写父类的方法，创建子类对象】合成一步完成 把【实现类实现类接口，重写接口中的方法。创建实现类对象】合成异步完成 匿名内部类的最终产物：子类/实现类对象，而这个类没有名字 匿名内部类的格式： 123new 父类/接口()&#123; //重写父类/接口的方法&#125;； 匿名内部类创建线程的步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.test.ThreadDemo;public class InnerClassThread &#123; public static void main(String[] args) &#123; /*----------------------------------*/ //new 父类Thread //new MyThread().start(); new Thread() &#123; //重写run方法，设置线程任务 public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Thread\"); &#125; &#125; &#125;.start(); /*----------------------------------*/ //new 接口Runnable //Runnable r = new RunnableTest(); 创建Runnable接口的实现类对象 Runnable r = new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Runnable\"); &#125; &#125; &#125;; //创建Thread类对象，构造方法床底Runnable接口的实现类对象 //调用start方法开启线程 new Thread(r).start(); /*----------------------------------*/ //简化Runnable new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;3;i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;Runnable01\"); &#125; &#125; &#125;).start(); &#125;&#125; 3. 线程安全3.1. 线程安全问题当多个线程访问共享的资源时，这些线程会抢占cpu的执行权，就会产生线程安全问题。 例如3个售票处同时售卖100张票，但会卖到同一张票，而一张票只能卖给一个人，此时的售票员多尴尬啊。 以下程序中不仅出现重复卖票，还出现不存在的票。 123456789101112131415161718package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义票数，这是一个共享的资源 private int ticket=10; //模拟售票 @Override public void run() &#123; while(true) &#123; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125; &#125;&#125; 12345678910111213141516171819package com.test.ThreadDemo;public class ThreadSecurityDemo &#123; public static void main(String[] args) &#123; //创建实现Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //定义Thread类的子类对象，其构造方法的参数为实现Runnable接口的实现类对象 Thread t1 = new Thread(run); Thread t2 = new Thread(run); Thread t3 = new Thread(run); //开启多线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 3.2. 解决线程安全问题（3种方法）（1）同步代码块synchronized关键字可用于方法中的某个区块中，表示只对该区块的资源进行互斥访问。 格式： 123synchronized(同步锁对象)&#123; 可能会出现线程安全问题的代码（共享数据的代码）&#125; 锁对象：锁对象可以使用任意的对象，多个线程使用的锁对象必须使同一个， 锁对象的作用：把同步代码块锁住，只允许一个线程在同步代码块中执行。 1234567891011121314151617181920212223242526272829303132package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; while(true) &#123; //同步代码块 synchronized(obj) &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125; &#125; &#125;&#125; （2）同步方法synchronized关键字修饰的方法，当某个线程执行该方法时，锁住代码，其他线程只能在方法外等候。 同步方法 格式 锁对象 原因 非静态同步方法 修饰符 synchronized 返回值类型 方法名(参数列表){ //需要同步的代码} this 静态同步方法 修饰符 static synchronized 返回值类型 方法名(参数列表){ //需要同步的代码} 本类的class文件对象 因为this是创建对象后产生的，而静态方法优先于对象，因此静态同步方法的锁对象是本类的class文件对象 非静态同步方法1234567891011121314151617181920212223242526272829303132333435package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; saleTicket(); &#125; &#125; //同步方法 public synchronized void saleTicket() &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125;&#125; 123456789101112131415161718192021package com.test.ThreadDemo;public class ThreadSecurityDemo &#123; public static void main(String[] args) &#123; //创建实现Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); System.out.println(\"run___\"+run); //定义Thread类的子类对象，其构造方法的参数为实现Runnable接口的实现类对象 Thread t1 = new Thread(run); Thread t2 = new Thread(run); Thread t3 = new Thread(run); //开启多线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 非静态同步方法的锁对象是对应的Runnable接口的实现类对象，即this 静态同步方法123456789101112131415161718192021222324252627282930313233343536package com.test.ThreadDemo;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private static int ticket=10; //定义锁对象 Object obj = new Object(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; saleTicket(); &#125; &#125; //同步方法 public static synchronized void saleTicket() &#123; if(ticket&gt;0) &#123; //提高安全问题出现的概率，使程序睡眠 try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; &#125;&#125; （3）Lock锁java.util.concurrent/locks.Lock接口 Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作 Lock接口中的方法: void lock()————————获取锁 void unlock()————————释放锁 Lock接口有个实现类： java.util.concurrent.locks.ReentrantLock 使用步骤： 在成员位置创建ReentrantLock对象 在可能会出现安全问题的代码前调用Lock接口的lock方法来获取锁 在可能会出现安全问题的代码后调用Lock接口的unlock方法来释放锁 1234567891011121314151617181920212223242526272829303132333435363738package com.test.ThreadDemo;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class RunnableImpl implements Runnable&#123; //定义一个票数，这是一个共享的资源 private static int ticket=10; /*1.创建ReentrantLock对象*/ Lock l =new ReentrantLock(); //模拟售票 @Override public void run() &#123; System.out.println(\"this___\"+this); while(true) &#123; /*2. 在线程安全代码之前获取锁*/ l.lock(); if(ticket&gt;0) &#123; try &#123; //睡眠，相当于冷却 Thread.sleep(5); //售票 System.out.println(Thread.currentThread().getName()+\"第\"+ticket+\"张票已出售！\"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; /*3. 在线程安全代码之后释放锁*/ l.unlock(); &#125; &#125; &#125; &#125;&#125; 4. 线程状态Thread的内部类State描述了线程的6种状态 4.1. TimedWaiting（计时等待）调用sleep()，使线程进入睡眠状态； 调用wait(long m)，等待毫秒值结束后，若没有被notify()唤醒，则自动醒来，线程进入运行状态或阻塞状态 4.2. BLOCKED（锁阻塞）当线程抢到cpu执行权时，进入运行状态。未强抢到执行权时，进入阻塞状态 4.3. Waiting（无限等待）线程进入等待状态，需要等待被唤醒。 wait()线程等待，需要notify唤醒 wait(long m)，等待毫秒值结束后，若没有被notify()唤醒，则自动醒来，线程进入运行状态或阻塞状态 notify()唤醒在该对象监视器等待的单个线程 notifyAll()唤醒在该对象监视器等待的所有线程 4.4. 其他5. 等待唤醒机制我们知道。多个线程并发执行时，cpu是随机切换线程的，当我们需要多个线程共同执行一项任务时，必然是需要有规律的执行，只做包子不吃或者只吃包子不做都是不符合规律的，因此我们需要他们之间协调通信来完成任务。 什么是等待唤醒机制？线程之间的通信 为了解决线程之间的通信问题，为了有效利用共享的资源 用到的方法： wait()：线程进入等待状态，进入对象的waiting set中，不再占用cpu资源和竞争锁。需要得到通知notify才能重新进入到调度队列中 notify()：释放对象的waiting set中等待时间最长的线程 notifyAll()：释放对象的waiting set中的全部线程","categories":[],"tags":[]},{"title":"JAVA——集合","slug":"JAVA——集合","date":"2019-10-16T11:22:04.000Z","updated":"2019-10-23T06:59:00.173Z","comments":true,"path":"2019/10/16/JAVA——集合/","link":"","permalink":"https://cometorbityh.github.io/2019/10/16/JAVA——集合/","excerpt":"","text":"1.CollectionCollection的常用方法 操作对象 方法 描述 单个容器 boolean add(Object element) 增加元素到容器中 boolean remove(Object element) 从容器中移除元素 boolean contains(Object element) 容器中是否包含该元素 int size() 容器中元素的数量 boolean isEmpty() 容器中是否为空 void clear() 清空容器中所有元素 迭代器 Interator 提供了统一的遍历容器的方式 多个容器 boolean addAll(Collection c) 将容器C的所有元素添加到本容器中 boolean removeAll(Collection c) 移除本容器和C容器中都包含的元素 boolean containsAll(Collection c) 本容器中是否包含c容器中的所有元素 boolean retainAll(Collection c) 留下本容器和容器C都包含的元素，移除本容器和C容器中非交集的元素 Object[] toArray() 转化为Object数组 123456789101112131415161718192021222324252627package com.orbit.demo;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add(\"张三\"); c.add(\"李四\"); System.out.println(c.toString()); System.out.println(\"当前容器是否为空 ==&gt; \"+c.isEmpty()); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); System.out.println(\"当前容器是否包含李四 ==&gt; \"+c.contains(\"李四\")); System.out.println(\"转为Object数组 ==&gt; \"+c.toArray().toString()); System.out.println(\"移除李四\"); c.remove(\"李四\"); System.out.println(c.toString()); System.out.println(\"清空\"); c.clear(); System.out.println(\"当前容器元素个数 ==&gt; \"+c.size()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"aa\"); list01.add(\"bb\"); list01.add(\"cc\"); List&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"aa\"); list02.add(\"dd\"); list02.add(\"ee\"); System.out.println(list01); System.out.println(list02); list01.addAll(list02); //list02添加到list01（可重复） System.out.println(list01); System.out.println(list01.containsAll(list02)); //list01是否包含list02 list01.removeAll(list02); //删除交集元素 System.out.println(list01); list01.retainAll(list02); //删除非交集元素 System.out.println(list01); &#125; &#125; 2.List接口List是有序的、可重复的容器。 有序：每个元素都有索引，可通过索引访问元素 可重复：允许加入重复元素 List接口常用的实现类有3个：ArrayList，LinkedList，Vector 12345678910111213141516171819202122232425262728293031323334package com.orbit.demo;import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123; public static void main(String[] args) &#123; //创建一个容器 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aa\"); list.add(\"bb\"); list.add(\"cc\"); list.add(\"dd\"); //在最后增加元素 System.out.println(list); list.add(2, \"AA\"); //在索引处插入元素 System.out.println(list); list.remove(2); //移除指定索引的元素 System.out.println(list); list.set(2, \"aa\"); //覆盖指定索引的元素 System.out.println(list); System.out.println(list.get(2)); //获取指定索引的元素 System.out.println(list.indexOf(\"aa\")); //获取该元素第一次出现的索引位置。不存在则返回-1 System.out.println(list.indexOf(\"bc\")); System.out.println(list.lastIndexOf(\"aa\")); //获取该元素最后一次出现的索引位置。不存在则返回-1 &#125; &#125; 2.1 ArrayList（常用）ArrayList底层是用数组实现的存储。 数组占用空间连续 特点：查询效率高，增删效率低，线程不安全。 数组长度有限，但ArrayList长度不限，可存放任意数量的对象。它是如何实现的？ 扩容。数组的默认长度为10，当长度满时，创建一个新的长度为原来的1.5倍（原长度+原长度右移1位）长度的数组，再将旧数组的元素复制到新数组中。 2.2 LinkedListLinkedList底层时采用双向链表实现的存储。链表占用空间不连续 特点：查询效率低，增删效率高，线程不安全 双向链表：每个数据节点（node）都有2个指针，分别指向前一个节点和后一个节点。 上节点地址 || 元素数据 || 下节点地址 2.3 VectorVector底层是采用数组实现的List，相关方法都增加了同步检查（synchronized） 特点：效率低（同步检查耗费时间），线程安全 3. Map接口显示生活中，常需要成对存储某些信息，比如一个手机号对应一个微信号，这就是成对存储关系， 在Java中，这对数据称为键值对（key-value）， Map就是用来存储键值对的，通过键来获取值，因此键对象是唯一的不可重复。 若重复，则新的键值对会覆盖旧的键值对 。 Map接口的实现类：HashMap，TreeMap，HashTable，Properties 操作对象 方法 描述 单个Map Object put(Object key,Object value) 存放键值对 Object get(Object key) 通过键对象查找得到值对象 Object remove(Object key) 删除键对象对应的值对象 boolean containsKey(Object key) Map容器中是否包含键对象对应的键值对 boolean containsValue(Object value) Map容器中是否包含值对象对应的键值对 int size() 键值对的数量 boolean isEmpty() 判断Map是否为空 void clear() 清空所有键值对 多个Map void putAll(Map m) 将m容器中的所有键值对存放到本map对象 3.1 HashMap类HashMap底层实现使用了哈希表，这是一种重要的数据结构。 哈希表的基本结构是&quot;数组＋单向链表&quot;。即结合了两者的优点，查询快，增删效率也快。 存储方式：将很多链保存在数组中 约定数组的长度必须是2的整数次幂，这样采用位算法可以实现取余的效果。 这些键值对越散越好，便于查询，因此为了得到更好的散列效果，jdk对hashcode还进行了2次散列处理，即移位操作，核心目标是为了分布更散更均匀 (1). hashmap如何存储数据①. put存储数据过程核心：产生hash值，该值用来对应数组的存储位置第一步，调用方法 key对象.hashcode() 生成 哈希码，注意整形数的哈希码是它本身第二步，调用hashMap的hash()方法 计算出哈希值，hash值=hashcode＆(数组长度-1)，哈希值的范围[0，table数组的length-1]，即数组的索引位置第三步，结合 hash值，key对象，value对象，next 四个数据生成entry对象，即链第四步，将这个entry对象存储到数组索引位置，当有多个entry对象的hash值一样时，前一个entry对象的next即指向后一个entry对象。 ②. get获取数据过程3.2 HashTable类——线程同步的HashMap类底层和用法与hashmap几乎一样，只是hashtable的方法添加了synchronized关键字，确保线程同步检查，效率较低。区别 hashmap线程不安全，效率高，允许key或value为nulltreemap线程安全，效率低，不允许key或value为null 3.3 TreeMap类treemap是红黑二叉树的典型实现源码中，root用来存储整个树的根节点，其类型为entry，entr底层源码中，存储了本身数据，左节点，右节点，父节点，节点颜色。treemap和hashmap实现了同样的接口map,因此用法对于调用者来说无区别，hashmap的效率高于treemap，在需要排序的map时才选用treemap #4. set接口继承自collection接口，有collection所有的方法，无新增方法 特点：无序，不可重复， 五序指set中元素无索引，只能遍历查找， 不可重复指不允许加入重复的元素。即新元素与set中的元素通过equal()方法对比为true，则不可加入。因此set中也只能放一个null元素。 (其实hashset的元素底层是map的key，因此不可重复，至于value只是定义了一个恒定的Object对象) 实现类：HashSet,TreeSet 4.1 HashSet(常用)4.2 TreeSet底层用treemap实现，内部维持了一个简化版的treemap.与hashset一样，通过key来存储set的元素，value是一个默认的Object对象。treeset需要对存储的元素进行排序，因此对应类需要实现Comparable接口，这样才能根据compareTo()方法比较对象之间的大小进行内部排序。 #5. Iterator迭代器的使用提供了统一的遍历容器的方式。 6. Collections工具类提供了对set，list，map，进行排序填充，查找元素的辅助方法，注意Collection是接口，Collections是工具类sort(list)按升序排序shuffle(list)随机排序reverse(list)倒序排序int binarySearch(list，Object)二分查找法查找特定对象","categories":[],"tags":[]},{"title":"SSM整合实例_05_删除人员","slug":"SSM整合实例-05-删除人员","date":"2019-10-10T08:46:39.000Z","updated":"2019-10-10T08:47:01.723Z","comments":true,"path":"2019/10/10/SSM整合实例-05-删除人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-05-删除人员/","excerpt":"","text":"","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_04_修改人员","slug":"SSM整合实例-04-修改人员","date":"2019-10-10T08:46:28.000Z","updated":"2019-10-10T12:38:18.452Z","comments":true,"path":"2019/10/10/SSM整合实例-04-修改人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/10/SSM整合实例-04-修改人员/","excerpt":"","text":"修改操作1.点击编辑，弹出修改的模态框，并显示用户信息 2.点击更新，完成用户修改 删除操作单个：url:/emp/{id} DELETE","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_03_增加人员","slug":"SSM整合实例-03-增加人员","date":"2019-10-08T14:14:41.000Z","updated":"2019-10-10T08:45:16.614Z","comments":true,"path":"2019/10/08/SSM整合实例-03-增加人员/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例-03-增加人员/","excerpt":"","text":"新增操作 需求： 思路： 点击“新增”按钮时弹出对话框，该对话框的功能为增加人员，需要获取到部门的数据到下拉框中 为“新增”绑定点击事件，包括： 1. 先清除表单数据 2. 调用获取部门数据的方法： 获取部门数据：发送ajax请求到处理器相应方法，收到返回结果，该返回结果是去数据库查询的部门列表 部门数据放到下拉框中：在ajax中，将success的result进行遍历，并拼接到标签中 3. 弹出模态框：利用bootstrap的$(id).modal({backdrop:&quot;static&quot;}); 对用户名进行ajax“重复”检验 为用户名输入框的change绑定事件：获取到输入框的值；发送ajax请求（发送用户名数据）到处理器校验用户名是否可用，得到返回值，返回值是一个状态码；判断该状态码：状态码为可用状态时，调用显示校验提示的方法，并给保存按钮添加一个自定义属性，属性值为success（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)）状态码为不可用状态时，调用显示校验提示的方法，显示提示信息，并给保存按钮添加一个自定义属性，属性值为error（$(&quot;按钮&quot;).attr(&quot;属性&quot;，“属性值”)），点击无效 点击“保存”按钮：对要提交给服务器的数据进行校验此时自动调转到包含该员工数据的那一页 为提示框的添加按钮绑定点击事件，包括： 1. 调用数据校验的方法。若该方法返回值为false,return false;该方法具体如下: 获取对应文本框中输入的值（var value=$(&quot;#文本框id&quot;).val()）； 定义一个正则表达式（var regValue=xxxxx）； 使用正则表达式对该值进行校验（regValue.test(value)），判断该语句的值； 是false则调用显示校验提示的方法并return false； 是true继续校验下一个； 以此类推，全部检验完毕，return true 1-1. 调用显示校验提示的方法： 先在每一个文本框下添加一个span标签，用来输出提示信息 清空当前元素的校验状态 判断输入框的格式 如果输入框格式有误，就在输入框的父标签（div）的class添加has error字段（bootstrap语法，该语法使文本框变红），在输入框的下一个标签（span）添加文本，文本为错误提示信息。 如果输入框格式正确，就在输入框的父标签（div）的class添加has success字段（bootstrap语法，该语法使文本框变绿） 该方法有相同之处，可抽取3个参数（输入框id，输入框格式状态，提示信息），不再详细说明。 2. 判断添加按钮的自定义属性（在上一个需求）是否为error，若是则return false; 3. 保存新增的员工数据：页面发送ajax请求（将表单数据序列化）到处理器的新增人员的方法，完成数据库数据的添加 4. 跳转到新员工的页面：调用to_page();，定义一个变量，赋值为总记录数，to_page(变量)即可跳转 重要数据，对用户进行后端校验（JSR303），唯一约束 1. 导入jar包：hibernate-validator（JSR303数据校验支持）2. 在处理器的保存人员方法中添加检验，并返回一个参数给请求页面的ajax解析","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SSM整合实例_02_主页设计","slug":"SSM整合实例_02_主页设计","date":"2019-10-08T14:08:54.000Z","updated":"2019-10-08T14:15:36.119Z","comments":true,"path":"2019/10/08/SSM整合实例_02_主页设计/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/SSM整合实例_02_主页设计/","excerpt":"","text":"查询操作需求：获取数据库的数据到主页。 1，查询步骤（model方法） 访问index.jsp index.jsp页面发出查询人员列表的请求 对应处理器（EmployeeController.java）接收请求，查询人员数据 响应数据到index.jsp页面 123456789101112//查询所有员工（分页查询）@RequestMapping(\"/emps\")public String getEmps(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model)&#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn,5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps,5); model.addAttribute(\"pageInfo\",page); return \"list\";&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;%--取出pageInfo属性中的list，将每一个list都命名为emp--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.list&#125;\" var=\"emp\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;emp.empId&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empName&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.gender=='M'?'男':'女'&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.email&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department.deptName&#125;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-primary btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt; 编辑 &lt;/button&gt; &lt;button class=\"btn btn-danger btn-sm\"&gt; &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\"&gt; 当前$&#123;pageInfo.pageNum&#125;/$&#123;pageInfo.pages&#125;页，共$&#123;pageInfo.total&#125;条记录 &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;%--首页即第一页--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=1\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;%-- 点击上一页，当前页面减1 --%&gt; &lt;%--如有上一页，就显示上一页图标，否则不显示（因为第一页时点击上一页会显示-1，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasPreviousPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum-1&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--该分页条显示的页码，每一个页码都用pageNum表示，遍历出来--%&gt; &lt;c:forEach items=\"$&#123;pageInfo.navigatepageNums&#125;\" var=\"page_Num\"&gt; &lt;%--当遍历出的这个页码和该显示页面的页码一致时,页码高亮--%&gt; &lt;c:if test=\"$&#123;page_Num == pageInfo.pageNum&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;%--当遍历出的这个页码和该显示页面的页码不一致时,页码不高亮，点击时可跳转至对应页面--%&gt; &lt;c:if test=\"$&#123;page_Num != pageInfo.pageNum&#125;\"&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;page_Num&#125;\"&gt;$&#123;page_Num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%-- 点击下一页，当前页面加1 --%&gt; &lt;%--如有下一页，就显示下一页图标，否则不显示（因为最后一页时点击下一页会显示不存在的页数，不符合规范）--%&gt; &lt;c:if test=\"$&#123;pageInfo.hasNextPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pageNum+1&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;%--末页即总页码--%&gt; &lt;li&gt;&lt;a href=\"$&#123;APP_PATH&#125;/emps?pn=$&#123;pageInfo.pages&#125;\"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2，查询步骤（ajax方法）（推荐） index.jsp页面发送ajax请求查询 服务器将查到的数据，以json字符串的形式返回给浏览器 浏览器收到js字符串，可使用js对json进行解析，使用js通过dom增删改来改变页面 返回json，实现客户端的无关性 给浏览器添加提示信息Msg,java EmployeeController.java 123456789101112131415161718192021222324252627282930313233343536373839package com.yanghan.crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.bean.Msg;import com.yanghan.crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; //查询所有员工（ajax分页查询） @RequestMapping(\"/emps\") @ResponseBody //可以将返回的pageInfo对象转为json字符串,需要导入Jackson包 public Msg getEmpsWithJson(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn, Model model) &#123; //查询方法前调用PageHelper.startPage方法，紧跟在这个方法后的第一个MyBatis查询方法会被进行分页。 PageHelper.startPage(pn, 5); //获取第pn页，10条内容 List&lt;Employee&gt; emps = employeeService.getAll(); //用PageInfo包装查询后的结果，只需将PageInfo交给页面即可 //PageInfo对象包含了详细的分页信息，包括查询出的数据,连续显示的页数 PageInfo page = new PageInfo(emps, 5); return Msg.success().add(\"pageInfo\",page); &#125;&#125; index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;%--引入核心标签库--%&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; &lt;script type=\"text/javascript\" src=\"static/js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;link href=\"static/bootstrap-3.3.7-dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 搭建显示页面 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 标题 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h1&gt;SSM-CRUD&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-8\"&gt; &lt;button class=\"btn btn-primary\"&gt;新增&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--数据--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-hover\" id=\"emps_table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--分页信息--&gt; &lt;div class=\"row\"&gt; &lt;!-- 分页文字信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_info_area\"&gt; &lt;/div&gt; &lt;!--分页条信息 --&gt; &lt;div class=\"col-md-6\" id=\"page_nav_area\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //页面加载完成后，直接发送ajax请求，获取到分页数据 $(function () &#123; //第一次去首页 to_page(1); &#125;); $(function () &#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=1\", type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125;); //跳到指定页面 function to_page(pn)&#123; $.ajax(&#123; url:\"$&#123;APP_PATH&#125;/emps\", data:\"pn=\"+pn, type:\"get\", success:function (result) &#123; //获得数据 // console.log(result); //1.解析并显示分页数据 build_emps_table(result); //2.解析并显示分页信息 build_page_info(result); //3.解析并显示分页条 build_page_nav(result); &#125; &#125;); &#125; //解析显示表格数据 function build_emps_table(result) &#123; //先清空上一次的数据 $(\"#emps_table tbody\").empty(); //取出json字符串的分页数据 var emps = result.extend.pageInfo.list; //遍历分页数据，index是索引，item是某个属性的集合 $.each(emps,function(index,item)&#123; // alert(item.empName); //构建单元格(append用来追加元素) var empIdTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empId); var empNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.empName); var genderTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.gender=='M'?\"男\":\"女\"); var emailTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.email); var deptNameTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(item.department.deptName); // &lt;button class=\"btn btn-primary btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"&gt;&lt;/span&gt;编辑 // &lt;/button&gt; // &lt;button class=\"btn btn-danger btn-sm\"&gt; // &lt;span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"&gt;&lt;/span&gt;删除 // &lt;/button&gt; var editBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-primary btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-pencil\").append(\"修改\"); var delBtn = $(\"&lt;button&gt;&lt;/button&gt;\").addClass(\"btn btn-danger btn-sm\") .append(\"&lt;span&gt;&lt;/span&gt;\").addClass(\"glyphicon glyphicon-trash\").append(\"删除\"); //将按钮放在一个单元格中 var btnTd = $(\"&lt;td&gt;&lt;/td&gt;\").append(editBtn).append(\" \").append(delBtn); //构建行(将单元格拼接成行，appendTo表示将该行添加到id为emps_table的tbody标签中) $(\"&lt;tr&gt;&lt;/tr&gt;\").append(empIdTd).append(empNameTd) .append(genderTd).append(emailTd).append(deptNameTd) .append(btnTd).appendTo(\"#emps_table tbody\"); &#125;); &#125; //解析显示分页信息 function build_page_info(result) &#123; //先清空上一次的数据 $(\"#page_info_area\").empty(); $(\"#page_info_area\").append(\"当前\" + result.extend.pageInfo.pageNum + \"/\" + result.extend.pageInfo.pages + \"页，共\" + result.extend.pageInfo.total + \"页\"); &#125; //解析构建分页条信息，点击进行跳转下一页 function build_page_nav(result) &#123; //先清空上一次的数据 $(\"#page_nav_area\").empty(); var ul = $(\"&lt;ul&gt;&lt;/ul&gt;\").addClass(\"pagination\"); //构建元素 var firstPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"首页\").attr(\"href\",\"#\")); var prePageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;laquo;\")); if (result.extend.pageInfo.hasPreviousPage == false) &#123; firstPageLi.addClass(\"disabled\"); prePageLi.addClass(\"disabled\"); &#125;else &#123; //为元素添加翻页事件 firstPageLi.click(function () &#123; to_page(1); &#125;); prePageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum -1); &#125;); &#125; var nextPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"&amp;raquo;\")); var lastPageLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(\"末页\").attr(\"href\",\"#\")); if (result.extend.pageInfo.hasNextPage == false) &#123; nextPageLi.addClass(\"disabled\"); lastPageLi.addClass(\"disabled\"); &#125;else &#123; nextPageLi.click(function () &#123; to_page(result.extend.pageInfo.pageNum +1); &#125;); lastPageLi.click(function () &#123; to_page(result.extend.pageInfo.pages); &#125;); &#125; //页码1，2，3，4 ul.append(firstPageLi).append(prePageLi); $.each(result.extend.pageInfo.navigatepageNums,function (index, item) &#123; var numLi = $(\"&lt;li&gt;&lt;/li&gt;\").append($(\"&lt;a&gt;&lt;/a&gt;\").append(item)); if (result.extend.pageInfo.pageNum == item) &#123; numLi.addClass(\"active\"); &#125; numLi.click(function () &#123; to_page(item); &#125;); ul.append(numLi); &#125;); ul.append(nextPageLi).append(lastPageLi); //把ul加入到nav var navEle = $(\"&lt;nav&gt;&lt;/nav&gt;\").append(ul); navEle.appendTo(\"#page_nav_area\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"JS语法基础2","slug":"JS语法基础2","date":"2019-10-08T07:15:05.000Z","updated":"2019-10-08T07:15:05.569Z","comments":true,"path":"2019/10/08/JS语法基础2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS语法基础","slug":"JS语法基础","date":"2019-10-08T07:14:58.000Z","updated":"2019-10-08T07:14:58.895Z","comments":true,"path":"2019/10/08/JS语法基础/","link":"","permalink":"https://cometorbityh.github.io/2019/10/08/JS语法基础/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SSM整合实例_01_环境搭建","slug":"SSM整合实例_01_环境搭建","date":"2019-10-07T05:59:45.000Z","updated":"2019-10-08T14:19:02.021Z","comments":true,"path":"2019/10/07/SSM整合实例_01_环境搭建/","link":"","permalink":"https://cometorbityh.github.io/2019/10/07/SSM整合实例_01_环境搭建/","excerpt":"","text":"环境搭建1，创建maven工程2，引入jar包 spring相关jar包 springmvc相关jar包 mybatis相关jar包（逆向工程jar包） 数据库连接池，驱动包 其他（jstl，servlet-api，junit，pageHelper分页插件） 3，引入bootstrap前端框架+JS4，编写ssm整合的关键配置文件 web.xml applicationContext.xml springmvc.xml mybatis-config.xml 5，mybatis逆向工程 + 测试（1）mybatis逆向工程生成对应的bean以及mapper 在项目下新建mbg.xml，修改部分内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--mybatis逆向工程--&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!--不生成注释--&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息--&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javaBean生成的位置--&gt; &lt;javaModelGenerator targetPackage=\"com.yanghan.crud.bean\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 指定sql映射文件位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\".\\src\\main\\resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定dao接口生成的位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.yanghan.crud.dao\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定每个表的生成策略:javaBean的名字--&gt; &lt;!-- &lt;table schema=\"DB2ADMIN\" tableName=\"ALLTYPES\" domainObjectName=\"Customer\" &gt;--&gt; &lt;!-- &lt;property name=\"useActualColumnNames\" value=\"true\"/&gt;--&gt; &lt;!-- &lt;generatedKey column=\"ID\" sqlStatement=\"DB2\" identity=\"true\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"DATE_FIELD\" property=\"startDate\" /&gt;--&gt; &lt;!-- &lt;ignoreColumn column=\"FRED\" /&gt;--&gt; &lt;!-- &lt;columnOverride column=\"LONG_VARCHAR_FIELD\" jdbcType=\"VARCHAR\" /&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;table tableName=\"tbl_emp\" domainObjectName=\"Employee\"/&gt; &lt;table tableName=\"tbl_dept\" domainObjectName=\"Department\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; com.xxx.crud.test包下新建MBGTest.java。 把以下内容复制进入。并修改File configFile = new File(&quot;mbg.xml&quot;); 执行该方法，即可自动生成。 123456789101112131415161718192021222324252627package com.yanghan.crud.test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;//逆向工程测试类public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; MapperTest.java测试是否连接成功数据库（可做增删改操作） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.yanghan.crud.test;import com.yanghan.crud.bean.Department;import com.yanghan.crud.bean.Employee;import com.yanghan.crud.dao.DepartmentMapper;import com.yanghan.crud.dao.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;/** * 测试dao层工作 * Spring的项目可以使用Spring的单元测试，可以自动注入我们需要的组件 * 1、导入SpringTest模块 * 2、@ContextConfiguration指定spring配置文件的位置 * 3、直接autowired要使用的组件即可 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession sqlSession; /** * 测试DepartmentMapper */ @Test public void testCRUD() &#123; //1、插入/删除部门// departmentMapper.insertSelective(new Department(null,\"测试1\"));// departmentMapper.insertSelective(new Department(null,\"测试2\"));// departmentMapper.deleteByPrimaryKey(3); //2、生成员工数据，测试员工插入// employeeMapper.insertSelective(new Employee(null,\"Jerry\",\"M\",\"Jerry@qq.com\",1)); //3、批量插入多个员工；使用可执行批量操作的sqlSession //for循环并非批量，是插入1000次，而sqlsession是预编译sql，然后修改参数进行插入 EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); String uid = \"initUid\"; int rid1 = 666; int rid2 = 666; for (int i = 0; i &lt; 100; i++) &#123; uid = UUID.randomUUID().toString().substring(0, 5)+i; rid1 = (int)(1+Math.random()*(2-1+1)); rid2 = (int)(1+Math.random()*(2-1+1)); mapper.insertSelective(new Employee(null,uid,(rid1==1)?(\"M\"):(\"W\"),uid+\"@test.com\",rid2)); &#125; &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://cometorbityh.github.io/tags/SSM/"}]},{"title":"SpringMVC(3)","slug":"SpringMVC-3","date":"2019-10-06T07:11:34.000Z","updated":"2019-10-06T07:11:34.539Z","comments":true,"path":"2019/10/06/SpringMVC-3/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringMVC(2)","slug":"SpringMVC-2","date":"2019-10-06T07:11:26.000Z","updated":"2019-10-06T14:28:25.267Z","comments":true,"path":"2019/10/06/SpringMVC-2/","link":"","permalink":"https://cometorbityh.github.io/2019/10/06/SpringMVC-2/","excerpt":"","text":"文件上传文件上传需要的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 1.传统方式实现文件上传2.SpringMVC实现本地服务器文件上传在springmvc.xml文件中配置 文件解析器 对象 12345&lt;!-- 配置文件解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--最大上传大小：10MB=10*1024*1024B--&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; 3.SpringMVC实现跨服务器文件上传跨服务器上传文件需要的2个jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 4.代码 index.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;SpringMVC方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;传统方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;h3&gt;跨服务器方式文件上传&lt;/h3&gt; &lt;form action=\"file/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件：&lt;input type=\"file\" name=\"upload\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.yanghan.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;@Controller@RequestMapping(\"/file\")public class FileController &#123; /** * 跨服务器文件上传 * @return */ @RequestMapping(\"/fileupload3\") public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"跨服务器文件上传...\"); // 定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 创建客户端的对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; &#125; /** * SpringMVC文件上传 * @return */ @RequestMapping(\"/fileupload2\") public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println(\"springmvc文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return \"success\"; &#125; /** * 文件上传 * @return */ @RequestMapping(\"/fileupload1\") public String fileupload1(HttpServletRequest request) throws Exception &#123; System.out.println(\"文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for(FileItem item:items)&#123; // 进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; // 说明普通表单向 &#125;else&#123; // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid+\"_\"+filename; // 完成文件上传 item.write(new File(path,filename)); // 删除临时文件 item.delete(); &#125; &#125; return \"success\"; &#125;&#125; 异常处理 web.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 字符过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp【测试页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"ex/testException\"&gt;异常测试&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ExceptionController.java【处理器】 1234567891011121314151617181920212223242526package com.yanghan.controller;import com.yanghan.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/ex\")public class ExceptionController &#123; @RequestMapping(\"/testException\") public String testException() throws SysException &#123; System.out.println(\"testException执行了...\"); try &#123; // 模拟异常 int a = 10/0; &#125; catch (Exception e) &#123; // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new SysException(\"出现异常了...\"); &#125; return \"success\"; &#125;&#125; SysException.java【系统异常实体类】 1234567891011121314151617181920212223package com.yanghan.exception;/** * 自定义异常类 */public class SysException extends Exception&#123; // 存储提示信息的 private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; SysExceptionResolver.java【异常处理器】 12345678910111213141516171819202122232425262728293031323334package com.yanghan.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver&#123; //处理异常业务逻辑 public ModelAndView resolveException (HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // 获取到异常对象 SysException e = null; if(ex instanceof SysException)&#123; e = (SysException)ex; &#125;else&#123; e = new SysException(\"系统正在维护....\"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\",e.getMessage()); mv.setViewName(\"error\"); return mv; &#125;&#125; springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.yanghan\"/&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!--配置异常处理器--&gt; &lt;bean id=\"sysExceptionResolver\" class=\"com.yanghan.exception.SysExceptionResolver\"/&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; error.jsp【返回的错误信息页面】 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;errorMsg&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"SpringMVC(1)","slug":"SpringMVC-1","date":"2019-10-05T12:17:55.000Z","updated":"2019-10-06T10:19:45.392Z","comments":true,"path":"2019/10/05/SpringMVC-1/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/SpringMVC-1/","excerpt":"","text":"1. SpringMVC1.1. 简介SpringMVC框架基于组件方式的执行流程 1.导包 2.写配置 配置前端控制器。指明springmvc的配置文件的位置 配置视图解析器，简化方法返回值（目标页面地址），实现前缀+返回值+后缀以拼接地址。 3.测试 1.2. 入门案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.orbit&lt;/groupId&gt; &lt;artifactId&gt;springmvc_01_newstart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_01_newstart Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvc_01_newstart&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;============================== web.xml ==============================&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置解决中文乱码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.orbit\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器对象:可以根据服务方法的返回值,自动的拼接最终的跳转路径--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持：自动配置处理器映射器和处理器适配器 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 1234567891011121314151617============================== FirstController.java ==============================package com.orbit.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class firstController &#123; @RequestMapping(path=\"/hello\") public String sayHello()&#123; System.out.println(\"hello,SpringMVC\"); return \"success\"; &#125;&#125; 12345678910111213141516171819202122232425============================== index,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;第一个springMVC程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;点我跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;============================== success,jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 跳转成功！&lt;/body&gt;&lt;/html&gt; 1.3. 用到的注解@RequestMapping:表示请求的具体的模块 value=&quot;/xx&quot;或path=&quot;/xx&quot;：指定请求的url method={RequestMethod.GET}：指定请求方式，GET，POST，…，是一个枚举类型的数组 params={&quot;&quot;}：指定请求中必须包含的请求参数的表达式集，是一个String类型的数组 params={&quot;param1&quot;}：请求中必须包含请求参数params1 params={&quot;!param1&quot;}：请求中不能包含请求参数param1 params={&quot;param1=123&quot;}：请求中必须包含请求参数params1，且其值必须是123 params={&quot;param1!=123&quot;}：请求中包含的请求参数的值不能是123（也可不包含param1，此时param1=null） params={&quot;param1=123&quot;,&quot;param2=zs&quot;}：请求中必须包含请求参数params1和param2，且param1=123,param2=zs headers={&quot;k=v&quot;}：指定发送的请求中必须包含的请求头 @RequestParam：获取请求的参数值，相当于request.getParameter(&quot;user&quot;); value=&quot;user&quot;：指定请求参数的key required：是否必须包含请求参数，true表示url一定要包含该请求参数，false表示可不包含 defaultValue：设置该参数的默认值 RequestHeader：获取请求头的部分的值 @RequestBody：获取请求体内容 @PathVariable获取请求路径中对应占位符的值。例如：url中有/delete/{id}，{id}就是占位符 。注意：1个占位符只能占1层路径 @ModelAttribute：出现在方法上：表示当前方法会在控制器方法执行前线执行。出现在参数上：获取指定的数据给参数赋值。 @CookieValue·：用于获取指定cookie的名称的值 2. 请求参数绑定2.1. 传入POJO，级联12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970============================== Account.java ==============================package com.orbit.domain;public class Account &#123; private Integer id; private String pwd; private Double money; private User user; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; //getter setter toString&#125;package com.orbit.domain;public class User &#123; private String uname; private Integer uage; //getter setter toString&#125;============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"params/saveAccount\" method=\"post\"&gt;序号：&lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"pwd\"&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"user.uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"user.uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"list[0].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"list[0].uage\"&gt;&lt;br&gt; 用户：&lt;input type=\"text\" name=\"map['one'].uname\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"map['one'].uage\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;============================== ParamsController.java ==============================package com.orbit.controller;import com.orbit.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/params\")public class ParamsController &#123; @RequestMapping(\"/saveAccount\") public String savaAccount(Account account)&#123; System.out.println(account); return \"success\"; &#125;&#125;============================== 其他页面同入门案例 ============================== 2.2. 数据输出的方式（1）传入原生API (方式1)SpringMVC的handler接收如下的ServletAPI类型的参数： 123456789• HttpServletRequest• HttpServletResponse• HttpSession• java.security.Principal• Locale• InputStream• OutputStream• Reader• Writer （2）Map，Model，ModelMap（方式2）处理方法返回时，Map中的数据会自动添加到模型中 （3）ModelAndView作为返回值输出（方式3） 方法的返回值可以是ModelAndView类型， 既包含视图信息（页面地址），也包含模型数据（携带到页面的数据），模型数据存放在请求域（requestScope）中。 （4）@SessionAttributes临时保存数据（方式4）(了解)@SessionAttributes只能标在类上，是SpringMVC提供的一种临时在session域中保存数据的方式。 value=&quot;xx&quot;：本类中以xx为key所对应的值，临时复制到session域中 规则：将该类中保存在 BindingAwareModelMap 或 ModelAndView 中的数据，临时复制一份到session域中。 （5）@ModelAttribute（6）@ResponseBody响应json数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152============================== pom.xml ============================== &lt;dependencies&gt; &lt;!-- 新增依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;============================== springmvc.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yanghan\"&gt;&lt;/context:component-scan&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 告诉前端控制器，哪些路径下的资源不拦截--&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\"/&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839============================== index.jsp ==============================&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 页面加载，绑定单击事件 $(function()&#123; $(\"#btn\").click(function()&#123; // alert(\"hello btn\"); // 发送ajax请求 $.ajax(&#123; // 编写json格式，设置属性和值 url:\"demo/testAjax\", contentType:\"application/json;charset=UTF-8\", data:'&#123;\"uid\":\"10001\",\"uname\":\"zs\",\"upwd\":123&#125;', dataType:\"json\", type:\"post\", success:function(data)&#123; // data服务器端响应的json的数据，进行解析 alert(data); alert(data.uid); alert(data.uname); alert(data.upwd); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122============================== TestController.java ==============================package com.yanghan.controller;import com.yanghan.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(\"/demo\")public class TestController &#123; @RequestMapping(\"/testAjax\") public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println(user.toString()); user.setUname(\"张三\"); return user; &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"},{"name":"SpringMVC框架","slug":"SpringMVC框架","permalink":"https://cometorbityh.github.io/tags/SpringMVC框架/"}]},{"title":"Spring框架——AOP","slug":"Spring框架——AOP","date":"2019-10-05T05:35:06.000Z","updated":"2019-10-05T12:22:59.679Z","comments":true,"path":"2019/10/05/Spring框架——AOP/","link":"","permalink":"https://cometorbityh.github.io/2019/10/05/Spring框架——AOP/","excerpt":"","text":"3. Spring中的AOP3.1. 引出问题（1）完善之前的account案例 （2）引出问题 （3）动态代理的2种实现方式 （4）解决问题 3.2. AOP的基本概述（1）AOP中的一些专业术语 连接点（Joinpoint）：业务层中所有的方法 切入点（Pointcut）：业务层中所要代理增强的方法 切入点一定是连接点，但连接点不一定是切入点 通知/增强（advice）：拦截到连接点后做的事情即通知。 通知类型：前置通知，后置通知，异常通知，最终通知，环绕通知 引介（Introduction）一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 目标对象（Target）代理的目标对象。 代理（Proxy）一个类被 AOP 织入增强后，就产生一个结果代理类。 切面（Aspect） 是切入点和通知（引介）的结合。 织入（Weaving）: 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 3.3. 基于XML的AOP配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day03_eesy_04adviceType&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.itheima.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\" &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154============================== AccountService.java ==============================package com.itheima.service;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /** * 删除账户 * @return */ int deleteAccount();&#125;============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService&#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125; ============================== Logger.java ============================== package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试AOP的配置 */public class AOPTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); //3.执行方法 as.saveAccount(); &#125;&#125; 3.4. 基于注解的AOP配置@Pointcut(&quot;execution(* com.xxx.service.impl.*.*(..))&quot;)：切入点表达式注解 private void pc(){} @Before(pc())：前置通知注解 @AfterReturning(&quot;pc()&quot;)：后置通知注解 @AfterThrowing(&quot;pc()&quot;)：异常通知注解 @After&quot;pc()&quot;)：最终通知注解 @Around(&quot;pc()&quot;)：环绕通知注解 注意： 使用注解AOP配置会先执行最终通知，后执行后置通知/异常通知； 使用环绕通知则按照正常顺序执行。 因此实际开发时应该注意这个细节，正确选择合适的注解。 12345678910111213141516171819202122============================== pom.xml ==============================......============================== bean.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置spring开启注解aop的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119============================== AccountService.java ==============================......============================== AccountServiceImpl.java ==============================package com.itheima.service.impl;import com.itheima.service.IAccountService;import org.springframework.stereotype.Service;/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService&#123; public void saveAccount() &#123; System.out.println(\"执行了保存\");// int i=1/0; &#125; public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i); &#125; public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125;============================== Logger.java ==============================package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 用于记录日志的工具类，它里面提供了公共的代码 */@Component(\"logger\")@Aspect //表示当前类是切面public class Logger &#123; @Pointcut(\"execution(* com.itheima.service.impl.*.*(..))\") private void pc()&#123;&#125; /** * 前置通知 */ @Before(\"pc()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ @AfterReturning(\"pc()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ @AfterThrowing(\"pc()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ @After(\"pc()\") public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pc()\") public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;============================== AOPTest.java ==============================......","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring——JdbcTemplate,事务控制","slug":"Spring——JdbcTemplate-事务控制","date":"2019-10-04T15:13:33.000Z","updated":"2019-10-05T05:33:44.980Z","comments":true,"path":"2019/10/04/Spring——JdbcTemplate-事务控制/","link":"","permalink":"https://cometorbityh.github.io/2019/10/04/Spring——JdbcTemplate-事务控制/","excerpt":"","text":"4. Spring中的JdbcTemlateJdbcTemplate 是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。 导包： spring-jdbc-5.0.2.RELEASE.jar （数据库相关） spring-tx-5.0.2.RELEASE.jar（事务相关） JdbcTemplate的基础案例： 123456789101112131415============================== Account.java ============================== package com.yanghan.domain;/** * 账户实体类 */public class Account &#123; private Integer id; private String name; private Float money; //get + set //toString()&#125; 12345678910111213141516171819202122232425262728293031323334353637============================== pom.xml ==============================&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yanghan&lt;/groupId&gt; &lt;artifactId&gt;spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5. Spring中的事务控制","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"Spring框架——IOC","slug":"Spring框架——IOC","date":"2019-10-02T07:53:22.000Z","updated":"2019-10-05T05:34:40.467Z","comments":true,"path":"2019/10/02/Spring框架——IOC/","link":"","permalink":"https://cometorbityh.github.io/2019/10/02/Spring框架——IOC/","excerpt":"","text":"1. Spring框架的基本概述1.1. Spring是什么？ 2. Spring中的IOCIOC : invertion of control（控制反转）——把对象的创建交给spring（IOC容器）来处理 IOC容器的理解：读取一个全限定类名，反射创建一个对象，并且存入核心容器中，最后通过对应的id来将该对象取出来。 2.1. 基于XML的IOC配置2.1.1. IOC中的bean标签 作用： 用于配置对象让 spring 来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 * singleton :默认值，单例的. * prototype :多例的. * request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. * session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. * global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session. init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162------------------------------ AccountService.java ------------------------------package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125;------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;public class AccountServiceImpl implements AccountService &#123; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125;------------------------------ bean.xml ------------------------------ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); System.out.println(as); &#125;&#125;------------------------------ 输出结果 ------------------------------ com.yanghan.service.impl.AccountServiceImpl@26be92ad 2.1.2. IOC 中的 DI 依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。注入依赖。 （1）构造函数注入 顾名思义，就是使用类中的构造函数，给成员变量赋值。 注意：赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。 要求： 类中需要提供一个对应参数列表的构造函数。 （有参构造函数） 标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 （需记忆参数索引位置，因此不用） type :指定参数在构造函数中的数据类型 （若有2个数据类型一样的参数则无法辨别，因此不用） name:指定参数在构造函数中的名称 用这个找给谁赋值 （推荐使用） （==上面三个找要赋值的参数，下面两个是给参数赋值==） value:它能赋的值是基本数据类型和 String 类型 ref :它能赋的值是其他 bean 类型，引用关联的bean对象，必须得是在配置文件中配置过的 bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283------------------------------ AccountService.java ------------------------------ package com.yanghan.service;public interface AccountService &#123; void saveAccount();&#125; ------------------------------ AccountServiceImpl.java ------------------------------ package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来处理--&gt; &lt;!-- id=\"唯一标识符 \" class= \"要反射的全限定类名\" --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"西门吹雪\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ 西门吹雪,18,Thu Oct 03 13:56:03 CST 2019 （2）set方法注入 前提：setter方法 + 无参构造函数 标签：property 属性： name：找的是类中 set 方法后面的部分 ref ：引用其他 bean 类型 value：基本数据类型和 string 类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.Date;public class AccountServiceImpl implements AccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+\",\"+age+\",\"+birthday); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- set方法注入 --&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"菠萝吹雪\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"20\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt;------------------------------ 输出结果 ------------------------------菠萝吹雪,20,Thu Oct 03 14:45:23 CST 2019 （3）集合数据的注入（set方法） 在注入集合数据时，只要结构相同，标签可以互换 用于给List 结构集合注入的标签： list，array，set 用于给Map结构集合注入的标签：map，props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123------------------------------ AccountServiceImpl.java ------------------------------package com.yanghan.service.impl;import com.yanghan.dao.AccountDao;import com.yanghan.dao.impl.AccountDaoImpl;import com.yanghan.service.AccountService;import java.util.*;public class AccountServiceImpl implements AccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,Object&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, Object&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125;------------------------------ bean.xml ------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.yanghan.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"myStrs\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"张三\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"name\" value=\"李四\"&gt;&lt;/entry&gt; &lt;entry key=\"sex\" value=\"男\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;------------------------------ test.java ------------------------------package com.yanghan.test;import com.yanghan.dao.AccountDao;import com.yanghan.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; //使用ApplicationContext接口来获取spring核心容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据bean的id获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125;------------------------------ 输出结果 ------------------------------ [AAA, BBB, CCC][AAA, BBB, CCC][AAA, BBB, CCC]&#123;name=张三, sex=男&#125;&#123;name=李四, sex=男&#125; 2.2. 基于注解的IOC配置spring中IOC的常用注解学习基于注解的 IoC 配置，注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 实际开发中，基于注解和XML的IOC配置混合使用。 根据作用分类 基于XML的IOC配置 基于注解的IOC配置 创建对象（将当前类对象存入spring容器中） &lt;bean&gt;标签 @Component(value=&quot;bean-id&quot;) 默认值为当前类名首字母小写@Controller(value=&quot;bean-id&quot;)：用于表现层@Service(value=&quot;bean-id&quot;)：用于业务层@Repository(value=&quot;bean-id&quot;)：用于持久层 注入数据 &lt;bean&gt;标签中的 &lt;property&gt;标签 （1）注入其他bean：@autowired 自动按照类型注入。即bean的class ＊若容器中有唯一的bean对象类型与要注入的变量类型匹配，则注入成功。 ＊若容器中没有bean对象类型与要注入的变量类型匹配，则注入失败，报错。 ＊若容器中有多个bean对象类型匹配与要注入的变量类型匹配，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 出现位置：变量上 ／ 方法上@qualifier(value=&quot;bean-id&quot;) 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。 在给字段注入时，不能独立使用，必须和@autowired一起使用； 在给方法参数注入时，可以独立使用。@resource(name=&quot;bean-id&quot;)（2）注入基本类型和String：@Value(value=&quot;具体数据&quot;)：可以使用spEL（spring的EL表达式）（3）注入集合类型：只能通过XML来实现 改变作用范围 &lt;bean&gt;标签中的 scope属性 @Scope(value=&quot;&quot;) 指定bean的作用范围； value的取值：singleton，prototype，request，session，globalsession 生命周期相关 &lt;bean&gt;标签中的 init-method属性 destory-method属性 2.3. IOC案例（持久层技术选择：dbutils）案例1：使用XML方式实现单表的CRUD操作案例2：使用XML方式和注解方式实现单表的CRUD操作案例3：使用纯注解的方式实现单表的CRUD操作（spring的一些新注解使用） @Configuration：表示该类是一个配置类 @ComponentScan( value=&quot;xxx&quot; )：指定spring在创建容器时要扫描的包 @ComponentScan( basePackages=”xxx” ) @Bean(name= &quot;bean-id&quot; )：把当前方法的返回值作为bean对象存入spring的ioc容器中 当我们用注解配置方法时，若方法有参数，spring框架会去容器中查找有无可用的bean对象，查找的方式与Autowired注解一致。 @Import( )：导入其他的配置类，value的值是配置类的字节码 带有Import注解的配置类称为父配置类，被导入的配置类称为子配置类 @PropertySource：导入配置文件 spring和Junit整合#","categories":[{"name":"框架","slug":"框架","permalink":"https://cometorbityh.github.io/categories/框架/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://cometorbityh.github.io/tags/Spring框架/"}]},{"title":"JavaWeb--ajax","slug":"JavaWeb-ajax","date":"2019-09-27T09:58:24.000Z","updated":"2019-09-30T14:41:13.904Z","comments":true,"path":"2019/09/27/JavaWeb-ajax/","link":"","permalink":"https://cometorbityh.github.io/2019/09/27/JavaWeb-ajax/","excerpt":"","text":"ajax简介1. 概念1.1. Ajax 【 Asynchronous JavaScript And XML 】【 异步的JavaScript和XML 】 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 1.2. 异步和同步的概念​ 同步：客户端给服务端发送请求，客户端必须等待服务器端的响应，在等待服务端处理请求的过程中，客户端无法进行其他操作； ​ 异步：客户端给服务端发送请求，客户端无需等待服务器端的响应，在等待服务端处理请求的过程中，客户端可以进行其他操作。 2. 实现方式2.1. 原生的JS实现方式（了解） XMLHttpRequest 用于在后台与服务器交换数据 XMLHttpRequest对象的2个方法 open 方法 １. 作用：与服务器建立连接。 ２. open方法的３个参数: (1). 请求方式(GET、POST) (2). 请求的URL： ＊若请求方式为GET，则将请求参数拼接在URL后方，send方法为空参或null ＊请求参数为POST，则将请求参数在send方法中定义 (3). 是否为异步请求，true为异步，false为同步send 方法 1. 作用：发送请求 2. send(xxx); XMLHttpRequest对象的2个属性 readyState（就绪状态） 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status（响应状态码） 200: “OK” 404: 未找到页面 2.2. JQuery实现方式（掌握） $.ajax( ) 语法：$.ajax({键值对});由于有很多内置键，因此举个例子介绍常用的几个键： $.get( ) 语法：$.get ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） $.post( ) 语法：$.post ( url, [data], [callback], [type] )参数： ＊url：请求路径 ＊data：请求参数 ＊callback：回调函数 ＊type：响应结果的类型注意：（ [ ] 中的参数可不写） —– 举个例子 —– ajax01.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;发送异步请求&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function fun1() &#123; $.ajax(&#123; url:\"ajaxServlet\", //请求路径 type:\"POST\", //请求方式 data:&#123;\"username\":\"Ajax\"&#125;, //请求参数 //data:\"username=jack\", success:function (data) &#123; //响应成功后的回调函数 alert(data); &#125;, error:function () &#123; alert(\"出错了\"); &#125;, &#125;); &#125; function fun2() &#123; $.get(\"ajaxServlet\",&#123;username:\"Get\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; function fun3() &#123; $.post(\"ajaxServlet\",&#123;username:\"Post\"&#125;,function (data) &#123; alert(data); &#125;,\"text\"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"submit\" value=\"ajax方式发送异步请求\" onclick=\"fun1();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"get 方式发送异步请求\" onclick=\"fun2();\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"post方式发送异步请求\" onclick=\"fun3();\"&gt;&lt;/body&gt;&lt;/html&gt; AjaxServlet.java 12345678910111213141516171819202122232425package com.test.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/ajaxServlet\")public class AjaxServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求参数 String username = request.getParameter(\"username\"); //2.处理业务逻辑 //3.打印username System.out.println(username); //4.响应 response.getWriter().write(\"hello:\"+username); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; JSON1. 概念 【JSON】【Javascript Object Notation】【JavaScript对象表示法】 进行数据的传输。是存储和交换文本信息的语法。 类似XML，但比XML更小更快，更易解析 2. JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 2.1. JSON定义数据的规则数据在名称/值对中 ＊键用引号（单双均可）括起来，也可以不使用引号 ＊JSON 值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 数据由逗号分隔：多个键值对用逗号隔开 花括号保存对象 方括号保存数组 2.2. JSON获取数据的规则 json对象的键名 json对象[“键名”] 数组对象[索引] 2.3. JSON遍历数据for ( var 键 in json对象 ) { ​ alert ( json对象 [ 键 ] ); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;script&gt; //1. 定义基本格式 var person = &#123;name:\"熊大\",age:23,gender:true&#125;; //alert(person.name); //遍历基本格式的json数据 for(var key in person)&#123; //key是字符串，person.key相当于person.\"xxx\"，因此不可取 alert(key + \":\" + person[key]); &#125; //2. 嵌套格式 （json对象中的数组） var persons = &#123; person:[ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ] &#125;; alert(persons.person[2].name); //3. 嵌套格式 （数组中的json对象） var persons2 = [ &#123;name:\"熊大\",age:23,gender:true&#125;, &#123;name:\"熊二\",age:23,gender:true&#125;, &#123;name:\"光头强\",age:23,gender:true&#125; ]; //alert(persons2[1].name); // 遍历数组中的json数据 for(var i=0;i&lt;persons2.length;i++)&#123; var p = persons2[i]; for(var key in p)&#123; alert(key + \":\" +p[key]); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JavaWeb项目——学生管理系统","slug":"JavaWeb项目——学生管理系统","date":"2019-09-06T08:31:03.000Z","updated":"2019-09-06T08:35:23.962Z","comments":true,"path":"2019/09/06/JavaWeb项目——学生管理系统/","link":"","permalink":"https://cometorbityh.github.io/2019/09/06/JavaWeb项目——学生管理系统/","excerpt":"","text":"1. 创建数据库123456CREATE TABLE `t_stu` (`id` int(10) NOT NULL AUTO_INCREMENT ,`uname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`upwd` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,PRIMARY KEY (`id`)) 2. 创建JDBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBC &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); System.out.println(\"驱动注册成功\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); System.out.println(\"数据库连接成功\"); stmt = conn.createStatement(); System.out.println(\"连接对象创建成功\"); String sql = \"select * from t_stu\"; rs = stmt.executeQuery(sql); if(rs.next()) &#123; System.out.print(rs.getInt(\"id\")+\" \"); System.out.print(rs.getString(\"uname\") + \" \"); System.out.println(rs.getString(\"upwd\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"项目","slug":"项目","permalink":"https://cometorbityh.github.io/tags/项目/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-09-03T08:55:59.000Z","updated":"2019-09-29T16:34:22.908Z","comments":true,"path":"2019/09/03/JDBC/","link":"","permalink":"https://cometorbityh.github.io/2019/09/03/JDBC/","excerpt":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。","text":"JDBC，Java DataBase Connectivity，Java语言连接数据库 JDBC是SUN公司制定的一套接口（面向接口编程，可以降低代码耦合度） 为什么要制定一套JDBC接口？ 每个数据库厂商的数据库实现原理都不一样，这样使用对应数据库产品编写对应的数据库操作代码。因此制定JDBC接口，而各大数据库厂商是JDBC的实现类，程序员只需面向接口编程即可。 一、JDBC编程6步 注册驱动（作用：告知Java程序，指明将要连接的数据库品牌） 获取连接（打开JVM的进程和数据库的进程之间的通道，属于进程之间的通信，使用完需要关闭） 获取数据库操作对象（专门执行sql语句的对象） 执行sql语句（DQL，DML） 处理查询指令集（只有当第四步执行的是select语句的时候，才需要第五步，否则省略） 释放资源（关闭JVM的进程和数据库的进程之间的通信资源） 二、JDBC的基本使用本例使用的是Mysql数据库，其驱动为mysql-connector-java-5.1.47.jar. 新建java project——在项目下新建文件夹lib——导入Mysql驱动jar包，右键jar包，点击build path,add 即可。 1. 使用Statement对数据库进行 “增删改” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.orbit.jdbc;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class test01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; // 1.注册驱动 //方式一// Driver driver = new com.mysql.jdbc.Driver();// Driver driver = new com.oracle.Driver.OracleDriver();// DriverManager.registerDriver(driver); //方式二(常用，原因是参数是字符串，字符串可以写到properties文件中，起到解耦合的作用) //该方法无需接收返回值，因为我们只想用它的类加载动作 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.获取连接 // oracle的URL： jdbc:oracle://localhost:1521:xxx String url = \"jdbc:mysql://localhost:3306/orbit\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); //com.mysql.jdbc.JDBC4Connection@3d646c37 System.out.println(conn); // 3.获取数据库操作对象（Statement专门执行sql语句） stmt = conn.createStatement(); // 4.执行sql (JDBC中的sql语句不需要分号结尾)// String sql = \"insert into dept(dno,dname,dage) values(2,'LS',23)\"; String sql = \"delete from dept where dno = 2\";// String sql = \"update dept set dname='王五',dage='20' where dno=1\"; // 专门执行DML语句的（insert，delete，update），返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); // 5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源，为了保证资源一定释放，必须放到finally语句中关闭资源 // 并且要遵循从小到大依次关闭，分别对其try...catch try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注册驱动的方式二为什么能够用放射直接调用？** ​ 因为mysql的驱动包中的com.mysql.jdbc包下的Driver.java的静态块中已经注册了驱动 2. 从属性配置文件中获取连接在src文件下新建file，输入”db.properties” db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/orbituser=rootpassword=123456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"insert into dept(dno,dname,dage) values(3,'娜可露露',22)\"; int count = stmt.executeUpdate(sql); System.out.println(count == 1?\"操作成功\":\"操作失败\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3. 使用Statement对数据库进行 “查” 操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.orbit.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;public class Test02 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"db\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); System.out.println(conn); stmt =conn.createStatement(); String sql = \"select dno,dname,dage from dept\"; rs = stmt.executeQuery(sql); System.out.println(rs); while(rs.next()) &#123; //该行有元素 int eno = rs.getInt(1); String ename = rs.getString(2); int eage = rs.getInt(3); //第二种写法：在getString中直接写入列名// String eno = rs.getString(\"dno\"); // String ename = rs.getString(\"dname\");// String eage = rs.getString(\"dage\"); System.out.println(eno +\" \" + ename + \" \" +eage); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4. 实例（设计登录界面，并解决SQL注入）这里使用到一个工具“PowerDesigner16.5”，用以物理建模，它与MySQL所不同的是，PowerDesigner用于设计阶段的物理建模，而MySQL用于开发阶段的数据处理。 123456789101112131415161718drop table if exists t_user;/*==============================================================*//* Table: t_user *//*==============================================================*/create table t_user( id bigint auto_increment, loginName varchar(255), loginPwd varchar(255), realName varchar(255), primary key (id));insert into t_user(loginName,loginPwd,realName) values('Zhangsan','123','张三');insert into t_user(loginName,loginPwd,realName) values('LiSi','123','李四');insert into t_user(loginName,loginPwd,realName) values('Wangwu','123','王五');commit;select * from t_user; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest02 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; Statement stmt = null; ResultSet rs = null; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql String sql = \"select * from t_user where loginName = '\"+loginName+\"' and loginPwd = '\"+loginPwd+\"'\"; //5、处理查询结果集 //发生sql语句给DBMS，DBMS进行sql编译 rs = stmt.executeQuery(sql); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 但是此时的程序存在一个安全问题，请看下面案例： 该现象称为“SQL注入”，这是一个安全隐患，是黑客入侵常用手段。 发生sql注入的原因是什么？ 用户输入的信息中含有sql的关键字，并且这些关键字拼接在sql语句中，参与sql语句的编译过程，导致sql语句原意被扭曲，进而引起sql注入。 如何解决SQL注入？ 只要用户提供的信息不参与SQL语句的编译过程，问题即可解决。 即便用户提供的信息中包含SQL的关键字，但这些关键字没有参与编译，就不会起作用 要想用户信息不参与SQL编译，需要用到java.sql.PreparedStatement PreparedStatement接口继承了java.sql.Statement，是预编译数据库操作对象(作用：编译、 ) 其原理为：预先对SQL语句的框架进行编译，然后再给SQL语句传值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.orbit.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class JDBCTest03 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.println(loginSuccess ? \"登录成功\":\"登录失败\"); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false失败，true成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //单独定义变量 String loginName = userLoginInfo.get(\"loginName\"); String loginPwd = userLoginInfo.get(\"loginPwd\"); /*编写JDBC代码*/ boolean loginSuccess = false; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、获取连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //3、执行sql语句框架 // ?表示一个占位符，用来接收值。注意？不加单引号 String sql = \"select * from t_user where loginName = ? and loginPwd = ?\"; //4、获取预编译数据库操作对象 ps = conn.prepareStatement(sql); //给占位符传值，若为字符串，其传值方法为setString(下标，值)； JDBC的下标都是从1开始的 ps.setString(1,loginName); //将对应下标的？替换为'xxxx' ps.setString(2,loginPwd); // ps.setString(3,100); 将对应下标的？替换为100 //5、处理查询结果集 rs = ps.executeQuery(); if(rs.next())&#123; loginSuccess = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI () &#123; Scanner s = new Scanner(System.in); System.out.print(\"用户名：\"); String loginName = s.nextLine(); System.out.print(\"密码：\"); String loginPwd = s.nextLine(); Map&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(\"loginName\", loginName); userLoginInfo.put(\"loginPwd\", loginPwd); return userLoginInfo; &#125;&#125; 比较Statement和PreparedStatement Statement存在注入问题，PreparedStatement可以解决SQL注入问题 Statement是编译一次执行一次，PreparedStatement是编译一次执行N次；（多次执行相同的sql语句时，DBMS只会编译一次就可以执行多次。Statement的sql语句中包含可变的参数，每次执行都要重新编译，PreparedStatement中sql语句占位符是固定的符号，只需编译一次即可执行多次） PreparedStatement会在编译阶段做类型的安全检查，如setString()方法中输入了int型字符，系统会报错。 因此，PreparedStatement使用场景较多。但需要sql注入时就要用到Statement 5.实例（Statement实现输入升序降序）升序降序用PreparedStatement传值给占位符？是不可行的，因为desc,asc都是字符串，传进入的话会加上引号，无法识别，因此需要用到Statement来实现输入升序降序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.orbit.jdbc;import java.sql.*;import java.util.Scanner;public class JDBCTest04 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(\"输入asc/desc进行升序/降序：\"); String keyWord = sc.nextLine(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); stmt = conn.createStatement(); String sql = \"select loginName from t_user order by loginName \"+ keyWord; rs = stmt.executeQuery(sql); while (rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 6.使用PreparedStatement增删改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.jdbc;import java.sql.*;public class JDBCTest05 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\");// String sql = \"insert into t_user(loginName,loginPwd,realName) values(?,?,?)\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"ZhaoLiu\");// ps.setString(2,\"123\");// ps.setString(3,\"赵六\");// String sql = \"delete from t_user set loginName = ? ,realName = ? where id = ?\";// ps = conn.prepareStatement(sql);// ps.setString(1,\"WangBa\");// ps.setString(2,\"王八\");// ps.setInt(3,4); String sql = \"delete from t_user where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1,4); int count = ps.executeUpdate(); System.out.println(count + \"行受影响\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 7. JDBC事务问题(模拟账户转账)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); //空指针异常，会导致程序中途停止运行 //导致用户10001丢失10000元，而用户10002也没收到10000元 String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解决方案(3行重要代码) conn.setAutoCommit(false); 禁用自动提交事务，开启事务 conn.commit(); 手动提交事务，即在此处才执行sql语句，事务结束 conn.rollback(); 回滚事务，回到事务发生之前数据，事务结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.orbit.jdbc;import java.sql.*;import java.util.Collection;public class JDBCTest06 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps =null; ResultSet rs = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); //禁用自动提交事务 conn.setAutoCommit(false); String sql = \"update t_act set balance = ? where actno = ?\"; ps = conn.prepareStatement(sql); //模拟用户10001转账给用户10002，转10000元 ps.setDouble(1,10000); ps.setInt(2,10001); int count = ps.executeUpdate(); String s =null; s.toString(); //用户10002收到汇款10000 ps.setDouble(1,10000); ps.setInt(2,10002); count += ps.executeUpdate(); System.out.println(count==2?\"转账成功\":\"转账失败\"); //手动提交事务 conn.commit(); &#125; catch (Exception e) &#123; if(conn != null)&#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 8.简化代码为工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.orbit.jdbc.DBUtil;import java.sql.*;public class DBUtil &#123; /*工具类的构造方法都是私有的， * 因为工具类的方法都是静态的，无需new对象，直接使用类名调用*/ private DBUtil()&#123;&#125; //静态代码块在类加载时执行，且只执行一次 //注册驱动只需要执行一次，因此放在静态代码块中 static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/orbit\",\"root\",\"123456\"); &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; //Statement ps面向抽象编程 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627package com.orbit.jdbc;import com.orbit.jdbc.utils.DBUtil;import java.sql.*;public class JDBCTest07 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = \"select loginName from t_user where loginName like ?\"; ps = conn.prepareStatement(sql); ps.setString(1,\"%g%\"); rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(\"loginName\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtil.close(conn,ps,rs); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://cometorbityh.github.io/tags/JDBC/"}]},{"title":"JSP——系统开发模型","slug":"JSP——系统开发模型","date":"2019-08-31T06:51:33.000Z","updated":"2019-09-03T15:06:52.679Z","comments":true,"path":"2019/08/31/JSP——系统开发模型/","link":"","permalink":"https://cometorbityh.github.io/2019/08/31/JSP——系统开发模型/","excerpt":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构","text":"系统开发模型，即系统架构，是整合系统程序的结构。 常见系统架构有2种：三层架构、MVC，这2种架构是为了降低系统模块之间的耦合度。 传统JavaWeb项目的系统开发模型经历过四大阶段： 纯JSP——JSP+JavaBean的Model1——MVC的Model2——MVC+三层架构 开发模型1. 纯JSP将所有业务处理、数据显示功能全都放在JSP页面完成。 缺点：代码结构乱，显示功能与业务处理功能代码没有划分，维护和升级麻烦。 2. JSP+JavaBean的Model1该开发模型将大多数业务处理交给专门的JavaBean完成。JSP页面主要负责数据显示功能。相对于“纯JSP”来说，已经得到极大改进。但是对于客户端的请求的解析，对于JavaBean对象的选择和创建，还是由JSP页面处理，即JSP还负责大量的请求解析、业务处理功能。 JavaBean的介绍 JavaBean 广义JavaBean，一般的Java类，主要功能：承载数据，业务处理 数据承载Bean：实体类，专门用于承载数据（装数据）的类，如User，Student 业务处理Bean：Service或Dao对象，专门用以处理用户提交请求的类。 狭义JavaBean：符合SUN公司提出的“JavaBean规范”的Java类。JavaBean规范规定，该类需满足以下四点： 公共，public class 实现Serializable接口 具备无参构造器 若有成员变量，则成员变量应该是私有的，且提供getter和setter 实际项目中，实体类（广义JavaBean的数据承载Bean）一般会被定义成满足“JavaBean规范”的狭义JavaBean 3. MVC的Model2MVC Model（模型），承载数据，并对用户的请求进行计算的模块。分为数据承载Bean和业务处理Bean，其实就是JavaBean。 View（视图），为用户提供使用界面，与用户进行直接交互 Controller（控制器），将请求转发给相应的Model进行处理，即选择使用哪一个JavaBean来处理请求。并提供Model的计算结果向用户进行相应的响应。 4. MVC + 三层架构三层架构 View层 / 视图层 / 表现层 / web层，编写用于接收用户请求的代码 Service层 / 服务层 / 业务层 / 逻辑层，编写系统的业务逻辑 Dao层 / 持久层 / 数据访问层，编写直接操作数据库的代码，Data Access Object数据访问对象 为了更好的降低各层之间的耦合度，在三层架构程序设计中，采用面向抽象编程，即上层对下层的调用是通过接口实现的。下层对上层的真正服务者，是下层接口的实现类，服务标准（接口）是相同的，服务提供者（实现类）可更换，这就实现了层间解耦合。 MVC + 三层架构 “MVC + 三层架构”开发模型，主要是指将MVC的业务处理Model分成了2层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。 “MVC + 三层架构”开发模型，是传统的JavaWeb项目最常用的开发模型。 实例：学生登录系统","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——JSTL","slug":"JSP——JSTL","date":"2019-08-30T08:22:01.000Z","updated":"2019-08-31T06:49:16.550Z","comments":true,"path":"2019/08/30/JSP——JSTL/","link":"","permalink":"https://cometorbityh.github.io/2019/08/30/JSP——JSTL/","excerpt":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。","text":"JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache给我们定义好的并且打包了的自定义标签库。 使用时，只需要导入该jar包，在页面中使用taglib指令导入，即可使用。 JSTL中定义了5个标签库： 核心标签库：主要用于完成基本逻辑运算 格式化标签库：主要用于完成日期、数字的格式化显示 EL函数标签库：定义了16个EL函数 SQL操作标签库：完成SQL操作，现已废弃不用，Java代码即可完全实现SQL操作 XML操作标签库：完成XML操作，现已废弃不用，Java代码即可完全实现XML操作 1 核心标签库（遍历数据等）12&lt;!-- 使用前先导入标签库 --&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; c:set——为指定变量赋值123456789101112131415161718192021222324252627282930313233package com.orbit.beans;public class Information &#123; private String uname; private String gender; public Information() &#123; // TODO Auto-generated constructor stub &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Information(String uname, String gender) &#123; super(); this.uname = uname; this.gender = gender; &#125; @Override public String toString() &#123; return \"Information [uname=\" + uname + \", gender=\" + gender + \"]\"; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:set 为域中的指定变量赋值 --------------- &lt;br/&gt; &lt;!-- var是变量名，value是变量值，scope是变量所在域，默认是pageContext --&gt; &lt;c:set var=\"name\" value=\"小明\" scope=\"session\"/&gt; name = $&#123;name &#125;&lt;br/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为域中的Bean对象的属性赋值 --------------- &lt;br/&gt; &lt;% Information info = new Information(); pageContext.setAttribute(\"info\", info); %&gt; &lt;!-- property表示属性名，value表示属性值，target表示属性的范围 --&gt; &lt;c:set value=\"小李\" property=\"uname\" target=\"$&#123;pageScope.info &#125;\"/&gt; &lt;c:set value=\"男\" property=\"gender\" target=\"$&#123;pageScope.info &#125;\"/&gt; info = $&#123;info&#125;&lt;br/&gt; &lt;br/&gt; --------------- c:set 为Map的键值赋值 --------------- &lt;br/&gt; &lt;% Map &lt;String,Object&gt; map = new HashMap(); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- property表示指定key，value表示key的值，target表示key的范围 --&gt; &lt;c:set value=\"网龙\" property=\"company\" target=\"$&#123;pageScope.map&#125;\"/&gt; &lt;c:set value=\"福建\" property=\"place\" target=\"$&#123;pageScope.map&#125;\"/&gt; map = $&#123;map &#125;&lt;/body&gt;&lt;/html&gt; c:remove——删除域中的属性1234567891011121314151617181920212223242526272829&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt; --------------- c:remove 删除指定域中的指定属性 --------------- &lt;br/&gt; &lt;c:set var=\"name\" value=\"page_name\"/&gt; &lt;c:set var=\"name\" value=\"req_name\" scope=\"request\"/&gt; &lt;c:set var=\"name\" value=\"ses_name\" scope=\"session\"/&gt; &lt;c:set var=\"name\" value=\"app_name\" scope=\"application\"/&gt; &lt;c:remove var=\"name\" scope=\"session\"/&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt; &lt;br/&gt; --------------- c:remove 删除所有域中的指定属性 --------------- &lt;br/&gt; &lt;c:remove var=\"name\" /&gt; name = $&#123;pageScope.name &#125;&lt;br/&gt; name = $&#123;requestScope.name &#125;&lt;br/&gt; name = $&#123;sessionScope.name &#125;&lt;br/&gt; name = $&#123;applicationScope.name &#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; c:out1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"test1\" value=\"&lt;h2&gt;hello,java!&lt;/h2&gt;\"/&gt; &lt;!-- value中EL的变量未定义时，默认输出default的值 --&gt; &lt;!-- value会原样输出其值，若该值带有html标签，可用escapeXml对该值进行解析 --&gt; &lt;c:out value=\"$&#123;test1 &#125;\" default=\"Hello,jsp!\" escapeXml=\"false\"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value=\"$&#123;test2 &#125;\" default=\"Hello,jsp!\"&gt;&lt;/c:out&gt;&lt;/body&gt;&lt;/html&gt; c:catch——捕获异常对象1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:catch var=\"math\"&gt; &lt;% int i = 7 / 0; %&gt; &lt;/c:catch&gt; $&#123;math.message &#125;&lt;/body&gt;&lt;/html&gt; c:if（掌握）——条件判断1234567891011121314151617&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set var=\"name\" value=\"熊大\"/&gt; &lt;c:if test=\"$&#123;name=='熊大' &#125;\"&gt; &lt;href a=\"#\"&gt;我是熊大&lt;/href&gt; &lt;/c:if&gt; &lt;/body&gt;&lt;/html&gt; c:choose（掌握）——条件判断123456789101112131415161718192021222324252627282930313233&lt;%@ page pageEncoding=\"UTF-8\" import=\"com.orbit.beans.Information,java.util.*\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"pageno\" value=\"2\"/&gt;&lt;c:set var=\"totalpage\" value=\"3\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;totalpage == 1 &#125;\"&gt; 首页 上一页 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == 1 &#125;\"&gt; 首页 上一页 &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:when test=\"$&#123;pageno == totalpage &#125;\"&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; 下一页 末页 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;a href=\"#\"&gt;上一页&lt;/a&gt; &lt;a href=\"#\"&gt;下一页&lt;/a&gt; &lt;a href=\"#\"&gt;末页&lt;/a&gt; 当前是 $&#123;pageno&#125; / $&#123;totalpage&#125; 页 &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach（掌握）——遍历&lt;c:forEach items=”${names }” var=”name” begin=”0” end=”9” step=”2”varStatus=”status” &gt; begin、end、step分别表示：起始序号，结束序号，跳跃步伐 varStatus属性定义了一个status名的对象作为varStatus的绑定值，该绑定值也就是status封装了当前遍历的状态。可以方便我们实现一些与行数相关的功能，如：奇数行、偶数行差异；最后一行特殊处理等等。先就varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=\"text/css\"&gt; .odd&#123; background-color: #F8E2D3; &#125; .even&#123; background-color: #D3EE66; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;------------ c:forEach 例1 ------------&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"喜羊羊\"); names.add(\"美羊羊\"); names.add(\"懒羊羊\"); names.add(\"沸羊羊\"); names.add(\"暖羊羊\"); names.add(\"慢羊羊\"); names.add(\"灰太狼\"); names.add(\"红太狼\"); names.add(\"小灰灰\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name，step步长 --&gt; &lt;c:forEach items=\"$&#123;names &#125;\" var=\"name\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/c:forEach&gt;------------ c:forEach 例2 ------------&lt;br/&gt; &lt;c:forEach var=\"num\" begin=\"0\" end=\"9\" step=\"2\"&gt; $&#123;num &#125; &lt;/c:forEach&gt; &lt;br/&gt; ------------ c:forEach 例3 ------------&lt;br/&gt;&lt;% List&lt;Information&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Information(\"张三\",\"男\")); persons.add(new Information(\"李四\",\"不详\")); persons.add(new Information(\"王五\",\"男\")); persons.add(new Information(\"赵六\",\"女\")); persons.add(new Information(\"田七\",\"女\")); persons.add(new Information(\"王八\",\"男\")); pageContext.setAttribute(\"persons\", persons); %&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;persons &#125;\" var=\"person\" varStatus=\"vs\"&gt; &lt;tr class=\"$&#123;vs.count % 2==0 ? 'even':'odd'&#125;\"&gt; &lt;td&gt;$&#123;vs.count &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.uname &#125;&lt;/td&gt; &lt;td&gt;$&#123;person.gender &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2 格式化标签库fmt:formatDate——日期格式fmt:parseDatefmt:formatNumberfmt:parseNumber12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*,com.orbit.beans.Information\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;---------- 格式化日期 ----------&lt;br/&gt; &lt;% Date now = new Date(); pageContext.setAttribute(\"now\", now); %&gt; now = $&#123;now &#125;&lt;br/&gt; now = &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\"/&gt;&lt;br/&gt; &lt;!-- 将结果保留在var属性中 --&gt; &lt;fmt:formatDate value=\"$&#123;now &#125;\" pattern=\"yyyy-MM-dd\" var=\"time\"/&gt; birthday = $&#123;time &#125;&lt;br/&gt;----------将字符串转换为日期 ----------&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\"/&gt;&lt;br/&gt; &lt;fmt:parseDate value=\"2020/08/08\" pattern=\"yyyy/MM/dd\" var=\"day\"/&gt; ay = $&#123;day &#125; &lt;br/&gt;---------- 格式化数字 ----------&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" groupingUsed=\"false\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxIntegerDigits=\"8\" minIntegerDigits=\"6\"/&gt;&lt;br/&gt; &lt;fmt:formatNumber value=\"$&#123;12345.6789 &#125;\" maxFractionDigits=\"6\" minFractionDigits=\"5\"/&gt;&lt;br/&gt; &lt;br/&gt;----------将字符串转换为数字 ----------&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\"/&gt;&lt;br/&gt; &lt;fmt:parseNumber value=\"$&#123;12345.6789 &#125;\" integerOnly=\"true\" var=\"num\"/&gt; num + 1 = $&#123;num + 1&#125;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"JSP——自定义标签","slug":"JSP——自定义标签","date":"2019-08-28T11:59:55.000Z","updated":"2019-08-30T08:49:28.154Z","comments":true,"path":"2019/08/28/JSP——自定义标签/","link":"","permalink":"https://cometorbityh.github.io/2019/08/28/JSP——自定义标签/","excerpt":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。","text":"1 自定义标签自定义标签是为了简化代码。使用自定义标签替换一个java代码片段，完成相同功能。 自定义标签的步骤： 定义标签处理器——定义一个类，继承SimpleTagSupport类，重写doTag( )方法 注册标签库，注册标签 导入标签库，使用标签 下面举2个案例来说明自定义标签。 2 定义带标签体的自定义标签（使用无标签体的标签完成：输出客户端IP） （使用有标签体的标签完成：小写转大写） 2-1 定义标签处理器 一个标签对应着一个类的一段代码。 一个类要实现自定义标签的功能，需要该类实现一个接口：Javax.servlet.jsp.tagext.SimpleTag，该接口有5个需要实现的方法，此时该类被称为标签处理器类。 ​ 123456789101112131415161718192021222324252627package com.orbit.tag;import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：获取客户端IPpublic class ClientIPTag extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //获取PageContext对象 PageContext pc = (PageContext) this.getJspContext(); //获取请求对象 ServletRequest request = pc.getRequest(); //获取客户端IP String ClientIp = request.getRemoteAddr(); //获取标准输出流 JspWriter out = pc.getOut(); //将客户端IP写入到输出流中 out.print(ClientIp); &#125;&#125; 12345678910111213141516171819202122232425262728package com.orbit.tag;import java.io.IOException;import java.io.StringWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;//定义标签处理器：小写转大写public class LowerToUpper extends SimpleTagSupport&#123; @Override public void doTag() throws JspException, IOException &#123; //创建一个输出流，该流中的内容可以通过其toString()方法获取到文本形式 StringWriter sw = new StringWriter(); //获取标签体对象 JspFragment jspBody = this.getJspBody(); //将标签体内容写入到输出流中 jspBody.invoke(sw); //以文本形式获取到输出流中的内容 String content = sw.toString(); //小写变大写 content = content.toUpperCase(); //将文本写入到标准输出流并打印 this.getJspContext().getOut().print(content);; &#125;&#125; 2-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;!-- 注册标签 --&gt; &lt;tag&gt; &lt;name&gt;clientIP&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ClientIPTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;tag&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.LowerToUpper&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- empty:当前标签没有标签体 scriptless:当前标签有标签体，但该标签中不能出现Java脚本，可以出现EL表达式 jsp:(已过时)，当前标签具有标签体，标签体内容原样显示到浏览器 tagdependent:当前标签有标签体，标签体内容原样显示到浏览器，即使是EL也一样 --&gt;&lt;/taglib&gt; 2-3 导入标签库，使用标签123456789101112131415161718192021222324252627&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用Java代码块获取IP --&gt; &lt;% String ip = request.getRemoteAddr(); out.println(\"ip = \" + ip); %&gt;&lt;br/&gt; &lt;!-- 使用无标签体的自定义标签获取IP --&gt; ip = &lt;tag:clientIP/&gt;&lt;br/&gt; &lt;!-- 使用有标签体的自定义标签完成小写转大写 --&gt; &lt;% String s = \"abc\"; pageContext.setAttribute(\"s\", s); %&gt; &lt;tag:LowerToUpper&gt;$&#123;s&#125;&lt;/tag:LowerToUpper&gt;&lt;br/&gt; &lt;tag:LowerToUpper&gt;are you kidding me?&lt;/tag:LowerToUpper&gt; &lt;/body&gt;&lt;/html&gt; 2-4 输出结果 3 定义带属性的自定义标签3-1 定义标签处理器1234567891011121314151617181920212223242526272829package com.orbit.tag;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;public class IfTag extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; if(test) &#123;// //获取标签体对象// JspFragment jspBody = this.getJspBody();// //将标签体加入到输出流// jspBody.invoke(this.getJspContext().getOut()); //invoke(null)等价于invoke(this.getJspContext().getOut()) this.getJspBody().invoke(null); &#125; &#125;&#125; 3-2 定义标签库，注册标签12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.IfTag&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 标签的属性 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性名 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true表示调用该标签时，必须要写该属性 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- runtime expression value运行时表达式值，true表示该属性的值支持EL与JSP表达式 --&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 3-3 导入标签库，使用标签123456789101112131415161718192021&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用带属性的自定义标签 --&gt; &lt;% boolean gender = true; pageContext.setAttribute(\"gender\", gender); %&gt; &lt;tag:if test=\"$&#123;gender &#125;\"&gt;男&lt;/tag:if&gt; &lt;tag:if test=\"$&#123;not gender &#125;\"&gt;女&lt;/tag:if&gt; &lt;/body&gt;&lt;/html&gt; #### 3-4 输出结果 4 自定义遍历List集合的forEachList标签4-1 定义标签处理器123456789101112131415161718192021222324252627282930package com.orbit.tag;import java.io.IOException;import java.util.List;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachListTag extends SimpleTagSupport&#123; private List items; private String var; //var代表当前对象要放入域中的属性名 public void setItems(List items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; for (Object obj : items) &#123; //EL只能处理四大域中的数据，因此将该遍历对象放入到四大域中 //key为var指定的名称（name）,value为当前遍历对象obj this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 4-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEachList&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachListTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 4-3 导入标签库，使用标签12345678910111213141516171819202122232425&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自定义标签 --&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEachList items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEachList&gt; &lt;/body&gt;&lt;/html&gt; 4-4 输出结果 5 自定义遍历集合和数组的forEach标签5-1 定义标签处理器(方法一) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.orbit.tag;import java.io.IOException;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; @Override public void doTag() throws JspException, IOException &#123; //判断items的类型 if(items instanceof List) &#123; List itemsList = (List) items; for (Object obj : itemsList) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Set) &#123; Set itemsSet = (Set) items; for (Object obj : itemsSet) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Map) &#123; Map itemsMap = (Map) items; for (Object obj : itemsMap.entrySet()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;else if(items instanceof Object[]) &#123; Object[] itemsObject = (Object[]) items; for (Object obj : itemsObject) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125; &#125;&#125; （方法二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.orbit.tag;import java.io.IOException;import java.lang.reflect.Array;import java.util.*;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;public class ForEachTag extends SimpleTagSupport&#123; //无论items是集合还是数组，他们的父类都是Object private Object items; private String var;// private Collection coll; public void setItems(Object items) &#123; this.items = items; &#125; public void setVar(String var) &#123; this.var = var; &#125; public Collection getColl() &#123; if(items instanceof List) &#123; return (List) items; &#125;else if(items instanceof Set) &#123; return (Set) items; &#125;else if(items instanceof Map) &#123; return ((Map) items).entrySet(); &#125; /*该方法只能遍历非基本数据类型的数组*/// else if(items instanceof Object[]) &#123;// //将items强转为数组，数组再转为List集合（因为返回值是集合类型）// return Arrays.asList((Object[])items);// &#125; /*该方法能遍历任何数组*/ else if(items.getClass().isArray()) &#123; List nums = new ArrayList(); for(int i =0;i&lt;Array.getLength(items);i++) &#123; nums.add(Array.get(items, i)); &#125; return nums; &#125; return null; &#125; @Override public void doTag() throws JspException, IOException &#123; //遍历getColl()的返回值 for (Object obj : getColl()) &#123; this.getJspContext().setAttribute(var, obj); this.getJspBody().invoke(null); &#125; &#125;&#125; 5-2 定义标签库，注册标签123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 注册标签库 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tag&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/AutoDefinedTag&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;forEach&lt;/name&gt; &lt;tag-class&gt;com.orbit.tag.ForEachTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 5-3 导入标签库，使用标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page pageEncoding=\"UTF-8\" import=\"java.util.*\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/AutoDefinedTag\" prefix=\"tag\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ===========遍历List===========&lt;br/&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; &lt;!-- items表示names这个数组，var表示names中的属性name --&gt; &lt;tag:forEach items=\"$&#123;names &#125;\" var=\"name\"&gt; $&#123;name &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Set===========&lt;br/&gt; &lt;% Set&lt;String&gt; cities = new HashSet&lt;&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"广州\"); pageContext.setAttribute(\"cities\", cities); %&gt; &lt;tag:forEach items=\"$&#123;cities &#125;\" var=\"city\"&gt; $&#123;city &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Map===========&lt;br/&gt; &lt;% Map&lt;String,Object&gt; infos = new HashMap&lt;&gt;(); infos.put(\"name\", \"张三\"); infos.put(\"age\", 24); infos.put(\"gender\", \"男\"); pageContext.setAttribute(\"infos\", infos); %&gt; &lt;tag:forEach items=\"$&#123;infos &#125;\" var=\"info\"&gt; $&#123;info &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型的数组===========&lt;br/&gt; &lt;% Object[] objs = &#123;\"元素1\",\"元素2\",\"元素3\"&#125;; pageContext.setAttribute(\"objs\", objs); %&gt; &lt;tag:forEach items=\"$&#123;objs &#125;\" var=\"obj\"&gt; $&#123;obj &#125; &lt;br/&gt;&lt;/tag:forEach&gt; ===========遍历Object类型及数据类型的数组===========&lt;br/&gt; &lt;% int[] ages = &#123;11,12,13&#125;; pageContext.setAttribute(\"ages\", ages); %&gt; &lt;tag:forEach items=\"$&#123;ages &#125;\" var=\"age\"&gt; $&#123;age &#125; &lt;br/&gt;&lt;/tag:forEach&gt; &lt;/body&gt;&lt;/html&gt; 5-4 输出结果 6 将自定义标签库打包发行右击项目名——Export——搜索JARfile——勾选需要打包的包名，其他的取消勾选，选择保存位置，命名为xxx.jar——将对应的tld文件复制到xxx.jar中的META-INF文件夹中——需要时导入即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"Next主题格式配置记录","slug":"Next主题格式配置记录","date":"2019-08-27T15:23:14.000Z","updated":"2019-08-27T15:48:58.046Z","comments":true,"path":"2019/08/27/Next主题格式配置记录/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/Next主题格式配置记录/","excerpt":"文章背景色","text":"文章背景色","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://cometorbityh.github.io/tags/next/"}]},{"title":"使用PicGo + 七牛云 快速创建图床","slug":"使用PicGo-七牛云-快速创建图床","date":"2019-08-27T12:04:12.000Z","updated":"2019-08-27T15:25:44.190Z","comments":true,"path":"2019/08/27/使用PicGo-七牛云-快速创建图床/","link":"","permalink":"https://cometorbityh.github.io/2019/08/27/使用PicGo-七牛云-快速创建图床/","excerpt":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。","text":"​ 上次是解决了hexo显示不出本地图片的问题，但是如果电脑出问题了，导致图片全都不见了，那么所带来的麻烦可不小，因此我们可以考虑把这些博客中的图片上传在图床（可以理解为专门存储图片的服务器）中，这样就不用担心图片丢失了，只要记住服务器网站的账号密码就可以永久保存图片了。 注册七牛云账号（https://www.qiniu.com/），并完成实名认证。 创建存储空间 下载并安装PicGo（https://github.com/Molunerfinn/PicGo/releases） 七牛图床设置 上传图片","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"JSP——EL表达式","slug":"JSP——EL表达式","date":"2019-08-26T06:14:53.000Z","updated":"2019-08-31T07:19:51.261Z","comments":true,"path":"2019/08/26/JSP——EL表达式/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/JSP——EL表达式/","excerpt":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值","text":"EL表达式，Expression Language，可以获取JSP页面的数据 EL表达式的格式为 ${expression} 在JSP页面的任何静态部分均可使用该格式获取到指定值 使用EL获取数据 从四大域中获取数据EL只能获取到四大域中的数据，因此要获取到某个数据，需要将其加入到某个域中，再使用EL表达式获取数据。 从四大域中依次查找数据 ${属性}EL01.jsp 12345678910&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;name&#125; &lt;/body&gt; 输出结果为page域的属性值（最小的域） 从指定域中获取数据 ${域scope.属性}依次从四大域查找属性效率过低，为了提高效率，我们应该想想如何从指定域中直接获取某个属性值。 EL有4个域属性空间相关的内置对象，分别为pageScope，requestScope，sessionScope，applicationScope。表示从对应域属性空间中查找指定key。 1234567891011121314&lt;!-- EL01.jsp --&gt;&lt;body&gt; &lt;% application.setAttribute(\"name\", \"JAVA核心技术1\"); session.setAttribute(\"name\", \"JAVA核心技术2\"); request.setAttribute(\"name\", \"JAVA核心技术3\"); pageContext.setAttribute(\"name\", \"JAVA核心技术4\"); %&gt; &lt;!-- $&#123;属性名&#125;会按照从小到大的顺序依次从四大域中查找指定名称的属性值 --&gt; name = $&#123;pageScope.name&#125;&lt;br/&gt; name = $&#123;requestScope.name&#125;&lt;br/&gt; name = $&#123;sessionScope.name&#125;&lt;br/&gt; name = $&#123;applicationScope.name&#125;&lt;br/&gt;&lt;/body&gt; 获取Bean的属性 ${key.属性}创建一个Bean的对象，将这个Bean对象加入到域属性空间中，通过 ${key.属性} 可以访问该对象的属性值。 注意：若访问对象为null，则EL也不会报空指针异常，显示结果为”” 12345678910111213141516171819202122232425262728293031/* School.java */package com.orbit.el;public class School &#123; private String scname; private String scaddress; public School(String scname, String scaddress) &#123; super(); this.scname = scname; this.scaddress = scaddress; &#125; public String getScname() &#123; return scname; &#125; public void setScname(String scname) &#123; this.scname = scname; &#125; public String getScaddress() &#123; return scaddress; &#125; public void setScaddress(String scaddress) &#123; this.scaddress = scaddress; &#125; @Override public String toString() &#123; return \"School [scname=\" + scname + \", scaddress=\" + scaddress + \"]\"; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/* Student.java */package com.orbit.el;public class Student &#123; private String sname; private int sno; private School school; public Student(String sname, int sno, School school) &#123; super(); this.sname = sname; this.sno = sno; this.school = school; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSno() &#123; return sno; &#125; public void setSno(int sno) &#123; this.sno = sno; &#125; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return \"Student [sname=\" + sname + \", sno=\" + sno + \", school=\" + school + \"]\"; &#125; &#125; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School school = new School(\"清华大学\",\"北京\"); Student student = new Student(\"杨小杨\",10001,school); pageContext.setAttribute(\"student\", student); %&gt; &lt;!-- 若访问对象为null，则EL也不会报空指针异常，显示结果为\" \" --&gt;&gt; student = $&#123;student1&#125; student = $&#123;student&#125;&lt;br/&gt; student.sname = $&#123;student.sname&#125;&lt;br/&gt; student.sname = $&#123;student['sname']&#125;&lt;br/&gt; student.sno = $&#123;student.sno&#125;&lt;br/&gt; student.sno = $&#123;student['sno']&#125;&lt;br/&gt; student.school = $&#123;student.school&#125;&lt;br/&gt; student.school.scname = $&#123;student.school.scname&#125;&lt;br/&gt; student.school.scaddress = $&#123;student.school.scaddress&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 获取数组 ${array[i]}创建一个数组，将这个数组加入到域属性空间，通过 ${array[i]} 可以访问该数组的第 i+1个元素。 1234567891011121314151617181920212223&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% School[] schools = new School[3]; schools[0] = new School(\"清华大学\",\"中国北京\"); schools[1] = new School(\"北京大学\",\"中国北京\"); schools[2] = new School(\"厦门大学\",\"中国福建\"); pageContext.setAttribute(\"schools\", schools); %&gt; school[2] = $&#123;schools[0]&#125;&lt;br/&gt; school[2].address = $&#123;schools[2].scaddress&#125;&lt;br/&gt; &lt;!-- 数组下标超出上限，EL不会报越界异常 --&gt; school[3] = $&#123;schools[3]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ​ ​ 获取List中的元素 ${list[i]}访问list与访问数组的方式一致。 注意：set是无序的，其中的元素没有索引，因此无法用该种方式访问。 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"熊大\"); names.add(\"熊二\"); names.add(\"光头强\"); pageContext.setAttribute(\"names\", names); %&gt; names[1] = $&#123;names[1]&#125;&lt;br/&gt; names[10] = $&#123;names[10]&#125;&lt;/body&gt;&lt;/html&gt; 获取Map中的元素 ${map.元素}123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"school\", new School(\"厦门大学\",\"中国福建\")); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); pageContext.setAttribute(\"map\", map); %&gt; &lt;!-- map.school是Object类型的，map.school.scname是默认Object型强转为School型 --&gt; $&#123;map.school.scname &#125;&lt;br/&gt; $&#123;map.name &#125;&lt;/body&gt;&lt;/html&gt; ​ EL常见运算符 序号 类别 运算符 1 算术运算符 + - * / % 2 关系运算符 &gt; &lt; == &gt;= &lt;= != 3 逻辑运算符 &amp;&amp;(and) ||(or) !(not) 4 条件运算符 ？ ： 5 取值运算符 . [ ] 6 empty运算符 empty empty的用法 empty判空，四大域中的元素符合以下条件时empty的运算结果为true： 没有定义的属性 值为null的引用 值为空串的String引用 没有元素的数组或集合 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" import=\"java.util.*,com.orbit.el.*\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String b = null; String c = \"\"; List&lt;String&gt; d = new ArrayList&lt;&gt;(); pageContext.setAttribute(\"b\", b); pageContext.setAttribute(\"c\", c); pageContext.setAttribute(\"d\", d); %&gt; empty a = $&#123;empty a&#125;&lt;br/&gt; empty b = $&#123;empty b&#125;&lt;br/&gt; empty c = $&#123;empty c&#125;&lt;br/&gt; empty d = $&#123;empty d&#125;&lt;/body&gt;&lt;/html&gt; EL内置对象 EL有11个内置对象，除了前面的和4个域属性空间相关的内置对象之外，还有7个。 EL的内置对象中，除了pageContext之外，其他内置对象的类型均为java.util.Map类型。 此处介绍常用的四个内置对象： pageContext 是不是有点熟悉？没错，EL的pageContext和JSP的pageContext是同一个对象。 可以获取到JSP的request、response、session、servletContext、servletConfig等对象 注意获取到的这些内置对象是JSP的，不是EL的，EL中没有这些内置对象。 如何在EL中使用pageContext获取到JSP的内置对象？ 例如，获取request内置对象——${pageContext.request} 其底层实际调用的方法为 pageContext.getRequest()，其他内置对象同理 常用内置对象的方法？ ${pageContext.request.contextPath()}，用来获取当前项目路径，一般用在JSP页面的路径中。 1234567&gt; &lt;body&gt;&gt; &lt;!-- 可读性差 --&gt;&gt; &lt;form action=\"register\"&gt;&lt;/form&gt; &gt; &lt;!-- 可读性好 --&gt;&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/register\"&gt;&lt;/form&gt;&gt; &lt;/body&gt;&gt; param ${param.parameter}`获取request域（请求）中的指定参数的值。 底层调用的是：request.getparameter() paramValues ${paramValues.parameter[i]}` :获取request域（请求）中指定参数的所有值。 底层调用的是：request.getparameterValues() initParam 获取初始化参数 底层调用的是servletContext.getInitParameter() 1234567891011121314151617181920212223&lt;!-- index.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/show.jsp\" &gt; 姓名：&lt;input type=\"text\" name=\"uname\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"uage\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"uhobby\" value=\"sing\"/&gt;唱 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"dancing\"/&gt;跳 &lt;input type=\"checkbox\" name=\"uhobby\" value=\"rap\"/&gt;RAP &lt;input type=\"checkbox\" name=\"uhobby\" value=\"basketball\"/&gt;篮球&lt;br/&gt; &lt;input type=\"submit\"value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!-- show.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;param.uname&#125;&lt;br/&gt; 年龄：$&#123;param.uage&#125;&lt;br/&gt; 爱好：$&#123;paramValues.uhobby[0]&#125; &amp;nbsp; $&#123;paramValues.uhobby[1]&#125;&amp;nbsp; $&#123;paramValues.uhobby[2]&#125;&amp;nbsp; $&#123;paramValues.uhobby[3]&#125;&lt;br/&gt; 学校：$&#123;initParam.school&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;display-name&gt;02-EL&lt;/display-name&gt;&lt;context-param&gt; &lt;param-name&gt;school&lt;/param-name&gt; &lt;param-value&gt;清华大学&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; EL自定义函数 EL函数只能处理四大域中的属性值及常量 步骤：定义函数——定义标签库——注册函数——使用函数 12345678910//ELFunctions.javapackage com.orbit.el;public class ELFunctions &#123; //小写转大写 public static String LowertoUpper(String source) &#123; return source.toUpperCase(); &#125;&#125; 12345678910111213141516171819&lt;!-- myFt.tld --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 定义标签库信息 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myFt&lt;/short-name&gt; &lt;uri&gt;http://www.orbit.com/jsp/el/functions&lt;/uri&gt; &lt;!-- 注册函数 --&gt; &lt;function&gt; &lt;name&gt;IsLowertoUpper&lt;/name&gt; &lt;function-class&gt;com.orbit.el.ELFunctions&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String LowertoUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 12345678910111213141516171819202122&lt;!-- index.jsp --&gt;&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://www.orbit.com/jsp/el/functions\" prefix=\"myFt\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用函数：处理常量 --&gt; $&#123;myFt:IsLowertoUpper(\"no one can stop me!\") &#125; &lt;!-- 使用函数：处理四大域中的属性 --&gt; &lt;% String name=\"Selena\"; pageContext.setAttribute(\"name\", name); %&gt; $&#123;myFt:IsLowertoUpper(name) &#125;&lt;/body&gt;&lt;/html&gt; JSTL中的EL函数​ JSTL，JSP Standard Tag Library，JSP标准标签库，是Apache定义好的一套标准的标签库规范。 ​ JSTL中，定义了一套关于字符串处理的函数标签库，这个函数标签库中包含16个处理字符串的函数。 ​ 在JSP页面中导入jstl.jar ，standard.jar，就可以直接使用。 ​ 导入jar包 jstl.jar下载地址： http://repo2.maven.org/maven2/javax/servlet/jstl/ standard.jar下载地址： http://repo2.maven.org/maven2/taglibs/standard/ ​ 查看目录 ​ 使用函数 1234567891011121314&lt;%@ page pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:substring(\"abcdefg\",2,5) &#125; $&#123;fn:substringBefore(\"abcdefg\",\"cd\") &#125; $&#123;fn:substringAfter(\"abcdefg\",\"cd\"\") &#125;&lt;/body&gt;&lt;/html&gt; 对于EL做出的总结 EL不能出现在Java代码块、表达式块等JSP的动态代码部分 EL只能从四大域属性空间中获取数据（pageContext,request,session,application） EL不会抛出空指针异常，若访问一个null对象的属性，则什么也不显示 EL不会抛出数组访问越界异常，若访问一个数组中不存在的元素，则什么也不显示 EL本身无法对字符串进行处理，要想进行处理，可以通过EL自定义函数和JSTL中的EL函数来处理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://cometorbityh.github.io/tags/JSP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"}]},{"title":"解决hexo显示不出本地图片问题","slug":"解决hexo显示不出本地图片问题","date":"2019-08-26T05:45:45.000Z","updated":"2019-08-27T15:26:08.966Z","comments":true,"path":"2019/08/26/解决hexo显示不出本地图片问题/","link":"","permalink":"https://cometorbityh.github.io/2019/08/26/解决hexo显示不出本地图片问题/","excerpt":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。","text":"昨天刚开通博客，很兴奋，今天写了一篇博客，发现博客中的图片一直加载不出来。于是网上找了很多方案，鼓捣了很久才弄出来，真是麻烦，不过好在弄完了。让我们看看如何解决本地图片加载不出来的问题。 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹 1hexo new \"博客名\" 将想要上传的图片先保存在文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 使用hexo g部署，进入public\\2019\\08\\26\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2019/08/26/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了","categories":[{"name":"Github","slug":"Github","permalink":"https://cometorbityh.github.io/categories/Github/"},{"name":"hexo","slug":"Github/hexo","permalink":"https://cometorbityh.github.io/categories/Github/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cometorbityh.github.io/tags/hexo/"}]},{"title":"Servlet","slug":"Servlet","date":"2019-08-24T11:40:33.000Z","updated":"2019-08-26T09:26:49.702Z","comments":true,"path":"2019/08/24/Servlet/","link":"","permalink":"https://cometorbityh.github.io/2019/08/24/Servlet/","excerpt":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层","text":"Servlet是一个遵循Servlet开发的java类。由服务器调用的，运行在服务器端。 Servlet是一种独立于平台和协议的处于服务器端的Java应用程序，担当客户请求与服务器响应的中间层 2. Servlet的作用：用来接收客户端的请求数据，然后调用底层service处理数据并生成结果，返回一个响应给浏览器。 利用他可以实现业务层和表现层的分离，同时又可以生成动态页面。 3 . Servlet执行业务的步骤浏览器http请求——》tomcat服务器——-》到达servlet—–》执行doget，dopost方法—-》返回数据&lt;1&gt;客户端发送请求到服务器端&lt;2&gt;服务器将请求信息发送至Servlet&lt;3&gt;Servlet生成响应内容并将其传给服务器。&lt;4&gt;服务器将响应返回给客户端。 4. 创建Servlet的三种方式 定义一个类实现javax.servlet.Servlet接口 定义一个类继承javax.servet.GenericServlet类 定义一个类继承javax.servlet.http.HttpServlet类 web应用我们自然基本上都是继承HttpServlet 5. Servlet的生命周期（Servlet实例对象从创建到销毁的整个过程）​ Servlet的生命周期由一套定义良好的生命周期规则来约束管理 ​ 其中定义了Servlet如何被加载实例化和初始化,处理客户端请求,以及何时结束服务 ​ 生命周期方法有: ​ void init(ServletConfig)； ​ void service(ServletRequest,ServletResponse)； ​ void destroy()；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://cometorbityh.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://cometorbityh.github.io/tags/Servlet/"}]}]}