<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MY</title>
  
  <subtitle>IT IS MY LIFE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cometorbityh.github.io/"/>
  <updated>2019-11-26T14:54:29.997Z</updated>
  <id>https://cometorbityh.github.io/</id>
  
  <author>
    <name>杨涵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA 多线程：1</title>
    <link href="https://cometorbityh.github.io/2019/11/26/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A1/"/>
    <id>https://cometorbityh.github.io/2019/11/26/JAVA-多线程：1/</id>
    <published>2019-11-26T12:21:27.000Z</published>
    <updated>2019-11-26T14:54:29.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程的创建-启动"><a href="#线程的创建-启动" class="headerlink" title="线程的创建 + 启动"></a>线程的创建 + 启动</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>方式1：继承 java.lang.Thread 类，并覆盖run( ) 方法<br>方式2：实现 java.lang.Runnble 类，并实现run( )方法<br>方式3：实现 Callable 接口，并实现call( )方法</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126211351.png" class="lozad"></p><blockquote><p> tips：<strong>我们常写的main方法也是一个线程</strong></p></blockquote><p><strong>线程启动的步骤：</strong></p><ul><li>创建线程类，重写 run( ) 方法</li></ul><p>*　创建线程对象</p><ul><li>启动该线程，start( ) 方法（注意不是执行 run 方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法体，run()中写的是线程执行的代码，线程要完成的任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于继承了Thread类，可以直接用this调用线程的方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程名："</span>+<span class="keyword">this</span>.getName()+<span class="string">",线程优先级："</span>+<span class="keyword">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        ThreadDemo thread = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程名："</span>+Thread.currentThread().getName()+<span class="string">"，线程优先级："</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line">当前线程名：main，线程优先级：<span class="number">5</span></span><br><span class="line">当前线程名：main，线程优先级：<span class="number">5</span></span><br><span class="line">当前线程名：main，线程优先级：<span class="number">5</span></span><br><span class="line">当前线程名：Thread-<span class="number">0</span>,线程优先级：<span class="number">5</span></span><br><span class="line">当前线程名：Thread-<span class="number">0</span>,线程优先级：<span class="number">5</span></span><br><span class="line">当前线程名：Thread-<span class="number">0</span>,线程优先级：<span class="number">5</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法体，run()中写的是线程执行的代码，线程要完成的任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于继承了Thread类，可以直接用this调用线程的方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程名："</span>+Thread.currentThread().getName()+<span class="string">",线程优先级："</span>+Thread.currentThread().getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> RunnableDemo();<span class="comment">//这并不是个线程对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);<span class="comment">//这才是线程对象</span></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程名："</span>+Thread.currentThread().getName()+<span class="string">"，线程优先级："</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2种定义线程类的方法的对比</strong></p><table><thead><tr><th></th><th>Thread类</th><th>Runnable接口</th></tr></thead><tbody><tr><td>1</td><td>编程相对简单</td><td>编程相对复杂</td></tr><tr><td>2</td><td>Thread是个类，因此线程类无法继承其他类</td><td>Runnable是个接口，因此线程类还可以继承其他类</td></tr><tr><td>3</td><td>多个线程共享同一个资源</td><td><strong>更方便</strong>多个线程共享同一个资源</td></tr></tbody></table><p>上述3的举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> RunnableDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个Thread对象共用同一个RunnableDemo</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程名："</span>+Thread.currentThread().getName()+<span class="string">"，线程优先级："</span>+Thread.currentThread().getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，假如在线程类中售卖200张票。如果启动了3个对象，就相当于是3个窗口交替的在给你卖票，这样效率就特别快了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h2 id=&quot;线程的创建-启动&quot;&gt;&lt;a href=&quot;#线程的创建-启动&quot; class=&quot;headerlink&quot; title=&quot;线程的创建
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://cometorbityh.github.io/2019/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://cometorbityh.github.io/2019/11/25/数据库/</id>
    <published>2019-11-25T12:23:38.000Z</published>
    <updated>2019-11-26T15:01:35.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h1><blockquote><p>数据库 —– DataBase —– DB</p></blockquote><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><blockquote><p> 用于存储和管理数据的仓库。</p></blockquote><h2 id="数据库的特点"><a href="#数据库的特点" class="headerlink" title="数据库的特点"></a>数据库的特点</h2><blockquote><ol><li>持久化存储数据的。其实数据库就是一个文件系统</li><li>方便存储和管理数据</li><li>使用了统一的方式操作数据库 —&gt; SQL</li></ol></blockquote><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><blockquote><p>Structured Query Language：结构化查询语言</p><p>其实就是定义了操作所有关系型数据库的<strong>规则</strong>。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p></blockquote><h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><pre><code>1. SQL 语句可以单行或多行书写，以分号结尾。2. 可使用空格和缩进来增强语句的可读性。3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。4. 3 种注释    * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)     * 多行注释: /* 注释 */</code></pre><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><blockquote><p><strong>DDL ( Data Definition Language ) 数据定义语言</strong><br>    用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</p><p><strong>DML ( Data Manipulation Language ) 数据操作语言</strong><br>    用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</p><p><strong>DQL ( Data Query Language ) 数据查询语言</strong><br>    用来查询数据库中表的记录(数据)。关键字：select, where 等</p><p>DCL ( Data Control Language ) 数据控制语言(了解)<br>    用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</p></blockquote><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">=========建表==========</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>, <span class="comment">-- 编号</span></span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="comment">-- 姓名</span></span><br><span class="line">age <span class="built_in">int</span>, <span class="comment">-- 年龄</span></span><br><span class="line">sex <span class="built_in">varchar</span>(<span class="number">5</span>), <span class="comment">-- 性别</span></span><br><span class="line">address <span class="built_in">varchar</span>(<span class="number">100</span>), <span class="comment">-- 地址</span></span><br><span class="line">math <span class="built_in">int</span>, <span class="comment">-- 数学</span></span><br><span class="line">english <span class="built_in">int</span> <span class="comment">-- 英语</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(<span class="keyword">id</span>,<span class="keyword">NAME</span>,age,sex,address,math,english) <span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="number">1</span>,<span class="string">'马云'</span>,<span class="number">55</span>,<span class="string">'男'</span>,<span class="string">'杭州'</span>,<span class="number">66</span>,<span class="number">78</span>),</span><br><span class="line">    (<span class="number">2</span>,<span class="string">'马化腾'</span>,<span class="number">45</span>,<span class="string">'女'</span>,<span class="string">'深圳'</span>,<span class="number">98</span>,<span class="number">87</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="string">'马景涛'</span>,<span class="number">55</span>,<span class="string">'男'</span>,<span class="string">'香港'</span>,<span class="number">56</span>,<span class="number">77</span>),</span><br><span class="line">    (<span class="number">4</span>,<span class="string">'柳岩'</span>,<span class="number">20</span>,<span class="string">'女'</span>,<span class="string">'湖南'</span>,<span class="number">76</span>,<span class="number">65</span>),</span><br><span class="line">    (<span class="number">5</span>,<span class="string">'柳青'</span>,<span class="number">20</span>,<span class="string">'男'</span>,<span class="string">'湖南'</span>,<span class="number">86</span>,<span class="literal">NULL</span>),</span><br><span class="line">    (<span class="number">6</span>,<span class="string">'刘德华'</span>,<span class="number">57</span>,<span class="string">'男'</span>,<span class="string">'香港'</span>,<span class="number">99</span>,<span class="number">99</span>),</span><br><span class="line">    (<span class="number">7</span>,<span class="string">'马德'</span>,<span class="number">22</span>,<span class="string">'女'</span>,<span class="string">'香港'</span>,<span class="number">99</span>,<span class="number">99</span>),</span><br><span class="line">    (<span class="number">8</span>,<span class="string">'德玛西亚'</span>,<span class="number">18</span>,<span class="string">'男'</span>,<span class="string">'南京'</span>,<span class="number">56</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束 —–&gt; 对表中数据进行限定，从而保证数据的正确性、有效性和完整性</p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191125234254.png" class="lozad"><h2 id="1-非空约束（not-null）"><a href="#1-非空约束（not-null）" class="headerlink" title="(1) 非空约束（not null）"></a>(1) 非空约束（not null）</h2><p>定义某列的数据不能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加非空约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">name</span> VAECHAR(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后删除非空约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table1 <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后添加非空约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table1 <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="2-唯一约束（unique）"><a href="#2-唯一约束（unique）" class="headerlink" title="(2) 唯一约束（unique）"></a>(2) 唯一约束（unique）</h2><p>注意：MYSQL中唯一约束限定的列的值可以有多个NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加唯一约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">phone VAECHAR(<span class="number">20</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后删除唯一约束（也称唯一索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后添加唯一约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table1 <span class="keyword">MODIFY</span> phone <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><h2 id="3-主键约束（primary-key）"><a href="#3-主键约束（primary-key）" class="headerlink" title="(3) 主键约束（primary key）"></a>(3) 主键约束（primary key）</h2><p><code>主键 = 非空 + 唯一</code></p><ul><li><p>一张表中只能由一个字段是主键</p></li><li><p>主键就是表中记录的唯一标识</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STU(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键(因为一张表只有一个主键 因此不必声明具体字段名)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后添加主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>自动增长</strong></p><ul><li><p>某一列时数值类型的，可以使用 <code>auto_increment</code> 来完成自动增长，这样添加数据时可无需指定该字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束(自动增长)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,qqq);<span class="comment">-- 不指定自动增长的字段</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="number">10</span>,sss);<span class="comment">-- 可以自己指定自增的字段</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,sss);<span class="comment">-- 注意该条数据中自增的字段为11 与上一条插入的数据有关</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除自增</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表后添加自增</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-外键约束（foreign-key）"><a href="#4-外键约束（foreign-key）" class="headerlink" title="(4) 外键约束（foreign key）"></a>(4) 外键约束（foreign key）</h2><p>首先创建一张表，观察表中数据会发现：这个表的数据有些冗余，而且增加和删除数据都很麻烦</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">age <span class="built_in">INT</span>,</span><br><span class="line">dep_name <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">dep_location <span class="built_in">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="string">'研发部'</span>, <span class="string">'广州'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="number">21</span>, <span class="string">'研发部'</span>, <span class="string">'广州'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="number">20</span>, <span class="string">'研发部'</span>, <span class="string">'广州'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'老王'</span>, <span class="number">20</span>, <span class="string">'销售部'</span>, <span class="string">'深圳'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'大王'</span>, <span class="number">22</span>, <span class="string">'销售部'</span>, <span class="string">'深圳'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (<span class="keyword">NAME</span>, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">'小王'</span>, <span class="number">18</span>, <span class="string">'销售部'</span>, <span class="string">'深圳'</span>);</span><br></pre></td></tr></table></figure><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126131608.png" class="lozad"><p>那我们如何解决呢？这里可以把这张数据表拆分成2张表，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建部门表（主表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">dep_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dep_location <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建员工表（从表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line">dep_id <span class="built_in">int</span> <span class="comment">-- 外键对应主表的主键</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'研发部'</span>,<span class="string">'广州'</span>),(<span class="literal">null</span>, <span class="string">'销售部'</span>, <span class="string">'深圳'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="number">21</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'老王'</span>, <span class="number">20</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'大王'</span>, <span class="number">22</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'小王'</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p> 现在这2张表是好看了，但是他们之间还是没有关系啊！</p><p>没事，我们可以使用一个<strong>外键约束</strong>来关联这2张表</p></blockquote><p>创建表时添加外键约束</p><p><code>CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建部门表（主表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">dep_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dep_location <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建员工表（从表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line">dep_id <span class="built_in">int</span>, <span class="comment">-- 外键对应主表的主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> emp_dept_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dep_id) <span class="keyword">REFERENCES</span> department(<span class="keyword">id</span>) <span class="comment">-- 外键约束</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'研发部'</span>,<span class="string">'广州'</span>),(<span class="literal">null</span>, <span class="string">'销售部'</span>, <span class="string">'深圳'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="number">21</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'老王'</span>, <span class="number">20</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'大王'</span>, <span class="number">22</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">NAME</span>, age, dep_id) <span class="keyword">VALUES</span> (<span class="string">'小王'</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>删除外键约束</p><p><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></p><p>创建表后添加外键约束</p><p><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)</code></p><h2 id="5-级联操作"><a href="#5-级联操作" class="headerlink" title="(5) 级联操作"></a>(5) 级联操作</h2><h3 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h3><p>当我们想修改主表的数值怎么办？由于从表的外键绑定着主表的数值，我们必须先修改从表中的数据，才能再修改主表中的数据</p><p>但是一个一个修改太麻烦了，有什么方法能够快速删除这些数据呢？</p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126134059.png" class="lozad"><p><strong>方法1（逐表修改）</strong></p><p>将从表中 dep_id = 1 更换成 dep_id = NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> dep_id = <span class="literal">NULL</span> <span class="keyword">WHERE</span> dep_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><img style="zoom: 67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126134355.png" class="lozad"><p>修改主表数据，再更换从表数据</p><p><code>UPDATE employee SET dep_id = 4 WHERE dep_id IS NULL;</code></p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126134745.png" class="lozad"><p><strong>方法2（级联操作）</strong></p><p>重新修改外键，并在其后添加<code>ON UPDATE CASCADE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> emp_dept_fk; <span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> emp_dept_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dep_id) <span class="keyword">REFERENCES</span> department(<span class="keyword">id</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>; <span class="comment">-- 重新添加外键</span></span><br></pre></td></tr></table></figure><p>修改主表的数据时，从表的外键数据也会随之修改</p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126135536.png" class="lozad"><h3 id="级联删除（谨慎使用！）"><a href="#级联删除（谨慎使用！）" class="headerlink" title="级联删除（谨慎使用！）"></a>级联删除（谨慎使用！）</h3><p>那么我们是否可以：删除主表的数据时，从表的相关外键数据也随之删除呢？</p><p>重新修改外键，并在其后添加<code>ON DELETE CASCADE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> emp_dept_fk; <span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> emp_dept_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dep_id) <span class="keyword">REFERENCES</span> department(<span class="keyword">id</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>; <span class="comment">-- 重新添加外键</span></span><br></pre></td></tr></table></figure><p>删除主表的数据时，从表的外键数据也会随之删除（注意：是整条删除！）</p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126135943.png" class="lozad"><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><h2 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h2><h3 id="1-一对一"><a href="#1-一对一" class="headerlink" title="(1) 一对一 *"></a>(1) 一对一 *</h3><blockquote><p>如：人 &lt;—–&gt; 身份证  ||  一个人对应一个身份证，一个身份证对应一个人</p></blockquote><blockquote><p>实现方式：<code>在任意一张表中添加唯一外键，指向另一个表的主键</code>，但一般情况下可以合成这2张表为一张表</p></blockquote><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126141000.png" class="lozad"><h3 id="2-一对多-多对一"><a href="#2-一对多-多对一" class="headerlink" title="(2) 一对多 / 多对一"></a>(2) 一对多 / 多对一</h3><blockquote><p>如；部门 &lt;—–&gt; 员工  ||  一个部门有多个员工，一个员工对应一个部门</p></blockquote><blockquote><p>实现方式：<code>在多的一方建立外键，指向多的一方的主键</code></p></blockquote><img style="zoom: 67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126140738.png" class="lozad"><h3 id="3-多对多"><a href="#3-多对多" class="headerlink" title="(3) 多对多"></a>(3) 多对多</h3><blockquote><p>如：学生 &lt;—–&gt; 课程  ||  一个学生可选多门课程，一个课程可被多个学生选择</p></blockquote><blockquote><p>实现方式：<code>新建中间表</code>，中间表至少包含2个字段，这2个字段作为中间表的外键，分别指向两张表的主键</p></blockquote><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126140755.png" class="lozad"><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>– 创建旅游线路分类表 tab_category<br>    – cid 旅游线路分类主键，自动增长<br>    – cname 旅游线路分类名称非空，唯一，字符串 100<br>    CREATE TABLE tab_category (<br>        cid INT PRIMARY KEY AUTO_INCREMENT,<br>        cname VARCHAR(100) NOT NULL UNIQUE<br>    );</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">-- 创建旅游线路表 tab_route</span><br><span class="line">/*</span><br><span class="line">rid 旅游线路主键，自动增长</span><br><span class="line">rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">price 价格</span><br><span class="line">rdate 上架时间，日期类型</span><br><span class="line">cid 外键，所属分类</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">price DOUBLE,</span><br><span class="line">rdate DATE,</span><br><span class="line">cid INT,</span><br><span class="line">FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建用户表 tab_user</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">NAME VARCHAR(100),</span><br><span class="line">birthday DATE,</span><br><span class="line">sex CHAR(1) DEFAULT &apos;男&apos;,</span><br><span class="line">telephone VARCHAR(11),</span><br><span class="line">email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">rid INT, -- 线路id</span><br><span class="line">DATE DATETIME,</span><br><span class="line">uid INT, -- 用户id</span><br><span class="line">-- 创建复合主键</span><br><span class="line">PRIMARY KEY(rid,uid), -- 联合主键</span><br><span class="line">FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="数据库的设计准则——范式"><a href="#数据库的设计准则——范式" class="headerlink" title="数据库的设计准则——范式"></a>数据库的设计准则——范式</h2><p>设计数据库时，需要遵循的一些<strong>规范</strong></p><ul><li><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，</p></li><li><p>各种范式呈递次规范，越高的范式数据库冗余越小。</p><blockquote><p>目前关系数据库有六种范式：</p><pre><code>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德 范式（BCNF）、第四范式(4NF）第五范式（5NF，又称完美范式）。</code></pre></blockquote></li></ul><p><code>如果要遵循后边的范式要求，必须先遵循前边的所有范式要求</code></p><h3 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="(1) 第一范式（1NF）"></a>(1) 第一范式（1NF）</h3><p>每一列都是不可分割的原子数据项</p><img style="zoom: 50%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126143429.png" class="lozad"><blockquote><p>存在的问题：<br>    1.存在非常严重的数据冗余(重复)：姓名、系名、系主任<br>    2.数据添加存在问题：添加新开设的系和系主任时，数据不合法<br>    3.数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</p></blockquote><h3 id="2-第二范式（2NF）"><a href="#2-第二范式（2NF）" class="headerlink" title="(2) 第二范式（2NF）"></a>(2) 第二范式（2NF）</h3><p>​    在1NF的基础上，非码属性必须完全依赖于码（<code>在1NF基础上消除</code>非主属性对主码的<code>部分函数依赖</code>）</p><p>​    首先要介绍几个概念：</p><ol><li><strong>函数依赖</strong>：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A<br>例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</li><li><strong>完全函数依赖</strong>：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。<br>例如：（学号，课程名称） –&gt; 分数</li><li><strong>部分函数依赖</strong>：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。<br>例如：（学号，课程名称） – &gt; 姓名</li><li><strong>传递函数依赖</strong>：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>例如：学号–&gt;系名，系名–&gt;系主任</li><li><strong>码</strong>：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<br>例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul></li></ol><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126145738.png" class="lozad"></p><blockquote><p>本例中，</p><p>​        码属性组（学号，课程名称），</p><p>​        分数完全依赖于码，</p><p>​        而姓名、系名和系主任则部分依赖于码（只需学号就可确定）；</p><p>而2NF的任务就是消除部分依赖</p><p>那么如何消除？方法就是拆分表格</p></blockquote><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126151257.png" class="lozad">        <blockquote><p>依然存在的问题：</p><p>​    2.数据添加存在问题：添加新开设的系和系主任时，数据不合法<br>​    3.数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</p></blockquote><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126151802.png" class="lozad"><h3 id="3-第三范式（3NF）"><a href="#3-第三范式（3NF）" class="headerlink" title="(3) 第三范式（3NF）"></a>(3) 第三范式（3NF）</h3><p>​    在2NF基础上，任何非主属性不依赖于其它非主属性（<code>在2NF基础上消除传递依赖</code>）</p><p>​    本例中的传递依赖是：学号 – &gt; 系名 –&gt; 系主任</p><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126152008.png" class="lozad"><p>此时添加数据和删除数据就都合法了。</p><h1 id="DQL-1"><a href="#DQL-1" class="headerlink" title="DQL"></a>DQL</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h2 id="–-1-基础查询"><a href="#–-1-基础查询" class="headerlink" title="– (1) 基础查询"></a>– (1) 基础查询</h2><blockquote><p>SELECT  FROM,DISTINCT , IFNULL, AS</p></blockquote><ul><li><p>查询 student 表所有字段<br> <code>select * from student;</code></p></li><li><p>查询 NAME 和 age 两列<br> <code>select NAME,age from student;</code></p></li><li><p>查询地址（去除重复后的结果集）<br> <code>select DISTINCT address from student;</code></p></li><li><p>计算分数之和（新列）</p><p><code>select name, math, english,math+english from student;</code></p><ul><li><p>若有null参与运算，则结果为null，显然不合理，这里应该用到：</p></li><li><p>IFNULL（字段名，字段值）：如果字段名的默认值为null，那么该值就替换为字段值</p><p><code>SELECT name,math,english,math+IFNULL(english,0) FROM student;</code></p></li></ul></li><li><p>起别名（接上例）（as 可省略）</p><p><code>SELECT name as 姓名,math as 数学,english as 英语,math+IFNULL(english,0) as 总分 FROM student;</code></p></li></ul><h2 id="–-2-条件查询"><a href="#–-2-条件查询" class="headerlink" title="– (2) 条件查询"></a>– (2) 条件查询</h2><blockquote><p>WHERE，BETWEEN AND， IN，IS NULL， AND，OR，NOT</p></blockquote><ul><li><p>查询 age等于20 的人</p><p><code>SELECT name,age FROM student WHERE age=20;</code></p></li><li><p>查询 age不等于20 的人</p><p><code>SELECT name,age FROM student WHERE age!=20;</code></p><p><code>SELECT name,age FROM student WHERE age&lt;&gt;20;</code></p></li><li><p>查询 age在[20,30] 范围的人</p><p><code>SELECT name,age FROM student WHERE age&gt;=20 AND age&lt;=30;</code></p><p> <code>SELECT name,age FROM student WHERE age BETWEEN 20 AND 30;</code> </p></li><li><p>查询 age等于22 或 18 或 25 的人</p><p><code>SELECT name,age FROM student WHERE age=22 OR age=18 OR age=25;</code></p><p><code>SELECT name,age FROM student WHERE age IN(18,22,25);</code></p><p>查询 English 缺考的人（=null）和未缺考的人</p><p><code>SELECT name,english FROM student WHERE english IS NULL;</code></p><p><code>SELECT name,english FROM student WHERE english IS NOT NULL;</code></p></li></ul><table><thead><tr><th></th><th align="left"></th></tr></thead><tbody><tr><td>LIKE （模糊查询）</td><td align="left">占位符<br> _：单个任意字符<br>%：多个任意字符</td></tr></tbody></table><ul><li><p>查询姓名中包含马的人</p><p><code>SELECT name FROM student WHERE name LIKE &#39;%马%&#39;;</code></p></li><li><p>查询姓名是3个字的人</p><p><code>SELECT name FROM student WHERE name LIKE &#39;___&#39;;</code></p></li></ul><h2 id="–-3-排序查询"><a href="#–-3-排序查询" class="headerlink" title="– (3) 排序查询"></a>– (3) 排序查询</h2><blockquote><p>ORDER BY ASC / DESC（默认升序）</p></blockquote><ul><li><p>按照 math 升序排序</p><p><code>SELECT name,math,english FROM student ORDER BY math asc;</code></p></li><li><p>按照 math 升序排序，若 math 一样，则按照 english 升序排序</p><p><code>SELECT name,math,english FROM student ORDER BY math asc,english asc;</code></p></li></ul><h2 id="–-4-计算列（聚合函数）"><a href="#–-4-计算列（聚合函数）" class="headerlink" title="– (4) 计算列（聚合函数）"></a>– (4) 计算列（聚合函数）</h2><blockquote><p>COUNT，MAX，MIN，SUM，AVG</p></blockquote><p>注意：聚合函数不计算null值</p><ul><li><p>查询总人数</p><p><code>SELECT COUNT(name),COUNT(IFNULL(english,0)) FROM student;</code></p></li><li><p>查询 math 的最大值和最小值</p><p><code>SELECT MAX(math),MIN(math) FROM student;</code></p></li><li><p>查询 english 的总和 以及 english 的平均值</p><p><code>SELECT SUM(english),AVG(english) FROM student;</code></p></li></ul><h2 id="–-5-分组查询"><a href="#–-5-分组查询" class="headerlink" title="– (5) 分组查询"></a>– (5) 分组查询</h2><blockquote><p>GROUP BY，HAVING（分组之后查询的字段为：分组字段、聚合函数)</p></blockquote><blockquote><p> where 和 having 的区别？</p><ol><li>where 在分组之前进行限定，having 在分组之后进行限定</li><li>where后不能根聚合函数，having后可以更聚合函数</li></ol></blockquote><ul><li><p>按照性别分组，查询不同性别的 english 的平均分，人数（分数低于70的人不参与分组）</p><p><code>SELECT sex,AVG(english),COUNT(id) FROM student WHERE english&gt;70 GROUP BY sex</code></p></li><li><p>根据上述分组，只显示大于2人的分组</p><p><code>SELECT sex,AVG(english),COUNT(id) FROM student WHERE english&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2;</code></p></li></ul><h2 id="–-6-分页查询"><a href="#–-6-分页查询" class="headerlink" title="– (6) 分页查询"></a>– (6) 分页查询</h2><blockquote><p>LIMIT x,y  —–  从 x 开始显示 y 条记录</p></blockquote><ul><li><p>每页显示3条记录</p><p><code>SELECT * FROM student LIMIT 0,3;</code></p><p><code>SELECT * FROM student LIMIT 3,3;</code></p><p><code>SELECT * FROM student LIMIT 6,3;</code></p></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>先创建2张表：部门表 + 员工表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (<span class="keyword">NAME</span>) <span class="keyword">VALUES</span> (<span class="string">'开发部'</span>),(<span class="string">'市场部'</span>),(<span class="string">'财务部'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">gender <span class="built_in">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">join_date <span class="built_in">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">dept_id <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept(<span class="keyword">id</span>) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">'孙悟空'</span>,<span class="string">'男'</span>,<span class="number">7200</span>,<span class="string">'2013-02-24'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">'猪八戒'</span>,<span class="string">'男'</span>,<span class="number">3600</span>,<span class="string">'2010-12-02'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">'唐僧'</span>,<span class="string">'男'</span>,<span class="number">9000</span>,<span class="string">'2008-08-08'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">'白骨精'</span>,<span class="string">'女'</span>,<span class="number">5000</span>,<span class="string">'2015-10-07'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">'蜘蛛精'</span>,<span class="string">'女'</span>,<span class="number">4500</span>,<span class="string">'2011-03-14'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>多表查询涉及到了笛卡尔积：</p><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><blockquote><ul><li>有两个集合A,B .取这两个集合的所有组成情况。</li><li>要完成多表查询，需要<strong>消除无用的数据</strong></li><li>多表查询的分类：<strong>内连接查询 + 外连接查询</strong></li></ul></blockquote><h4 id="1-内连接查询"><a href="#1-内连接查询" class="headerlink" title="(1) 内连接查询"></a>(1) 内连接查询</h4><blockquote><p>使用内连接查询需要的数据：</p><ol><li>查询哪些字段( select … )</li><li>从哪些表中查询数据 ( from… )</li><li>条件是什么( where… )</li></ol></blockquote><ul><li><p><strong>隐式内连接</strong>：使用 <strong>where</strong> 条件消除无用数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息和对应的部门信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.<span class="string">`dept_id`</span> = dept.<span class="string">`id`</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工表的名称，性别。部门表的名称</span></span><br><span class="line"><span class="comment">-- 方式1</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.<span class="string">`dept_id`</span> = dept.<span class="string">`id`</span>;</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">t1.<span class="string">`dept_id`</span> = t2.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>显式内连接：</strong></p><p>语法： <code>select 字段列表 from 表名1 [inner] join 表名2 on 条件</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息和对应的部门信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.<span class="string">`dept_id`</span> = dept.<span class="string">`id`</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.<span class="string">`dept_id`</span> = dept.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>​    </p><h4 id="2-外连接查询"><a href="#2-外连接查询" class="headerlink" title="(2) 外连接查询"></a>(2) 外连接查询</h4><ul><li><p><strong>左外连接：</strong>查询的是左表所有数据以及其交集部分。</p><p>语法：<code>select 字段列表 from 表1 left [outer] join 表2 on 条件；</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.*,t2.<span class="string">`name`</span> <span class="keyword">FROM</span> emp t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept t2 <span class="keyword">ON</span> t1.<span class="string">`dept_id`</span> = t2.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li></ul><img style="zoom:67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126154358.png" class="lozad"><ul><li><p><strong>右外连接：</strong>查询的是右表所有数据以及其交集部分。</p><p>语法：<code>select 字段列表 from 表1 right [outer] join 表2 on 条件;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept t2 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> emp t1 <span class="keyword">ON</span> t1.<span class="string">`dept_id`</span> = t2.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-子查询（嵌套查询）"><a href="#3-子查询（嵌套查询）" class="headerlink" title="(3) 子查询（嵌套查询）"></a>(3) 子查询（嵌套查询）</h4><ul><li><p>概念：查询中嵌套查询，称<strong>嵌套查询</strong>为<strong>子查询</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工信息</span></span><br><span class="line"><span class="comment"># 普通方法</span></span><br><span class="line"><span class="comment">-- 1 查询最高的工资是多少 9000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 查询员工信息，并且工资等于9000的</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.<span class="string">`salary`</span> = <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子查询方法</span></span><br><span class="line"><span class="comment">-- 一条sql就完成这个操作。子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.<span class="string">`salary`</span> = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>子查询不同情况</strong></li></ul><pre><code>1. 子查询的结果是**单行单列**的：子查询可以作为条件，使用**运算符**去判断。 运算符： &gt; &gt;= &lt; &lt;= =    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工工资小于平均工资的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary &lt; (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure>2. 子查询的结果是**多行单列**的：子查询可以作为条件，使用**运算符in**来判断  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询'财务部'和'市场部'所有的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'财务部'</span> <span class="keyword">OR</span> <span class="keyword">NAME</span> = <span class="string">'市场部'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = <span class="number">3</span> <span class="keyword">OR</span> dept_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'财务部'</span> <span class="keyword">OR</span> <span class="keyword">NAME</span> = <span class="string">'市场部'</span>);</span><br></pre></td></tr></table></figure>3. 子查询的结果是**多行多列**的：子查询可以作为一张**虚拟表**参与查询  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept t1 ,(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.<span class="string">`join_date`</span> &gt; <span class="string">'2011-11-11'</span>) t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id = t2.dept_id;</span><br><span class="line"><span class="comment">-- 普通内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp t1,dept t2 <span class="keyword">WHERE</span> t1.<span class="string">`dept_id`</span> = t2.<span class="string">`id`</span> <span class="keyword">AND</span> t1.<span class="string">`join_date`</span> &gt;  <span class="string">'2011-11-11'</span>;</span><br></pre></td></tr></table></figure></code></pre><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><ol><li>命令行：<ul><li>语法：<ul><li>备份： <code>mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</code></li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件 source 文件路径</li></ol></li></ul></li></ul></li><li>图形化工具：</li></ol><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="概念-步骤"><a href="#概念-步骤" class="headerlink" title="概念 + 步骤"></a>概念 + 步骤</h2><p><strong>事务</strong>：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p><p><strong>操作步骤：</strong></p><ol><li>开启事务： start transaction;</li><li>回滚：rollback;</li><li>提交：commit;</li></ol><ul><li><p>先创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span> (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">balance <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">account</span> (<span class="keyword">NAME</span>, balance) <span class="keyword">VALUES</span> (<span class="string">'zhangsan'</span>, <span class="number">1000</span>), (<span class="string">'lisi'</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ul><img style="zoom:80%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126161100.png" class="lozad"><ul><li><p>模拟转账出错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 张三账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance - <span class="number">500</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="comment">-- 2. 李四账户 +500（多打了一行字，导致出错，下条没执行）</span></span><br><span class="line">多打了一行字</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance + <span class="number">500</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'lisi'</span>;</span><br></pre></td></tr></table></figure></li></ul><img style="zoom:80%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126160834.png" class="lozad"><ul><li><p>使用事务解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--    先恢复金额</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0. 开启事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">-- 1. 张三账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance - <span class="number">500</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="comment">-- 2. 李四账户 +500（多打了一行字，导致出错）</span></span><br><span class="line">多打了一行字</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance + <span class="number">500</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'lisi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 发现执行没有问题，提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 发现出问题了，回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ul><img style="zoom:80%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126161100.png" class="lozad"><h2 id="事务提交的两种方式"><a href="#事务提交的两种方式" class="headerlink" title="事务提交的两种方式"></a>事务提交的两种方式</h2><p>自动提交：一条DML(增删改)语句会自动提交一次事务。（mysql就是自动提交的）</p><p>手动提交：需要先开启事务，再提交</p><ul><li>（<strong>若只开启事务没有提交，则下次重新打开图形界面时会恢复成之之前的数据</strong>）</li><li>（上述例子就是手动提交的）</li></ul><blockquote><p> MySQL数据库中事务默认自动提交，Oracle 数据库默认是手动提交事务</p></blockquote><blockquote><p>修改事务的默认提交方式：</p><ul><li>查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交  0 代表手动提交</li><li>修改默认提交方式： set @@autocommit = 0;</li></ul></blockquote><h2 id="事务的四大特征（⭐）"><a href="#事务的四大特征（⭐）" class="headerlink" title="事务的四大特征（⭐）"></a>事务的四大特征（⭐）</h2><ol><li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li><li>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</li><li>隔离性：多个事务之间。相互独立。</li><li>一致性：事务操作前后，数据总量不变</li></ol><h2 id="事务的隔离级别（⭐）"><a href="#事务的隔离级别（⭐）" class="headerlink" title="事务的隔离级别（⭐）"></a>事务的隔离级别（⭐）</h2><ul><li><p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p></li><li><p>存在的问题：</p><ol><li><strong>脏读</strong>：一个事务，读取到另一个事务中没有提交的数据</li><li><strong>不可重复读(虚读)</strong>：在同一个事务中，两次读取到的数据不一样。</li><li><strong>幻读</strong>：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li></ol></li><li><p>隔离级别：</p><ol><li><p>read uncommitted：读未提交（对方事务<strong>未提交</strong>，我方事务就可读取到修改）</p><ul><li>产生的问题：脏读、不可重复读、幻读</li></ul></li><li><p>read committed：读已提交 （对方事务<strong>提交后</strong>，我方事务才能读取到修改）（Oracle默认）</p><ul><li>产生的问题：不可重复读、幻读</li></ul></li><li><p>repeatable read：可重复读 （对方和我方事务<strong>都提交后</strong>，我方事务才能读取到修改）（MySQL默认）</p><ul><li>产生的问题：幻读</li></ul></li><li><p>serializable：串行化（<strong>锁表</strong>的操作，只能有一个事务在运行，相当于java的同步锁）</p><ul><li>可以解决所有的问题</li></ul><blockquote><p>注意：隔离级别从小到大<strong>安全性越来越高</strong>，但是<strong>效率越来越低</strong></p></blockquote><blockquote><p>数据库查询隔离级别：select @@tx_isolation;</p><p>数据库设置隔离级别：set global transaction isolation level  级别字符串;<strong>（修改隔离级别后要重启）</strong></p></blockquote></li></ol></li><li><p>案例演示：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 事务提交</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126164808.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126170106.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126171402.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126172242.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191126172450.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库介绍&quot;&gt;&lt;a href=&quot;#数据库介绍&quot; class=&quot;headerlink&quot; title=&quot;数据库介绍&quot;&gt;&lt;/a&gt;数据库介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;数据库 —– DataBase —– DB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 集合：Collections</title>
    <link href="https://cometorbityh.github.io/2019/11/24/JAVA-%E9%9B%86%E5%90%88%EF%BC%9ACollections/"/>
    <id>https://cometorbityh.github.io/2019/11/24/JAVA-集合：Collections/</id>
    <published>2019-11-24T15:48:11.000Z</published>
    <updated>2019-11-24T16:03:44.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"AAA"</span>);</span><br><span class="line">        list.add(<span class="string">"DDD"</span>);</span><br><span class="line">        <span class="comment">// addAll()后面可跟可变参数</span></span><br><span class="line">        Collections.addAll(list,<span class="string">"CCC"</span>,<span class="string">"BBB"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">int</span> index = Collections.binarySearch(list, <span class="string">"BBB"</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">// 打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">int</span> index1 = Collections.binarySearch(list, <span class="string">"BBB"</span>);</span><br><span class="line">        System.out.println(index1);</span><br><span class="line">        <span class="comment">// 反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">int</span> index2 = Collections.binarySearch(list, <span class="string">"BBB"</span>);</span><br><span class="line">        System.out.println(index2);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">int</span> index3 = Collections.binarySearch(list, <span class="string">"BBB"</span>);</span><br><span class="line">        System.out.println(index3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">[AAA, DDD, CCC, BBB]</span><br><span class="line">[DDD, CCC, AAA, BBB]</span><br><span class="line">[BBB, AAA, CCC, DDD]</span><br><span class="line">[AAA, BBB, CCC, DDD]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Collections&quot;&gt;&lt;a href=&quot;#Collections&quot; class=&quot;headerlink&quot; title=&quot;Collections&quot;&gt;&lt;/a&gt;Collections&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IDEA 快捷键：逐步更新</title>
    <link href="https://cometorbityh.github.io/2019/11/23/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%9A%E9%80%90%E6%AD%A5%E6%9B%B4%E6%96%B0/"/>
    <id>https://cometorbityh.github.io/2019/11/23/IDEA-快捷键：逐步更新/</id>
    <published>2019-11-23T06:29:39.000Z</published>
    <updated>2019-11-23T06:57:16.773Z</updated>
    
    <content type="html"><![CDATA[<p>191123</p><hr><h1 id="查看源码的继承关系：Ctrl-H"><a href="#查看源码的继承关系：Ctrl-H" class="headerlink" title="查看源码的继承关系：Ctrl+H"></a>查看源码的继承关系：Ctrl+H</h1><p>随意进入源码的一个类，按住Ctrl+H可以查看该类的继承关系</p><img style="zoom: 50%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123143052.png" class="lozad"><h1 id="查看类的所有方法：Alt-7"><a href="#查看类的所有方法：Alt-7" class="headerlink" title="查看类的所有方法：Alt + 7"></a>查看类的所有方法：Alt + 7</h1><img style="zoom: 67%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123145250.png" class="lozad">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;191123&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;查看源码的继承关系：Ctrl-H&quot;&gt;&lt;a href=&quot;#查看源码的继承关系：Ctrl-H&quot; class=&quot;headerlink&quot; title=&quot;查看源码的继承关系：Ctrl+H&quot;&gt;&lt;/a&gt;查看源码的继承关系：Ctrl+H&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 集合：Map接口概述</title>
    <link href="https://cometorbityh.github.io/2019/11/23/JAVA-%E9%9B%86%E5%90%88%EF%BC%9AMap%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0/"/>
    <id>https://cometorbityh.github.io/2019/11/23/JAVA-集合：Map接口概述/</id>
    <published>2019-11-23T06:17:08.000Z</published>
    <updated>2019-11-24T14:49:20.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p><code>java.util.Map</code></p><p>按照<code>&lt;键，值&gt;对</code>的形式存储数据，是双列集合</p><p>如身份证（&lt;身份证号，名字&gt;），QQ（&lt;QQ号，网名&gt;）这种一一对应的关系，称为“映射”</p><p>Map就是用来存储这种映射对象的集合。</p><p>HashMap的key无法重复，但是可以为null</p><h1 id="Map接口的继承体系"><a href="#Map接口的继承体系" class="headerlink" title="Map接口的继承体系"></a>Map接口的继承体系</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123142611.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123144559.png" class="lozad"></p><h1 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h1><p>由于Map是一个接口，因此我们使用HashMap类来测试Map接口的常用方法</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123145848.png" class="lozad"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> ? !id.equals(person.id) : person.id != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Person&gt; persons = <span class="keyword">new</span> HashMap&lt;String,Person&gt;();</span><br><span class="line">        persons.put(<span class="string">"01"</span>,<span class="keyword">new</span> Person(<span class="number">01</span>,<span class="string">"刘备"</span>));</span><br><span class="line">        persons.put(<span class="string">"02"</span>,<span class="keyword">new</span> Person(<span class="number">02</span>,<span class="string">"关羽"</span>));</span><br><span class="line">        persons.put(<span class="string">"03"</span>,<span class="keyword">new</span> Person(<span class="number">03</span>,<span class="string">"张飞"</span>));</span><br><span class="line">        persons.put(<span class="string">"04"</span>,<span class="keyword">new</span> Person(<span class="number">01</span>,<span class="string">"赵云"</span>));</span><br><span class="line">        persons.put(<span class="string">"04"</span>,<span class="keyword">new</span> Person(<span class="number">01</span>,<span class="string">"诸葛"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(persons.size()); <span class="comment">// 4</span></span><br><span class="line">        Person p04 = persons.get(<span class="string">"04"</span>);</span><br><span class="line">        System.out.println(p04);    <span class="comment">// Person&#123;id=1, name='诸葛'&#125;</span></span><br><span class="line">        System.out.println(<span class="string">"移除："</span>+persons.remove(<span class="string">"04"</span>).getName());   <span class="comment">// 移除：诸葛</span></span><br><span class="line">        System.out.println(persons.size()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//persons.clear();</span></span><br><span class="line">        <span class="comment">//System.out.println(persons.size()); // o</span></span><br><span class="line"></span><br><span class="line">        String num = <span class="string">"01"</span>;</span><br><span class="line">        <span class="keyword">if</span>(persons.containsKey(num))&#123;</span><br><span class="line">            System.out.println(persons.get(num).getName()+ <span class="string">"已存在！"</span>); <span class="comment">//刘备已存在！</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(persons.get(num).getName()+ <span class="string">"不存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 原本是根据equals和hashCode方法同时相等才算相等</span></span><br><span class="line"><span class="comment">         * 但这不符合现实的规则，因此我们重写了这2个方法</span></span><br><span class="line"><span class="comment">         * 使得只要对象内容一样就算一致！*/</span></span><br><span class="line">        <span class="keyword">if</span>(persons.containsValue(<span class="keyword">new</span> Person(<span class="number">02</span>,<span class="string">"关羽"</span>)))&#123;</span><br><span class="line">            System.out.println(<span class="string">"存在！"</span>);  <span class="comment">//  存在！</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"不存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*--------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = persons.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代key</span></span><br><span class="line">        <span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s %s  "</span>, key, persons.get(key).getName());  <span class="comment">//01 刘备  02 关羽  03 张飞</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代key（迭代器）</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            String name = persons.get(key).getName();</span><br><span class="line">            System.out.printf(<span class="string">"%s %s  "</span>, key, name);  <span class="comment">//01 刘备  02 关羽  03 张飞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代value</span></span><br><span class="line">        Collection&lt;Person&gt; values = persons.values();</span><br><span class="line">        <span class="keyword">for</span> (Person p:values)&#123;</span><br><span class="line">            System.out.print(p + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// Person&#123;id=1, name='刘备'&#125; Person&#123;id=2, name='关羽'&#125; Person&#123;id=3, name='张飞'&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Person&gt;&gt; entries = persons.entrySet();</span><br><span class="line">        <span class="comment">//迭代 Entry&lt;key,value&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Person&gt; entry:entries)&#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Person value = entry.getValue();</span><br><span class="line">            System.out.printf(<span class="string">"%s---%s  "</span>,key,value);</span><br><span class="line">            <span class="comment">// 01---Person&#123;id=1, name='刘备'&#125;  02---Person&#123;id=2, name='关羽'&#125;  03---Person&#123;id=3, name='张飞'&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//迭代 Entry&lt;key,value&gt;（迭代器）</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Person&gt;&gt; iterator1 = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Person&gt; ent = iterator1.next();</span><br><span class="line">            String key = ent.getKey();</span><br><span class="line">            Person value = ent.getValue();</span><br><span class="line">            System.out.printf(<span class="string">"%s---%s  "</span>,key,value);</span><br><span class="line">            <span class="comment">// 01---Person&#123;id=1, name='刘备'&#125;  02---Person&#123;id=2, name='关羽'&#125;  03---Person&#123;id=3, name='张飞'&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是Map接口的子类</p><p>Hash：音译为哈希，实际翻译为散列，杂凑</p><p>Hash算法可将一个数据转换成一个标志，该标志和原数据的每个字节都有十分紧密的关系</p><p>Hash算法很难找到逆向规律</p><p>Hash算法没有一个固定的公式，只要符合散列思想的算法都可以称为Hash算法</p><p>典型的Hash算法：MD5  SHA-1</p><p><strong>Hash碰撞（hash冲突）</strong></p><p>Hash算法可以算出几乎唯一的hashCode，若出现重复的hashCode，则称之为 “哈希碰撞” 或 “哈希冲突” </p><p>HashMap的数据结构</p><p>底层：散列表（哈希表），是基于快速存取的角度设计的，也是一种典型的“空间换时间”的做法。</p><img style="zoom:80%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123161812.png" class="lozad"><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123231137.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191124181907.png" class="lozad"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在线HashMap图解操作： <a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/OpenHash.html</a> </p><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负载因子赋值 0.75f</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义容量的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义容量&lt;0 抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 自定义容量 &gt; 最大容量(2^30) </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 负载因子&lt;0 或 负载因子为空 抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 把传入的自定义容量强行转化为2^n-1</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把传入的自定义容量强行转化为2^n-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入的集合大小</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断Node&lt;K,V&gt;[] table 即线性表数组是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取key的hash值 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key的hash值 异或 key的hash值的高16位</span></span><br><span class="line">    <span class="comment">//目的：提高hashcode的随机性</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">例如：某个key对象的hashcode为 <span class="number">1101</span> <span class="number">1001</span>，数组容量为<span class="number">16</span>，最大下标为<span class="number">15</span>（<span class="number">0000</span> <span class="number">1111</span>），真实实例为<span class="number">32</span>位，此处仅用<span class="number">8</span>位来举例</span><br><span class="line"> <span class="number">1101</span> <span class="number">1001</span>    hash值  </span><br><span class="line"> <span class="number">0000</span> <span class="number">1101</span>    hash值右移四位  </span><br><span class="line">----------    异或（^） ----&gt; key的hash值        </span><br><span class="line"> <span class="number">1101</span> <span class="number">0100</span>   </span><br><span class="line"> <span class="number">0000</span> <span class="number">1111</span>  数组大小-<span class="number">1</span>（<span class="number">16</span>-<span class="number">1</span>）</span><br><span class="line">----------  与（&amp;）----&gt; 该node最终存储在数组的位置</span><br><span class="line"> <span class="number">0000</span> <span class="number">0100</span>  最终存储的位置</span><br></pre></td></tr></table></figure></li><li><p>put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">table:当前的数组（全局变量）</span></span><br><span class="line"><span class="comment">tab：当前的数组（局部变量）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 若table数组为空 或 长度为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化table，并且获取数组长度n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 用hash和（数组长度-1）进行与运算（本质就是取余运算），算出put的数据应该插在数组的哪个位置</span></span><br><span class="line">    <span class="comment">// 那为什么不直接用取余？ 因为与运算的速度更快，因此使用与运算的目的就是优化计算速度</span></span><br><span class="line">   <span class="comment">// 若p=tab[i]为空，即p链表为null</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将put进来的数据放到tab[i]中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若p=tab[i]不为空，就是数组上该位置有元素了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 若tab[i]上的元素和put进来的hash值和键都相等（2个对象指向的地址一致，但是值不同）</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 把p=tab[i]的值保存在e中，等待旧值换成新值</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 若p=tab[i]是树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 调用红黑树的插入逻辑</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 若是链表插入元素</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 若p=tab[i]指向的下一个元素e为null</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// p=tab[i]的下一个元素就是put进来的数据</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 若当前链表节点的数量&gt; 树结构的阈值（默认8）</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">//树化：转换成红黑树结构（红黑树可以优化查询性能）</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 若当前链表包含要插入的值e=p.next，结束遍历，等待新值覆盖旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//p=tab[i+1]，为了遍历</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断插入的值是否存在hashmap中，若是则替换成新值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">// 保存e的旧值</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 将e的旧值替换为新值（覆盖）</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    <span class="comment">//若当前数组大小 &gt; 阈值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p> 是拿<strong>size的大小和threshold进行比较来决定是否需要扩容</strong> </p><p><strong>loadFactor负载因子是可以大于1的</strong>，因为构造函数没有限制，而且从结构上看size的大小是可以大于数组长度的（由于树节点和链表节点的存在）。</p></blockquote><ul><li><p>扩容：resize()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//旧数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// newCap：初始化新数组的容量</span></span><br><span class="line">   <span class="comment">// newThr：初始化新数组的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*--------------------1.新容量和阀值的计算---------------------*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用不同的构造方法初始化数组时，其容量和阈值不相同，因此以下对不同的情况进行初始化</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 情况1：若旧数组有容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当容量达到最大值时，无法扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当新容量（2倍旧容量）&lt; 最大容量 并且 旧容量 &gt;= 默认容量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 新阈值 = 2 * 旧阈值</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 情况2：若旧阈值 &gt; 0 （使用自定义容量的构造方法创建的数组的初始化）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//新容量 = 旧阈值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况3：若旧数组无容量（使用无参构造方法创建的数组的初始化）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 初始化新容量 = 16</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">// 初始化新阈值 = 负载因子 * 初始容量 </span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当新阈值为0时给新阈值赋值（上述情况2没有新阈值）</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// threshold就是新阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*--------------------2.扩容---------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对数组进行扩容，扩容时注意：</span></span><br><span class="line"><span class="comment">    由于元素位置时有hashcode计算得出的，当数组长度发生变化时，</span></span><br><span class="line"><span class="comment">    各个元素的位置也可能随机发生变化，因此要重新对元素进行定位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//创建一个新数组，长度为新容量</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新对元素位置进行定位</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历旧数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">// 若旧数组的该位置上有数据，先保存在e中，再将旧数组的该位置进行清空</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 当该元素的next指针没有值时（没有指向下一个）</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 重新计算位置，位置下标为 ：旧数组元素的hash值 &amp; (新数组容量-1)</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 当该元素的next指针有值时（指向了树节点，e本身也是树节点）</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">// 当该元素的next指针有值时（指向链表的下一个元素）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">// 遍历链表 将链表节点按照顺序进行分组（2组）</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 如果原有元素再扩容后，还在原位置</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//旧链表数据添加在一组</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果原有元素再扩容后，不在原位置（位置发生变化，放在其他位置了）</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//新链表数据添加在一组</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//把还在以前位置的元素链起来</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把不再以前位置的元素放在新的位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">//新的位置 = 原位置J + 原容量</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回扩容后的数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除：remove（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在key则删除并返回value，如果不存在则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定key并返回node</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 当前数组不能为空 &amp;&amp; 数组长度不能为0 &amp;&amp; 要删除的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hash没有冲突时（就在数组上，单个元素的桶节点）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hash有冲突时（不只是1个元素在同一位置，在链表或红黑树上）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该节点是树的桶节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 定位要删除的元素</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果该节点是链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历下一个链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="comment">// 定位要删除的元素</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到要删除的元素node</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果node是树的桶节点，删除该节点，并调整红黑树使得保持平衡</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// node在数组上（单个元素的桶节点）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// node在链表上（使数组上的元素指向 被删除节点的下一个元素）</span></span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> remove方法删除键值对并不会将数组的大小缩小，按照不同类型的待删除的节点有不同的处理方式： </p><ol><li>单元素桶节点：则将当前桶节点设置为null。</li><li>链表的桶节点：则断开被删除的键值对节点，然后重新连接</li><li>红黑树桶节点：删除键值对节点并调整树结构保持平衡，如果有必要则将红黑树缩减为链表</li></ol></li></ul><p>找到几篇文章，写的很好! </p><p><a href="https://blog.csdn.net/zjxxyz123/article/details/81111627" target="_blank" rel="noopener">https://blog.csdn.net/zjxxyz123/article/details/81111627</a> </p><p><a href="https://www.jianshu.com/p/e826d38d04d8" target="_blank" rel="noopener">https://www.jianshu.com/p/e826d38d04d8</a> </p><p> <a href="https://www.toutiao.com/i6693789706628366862/" target="_blank" rel="noopener">https://www.toutiao.com/i6693789706628366862/</a> </p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p><img alt="image-20191124001839334" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191124001839334.png" class="lozad"></p><p>LinkedHashMap 继承自HashMap，是基于 HashMap 和双向链表来实现的</p><p>HashMap 有一个不足之处就是在<strong>迭代</strong>元素时与<strong>插入顺序不一致</strong>。而大多数人都喜欢按顺序做某些事情，所以，LinkedHashMap 就是针对这一点对 HashMap 进行扩展，主要新增了<strong>「两种迭代方式」</strong>：</p><ul><li><strong>按插入顺序</strong> - 保证迭代元素的顺序与插入顺序一致</li><li><strong>按访问顺序</strong> - 一种特殊的迭代顺序，从最近最少访问到最多访问的元素访问顺序，非常适合构建 <strong>LRU</strong> 缓存</li></ul><p>HashMap 无序 而 LinkedHashMap 有序，可分为<code>插入顺序（有序）</code>和<code>访问顺序</code>两种</p><p>LinkedHashMap 存取数据，还是和HashMap一样使用Entry方式，双向链表只是为了保证顺序</p><p>LinkedHashMap 是线性不安全的</p><p>底层：双向链表</p><p>​    访问顺序：当访问一个链表的某个元素时，该元素会被移动到链表的最前面（置顶），这样子循环下去，排位越靠前的访问次数越多，越靠后的访问次数越少。这种思路也被称为“最近最少访问（LRU）”</p><blockquote><p>作用领域：缓存，假定该缓存规定每条链表只能拥有10个元素，其中有1条有12个元素，那么根据排序来看，前面的元素都是最近访问的，越靠后的访问次数就越少，那被删除的这2条就是没有经常访问的了，价值不大，因此LinkedHashMap非常适用于缓存。</p></blockquote><p>TreeMap</p><p>没有继承自HashMap</p><p>底层：红黑树</p><p>TreeMap的元素默认按照key的自然顺序进行排序</p><p>使用TreeMap的前提</p><ul><li>key的类实现了Comparable接口<ul><li>Integer：数组升序，实现了Comparable接口</li><li>String：按照字母表排序。实现了Comparable接口</li></ul></li><li>若key的类没有实现Comparable接口，那么需要使用Comparator比较器</li><li>若即实现了Comparable接口，又使用Comparator，则Comparator的优先级更高</li></ul><h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>特点：无序 不可重复</p><p>通过阅读源码：</p><ul><li><p>HashSet底层实现就是HashMap的key集合</p></li><li><p>LinkedHashSet底层实现就是LinkedHashMap的key集合</p></li><li><p>TreeSet底层实现就是TreeMap的key集合</p></li></ul><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：消除重复元素</span></span><br><span class="line"><span class="comment">注意：必须重写 equals()、hashcode()，否则无法比较2个对象相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Book&gt; list = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1001</span>,<span class="string">"java"</span>,<span class="number">13</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1001</span>,<span class="string">"java"</span>,<span class="number">13</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1002</span>,<span class="string">"java"</span>,<span class="number">13</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1003</span>,<span class="string">"java"</span>,<span class="number">13</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1003</span>,<span class="string">"java"</span>,<span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="keyword">for</span>(Book book:list)&#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Book&gt; books = getBooks(list);</span><br><span class="line">        System.out.println(books.size());</span><br><span class="line">        <span class="keyword">for</span>(Book book:books)&#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法清除重复元素，返回一个没有重复元素元素的集合对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Book&gt; <span class="title">getBooks</span><span class="params">(List&lt;Book&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"list is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Book&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法（有参、无参）</span></span><br><span class="line">    <span class="comment">// getter、setter</span></span><br><span class="line">    <span class="comment">// 重写 equals()、hashcode()、toString()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">5</span></span><br><span class="line">Book&#123;id=<span class="number">1001</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1001</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1002</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1003</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1003</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Book&#123;id=<span class="number">1003</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1001</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">1002</span>, name=<span class="string">'java'</span>, price=<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><strong>底层</strong>：TreeMap 的 key 集合</p><p><strong>特点</strong>：TreeSet 的元素默认按照 key 的自然顺序进行排序，不可重复</p><p><strong>使用TreeSet的前提</strong></p><ul><li>key 的类实现了 Comparable 接口<ul><li>Integer：数组升序，实现了 Comparable 接口</li><li>String：按照字母表排序。实现了 Comparable 接口</li></ul></li><li>若 key 的类没有实现 Comparable 接口，那么需要使用 Comparator 比较器</li><li>若即实现了 Comparable 接口，又使用 Comparator，则 Comparator 的优先级更高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法1：通过实现Comparable接口，并重写compareTo方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Emp</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法（有参、无参）</span></span><br><span class="line">    <span class="comment">// getter、setter</span></span><br><span class="line">    <span class="comment">// 重写 equals()、hashcode()、toString()</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Emp o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="keyword">this</span>.salary - o.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Emp&gt; emps = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1001</span>,<span class="string">"AAA"</span>,<span class="number">4000</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1002</span>,<span class="string">"BBB"</span>,<span class="number">2900</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1003</span>,<span class="string">"CCC"</span>,<span class="number">3800</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1004</span>,<span class="string">"DDD"</span>,<span class="number">4500</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1005</span>,<span class="string">"EEE"</span>,<span class="number">2800</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1006</span>,<span class="string">"FFF"</span>,<span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Emp emp:emps)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">Emp&#123;id=<span class="number">1005</span>, name=<span class="string">'EEE'</span>, salary=<span class="number">2800</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1002</span>, name=<span class="string">'BBB'</span>, salary=<span class="number">2900</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1003</span>, name=<span class="string">'CCC'</span>, salary=<span class="number">3800</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1001</span>, name=<span class="string">'AAA'</span>, salary=<span class="number">4000</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1004</span>, name=<span class="string">'DDD'</span>, salary=<span class="number">4500</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1006</span>, name=<span class="string">'FFF'</span>, salary=<span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法2：通过新建Comparator对象，并重写compare方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Emp&gt; emps = <span class="keyword">new</span> TreeSet&lt;Emp&gt;(<span class="keyword">new</span> Comparator&lt;Emp&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Emp o1, Emp o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 降序</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)o2.getSalary()-o1.getSalary();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1001</span>,<span class="string">"AAA"</span>,<span class="number">4000</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1002</span>,<span class="string">"BBB"</span>,<span class="number">2900</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1003</span>,<span class="string">"CCC"</span>,<span class="number">3800</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1004</span>,<span class="string">"DDD"</span>,<span class="number">4500</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1005</span>,<span class="string">"EEE"</span>,<span class="number">2800</span>));</span><br><span class="line">    emps.add(<span class="keyword">new</span> Emp(<span class="number">1006</span>,<span class="string">"FFF"</span>,<span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Emp emp:emps)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">Emp&#123;id=<span class="number">1006</span>, name=<span class="string">'FFF'</span>, salary=<span class="number">5000</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1004</span>, name=<span class="string">'DDD'</span>, salary=<span class="number">4500</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1001</span>, name=<span class="string">'AAA'</span>, salary=<span class="number">4000</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1003</span>, name=<span class="string">'CCC'</span>, salary=<span class="number">3800</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1002</span>, name=<span class="string">'BBB'</span>, salary=<span class="number">2900</span>&#125;</span><br><span class="line">Emp&#123;id=<span class="number">1005</span>, name=<span class="string">'EEE'</span>, salary=<span class="number">2800</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map接口&quot;&gt;&lt;a href=&quot;#Map接口&quot; class=&quot;headerlink&quot; title=&quot;Map接口&quot;&gt;&lt;/a&gt;Map接口&lt;/h1&gt;&lt;p&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照&lt;code&gt;&amp;lt;键，值&amp;gt;对&lt;/co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 数据结构：栈+队列+数组+链表</title>
    <link href="https://cometorbityh.github.io/2019/11/22/JAVA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    <id>https://cometorbityh.github.io/2019/11/22/JAVA-数据结构：栈-队列-数组-链表/</id>
    <published>2019-11-22T09:20:10.000Z</published>
    <updated>2019-11-23T06:15:05.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>计算机存储、组织数据的方式</p><p>数据结构可以编写出更优雅、更有效率的代码S</p><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p>特点：后进先出（弹夹、书箱）</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191122173146.png" class="lozad"></p><p>查看源码，Stack类继承Vector，而Vector的底层是线程安全的数组。因此推断出Stack的底层也是数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈出栈操作"><a href="#入栈出栈操作" class="headerlink" title="入栈出栈操作"></a>入栈出栈操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个栈对象（后进先出）</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 压栈操作 push()</span></span><br><span class="line">        stack.push(<span class="string">"刘备"</span>);</span><br><span class="line">        stack.push(<span class="string">"关羽"</span>);</span><br><span class="line">        stack.push(<span class="string">"张飞"</span>);</span><br><span class="line">        System.out.println(stack);  <span class="comment">// [刘备, 关羽, 张飞]</span></span><br><span class="line">        <span class="comment">//弹栈操作 pop()</span></span><br><span class="line">        String s1 = stack.pop();</span><br><span class="line">        System.out.println(s1); <span class="comment">//张飞</span></span><br><span class="line">        System.out.println(stack);  <span class="comment">// [刘备, 关羽]</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();    <span class="comment">//EmptyStackException,空栈异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>特点：先进先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.add(<span class="string">"刘备"</span>);</span><br><span class="line">        queue.add(<span class="string">"关羽"</span>);</span><br><span class="line">        queue.add(<span class="string">"张飞"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        String pop = queue.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">        queue.pop();</span><br><span class="line">        queue.pop();</span><br><span class="line">        queue.pop(); <span class="comment">//NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p>数组是有序的元素队列，是在内存中开辟了一段连续的空间，在此段空间存放元素</p><p>特点：长度固定，查询快，增删慢</p><p>为什么增删慢？</p><p>因为数组是一个固定的长度，增加和删除的话，都要重新创建一个新数组，并将旧数组中还保留的元素都复制到新数组，还要考虑删除或增加中间元素时，后面元素都要往前挪或往后挪，之后垃圾系统会回收旧数组，因此数组增删元素效率很低。</p><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191122194311.png" class="lozad"></p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>size()</p><p>isEmpty()</p><p>clear</p><p>add(E e)</p><p>add(int index,E e)</p><p>E get(int index)</p><p>remove(int index)</p><h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>构建类LinkedList<e>（底层：双向链表（Node））</e></p><ul><li><p>构造器（无参）</p></li><li><p>属性：size</p></li><li><p>内部类Node<e></e></p><ul><li>Node prev</li><li>E e(data)</li><li>Node next</li></ul><p>声明第一节点（Node first)</p><p>声明最后节点（Node last）</p></li></ul><p>  size():return size</p><p>  isEmpty()：return size==0</p><ul><li><p><strong>clear()：从头到尾遍历，</strong></p><ul><li>保存遍历节点</li><li>释放节点资源<ul><li>node.prev=null;</li><li>node.e=null;</li><li>node.next=null;</li></ul></li><li>通过保存节点找到下个节点<ul><li>node=oldNode.next</li></ul></li><li>size置为0</li><li>first=null,last=null</li></ul></li></ul><p><strong>E get(int index)</strong></p><p>判断index是否在范围内</p><p>​    checkElementIndex(index)</p><p>​    index&gt;0&amp;&amp;index&lt;size（合理）</p><p>​    index&lt;0||index》=size（不合理）</p><p>​    假如不可理抛异常</p><p>查找节点</p><ul><li><p>Node node = node(index)</p></li><li><p>二分查找思路：</p></li><li><p>index&lt;&lt;(Size-1)</p></li><li><p>Node node = first(从左到右)</p></li><li><p>for(int i=0;i&lt;index;i++){</p></li><li><p>node = node.next}</p><p>Node node = last（从右到左）</p><p>for(inr i=size-1;i&gt;index;i–){ node=node.prev}</p><p>return node</p></li></ul><p><strong>boolean add(E e):默认时添加到链表尾部</strong></p><p>linkLast</p><p>将变量保存临时list–f</p><p>构建新节点，等着被添加</p><p>​    Node newNode = new Node(last,e,null)</p><p>判断f是否为null</p><p>​    若f为null,newNode就要作为第一个节点 first = newNode </p><p>​    若f不为null  last.next=newNode;newNode作为最后节点 last = newNode</p><p>size++</p><p>return true</p><p><strong>add(int index,E e)</strong></p><p>检测该下标能否被添加</p><ul><li>index&gt;0 &amp;&amp; index&lt;=size</li><li>index&lt;0 || index&gt;size</li></ul><p>找到需要添加节点·下标</p><p>添加有3种情况</p><ul><li><p>添加到末尾</p><ul><li>if(index==size){linkLast(index)}</li></ul><p>else{</p><p>​    找到需要添加的节点下标</p><p>​        Node node = node(index)</p><p>​        linkBefore(index,node)</p><p>​            Node pre = node.prev    //前一个节点</p><p>​            Node next = node.next    //后一个节点</p><p>​            Node newNode = Node(prev,e,next)    //创建新节点</p><p>node.prev = newNode；找到的节点的前一个添加新节点</p><p>​    if(prev == null){        //要添加到第一个节点（即头节点指向的节点）</p><p>​        first = newNode</p><p>​        </p><p>}    else{prev.next = newNode}</p><p>}</p></li></ul><p><strong>E remove(int index)</strong></p><p>检测下标</p><p>找到需要删除的节点</p><p>​    Node node = node(index)</p><p>​    Node prev = node.prev’</p><p>Node next = node.next</p><p>if(prev==null) //要删除的节点是第一个</p><p>{first=next}    //第二个就变成第一个</p><p>else{prev.next=next;node.prev = null }    //前一个节点denext指针指向类删除的节点的下一个,并且清空被删除节点的prev</p><p>if(next==null)    //要删除的节点是最后一个</p><p>{last = prev; }    //前一个就变成最后一个</p><p>else{next.prev=prev;node.next =null}    //…</p><p>node.e=null</p><p>size–;</p><p>return e;</p><p><strong>有错误，等待订正！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; first;  <span class="comment">//链表首节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; last;   <span class="comment">//链表尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类 Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        E e;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev, E e, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node&lt;E&gt; node=first;node!=<span class="keyword">null</span>;)&#123;</span><br><span class="line">            Node&lt;E&gt; nd = node;</span><br><span class="line">            node.prev =<span class="keyword">null</span>;</span><br><span class="line">            node.e = <span class="keyword">null</span>;</span><br><span class="line">            node.next =<span class="keyword">null</span>;</span><br><span class="line">            node = nd.next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//检查下标范围是否合法</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//找到该下标所对应的节点</span></span><br><span class="line">        <span class="keyword">return</span> node(index).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到下标对应节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用二分法遍历</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;(size&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            Node&lt;E&gt; node=first;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node&lt;E&gt; node = last;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">                node=node.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isExistIndex(index))&#123;<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"下标不存在！"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下标是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExistIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;=<span class="number">0</span> &amp;&amp; index &lt;size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点（默认添加到最后）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        listLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素到链表最后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线保存原来最后一个结点的信息</span></span><br><span class="line">        Node&lt;E&gt; f = last;</span><br><span class="line">        Node&lt;E&gt; newNode =<span class="keyword">new</span> Node&lt;E&gt;(last,e,<span class="keyword">null</span>);   <span class="comment">//创建新结点</span></span><br><span class="line">        <span class="keyword">if</span>(f==<span class="keyword">null</span>)&#123;    <span class="comment">//如果last是空的</span></span><br><span class="line">            first = newNode;    <span class="comment">//那么这个新节点就是第一个</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next= newNode; <span class="comment">//原本链表的next指针指向新结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        last = newNode; <span class="comment">//现在新结点就是最后一个结点</span></span><br><span class="line">        size++;     <span class="comment">//结点长度加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//检查下标是否存在</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="comment">//判断添加的位置</span></span><br><span class="line">        <span class="keyword">if</span>(index==size)&#123;    <span class="comment">//添加到尾部</span></span><br><span class="line">            listLast(e);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;              <span class="comment">//添加到非尾部</span></span><br><span class="line">            Node&lt;E&gt; node = node(index);    <span class="comment">//查找到下标对应的结点</span></span><br><span class="line">            linkBefore(e,node);  <span class="comment">//添加到该节点之前</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e,Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; prev = node.prev;   <span class="comment">//该结点的前一个</span></span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; next = node.next;   <span class="comment">//该结点的前一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建要添加进来的新结点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(prev,e,node);</span><br><span class="line">        <span class="keyword">if</span>(prev==<span class="keyword">null</span>)&#123; <span class="comment">//如果该结点时第一个</span></span><br><span class="line">            first=newNode;  <span class="comment">//那么新结点就是第一个</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;     <span class="comment">//该节点不是第一个</span></span><br><span class="line">            prev.next=newNode;  <span class="comment">//那么前一个结点的next指针指向新结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.prev=newNode;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//检测下标是否存在</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; node = node(index); <span class="comment">//要删除的结点</span></span><br><span class="line">        Node prev = node.prev;  <span class="comment">//前一个结点</span></span><br><span class="line">        E e = node.e;</span><br><span class="line">        Node next = node.next;  <span class="comment">//后一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(prev==<span class="keyword">null</span>)&#123; <span class="comment">//如果要清除的是第一个结点</span></span><br><span class="line">            first = next;   <span class="comment">//那第二个结点就编程第一个</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            node.prev =<span class="keyword">null</span>;    <span class="comment">//清空该结点的prev指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next ==<span class="keyword">null</span>)&#123;    <span class="comment">//如果要清除的是最后一个结点</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            node.next = <span class="keyword">null</span>;   <span class="comment">//清空该结点的next指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.e = <span class="keyword">null</span>;  <span class="comment">//清空该结点的值</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPositionIndex(index))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"下标不存在！"</span>);        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index&gt;=<span class="number">0</span> &amp;&amp; index&lt;=size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedListDemo&lt;String&gt; l1 = <span class="keyword">new</span> LinkedListDemo&lt;String&gt;();</span><br><span class="line">        l1.add(<span class="string">"张三"</span>);</span><br><span class="line">        l1.add(<span class="string">"李四"</span>);</span><br><span class="line">        l1.add(<span class="string">"王五"</span>);</span><br><span class="line">        System.out.println(l1.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1.size();i++)&#123;</span><br><span class="line">            System.out.print(l1.get(i)+ <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        l1.add(<span class="number">2</span>,<span class="string">"赵玉"</span>);</span><br><span class="line">        System.out.println(l1.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1.size();i++)&#123;</span><br><span class="line">            System.out.print(l1.get(i)+ <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        l1.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(l1.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1.size();i++)&#123;</span><br><span class="line">            System.out.print(l1.get(i)+ <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        l1.clear();</span><br><span class="line">        System.out.println(l1.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">3</span></span><br><span class="line">张三 李四 王五 </span><br><span class="line"><span class="number">4</span></span><br><span class="line">张三 李四 赵玉 王五 </span><br><span class="line"><span class="number">3</span></span><br><span class="line">张三 李四 赵玉 </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;计算机存储、组织数据的方式&lt;/p&gt;
&lt;p&gt;数据结构可以编写出更优雅、更有效率的代码S&lt;/p&gt;
&lt;h1 id=&quot;栈（Stack
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 集合-1</title>
    <link href="https://cometorbityh.github.io/2019/11/20/JAVA-%E9%9B%86%E5%90%88-1/"/>
    <id>https://cometorbityh.github.io/2019/11/20/JAVA-集合-1/</id>
    <published>2019-11-20T13:42:57.000Z</published>
    <updated>2019-11-24T15:12:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191124224923.png" class="lozad"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>集合——用来存储引用类型数据的<strong>容器</strong>，只能<strong>存储对象</strong>。</p><p> 所有集合类都位于 <code>java.util</code> 包下，但支持多线程的集合类位于 java.util.concurrent 包下 </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>Collection集合（单列集合）：存储数据时单个存储</li><li>Map集合（双列集合）：存储数据时按键值对形式存储</li></ul><h2 id="集合与数组的区别与联系"><a href="#集合与数组的区别与联系" class="headerlink" title="集合与数组的区别与联系"></a>集合与数组的区别与联系</h2><ul><li>数组长度固定，集合长度可变</li><li>数组元素可以是基本类型，也可以是对象，集合只能保存对象</li><li>集合底层是数组</li></ul><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><ul><li>Java 集合类主要由两个根接口 <strong>Collection</strong> 和 <strong>Map</strong> 派生出来的，Collection 派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此 Java 集合大致也可分成 List、Set、Queue、Map 四种接口体系，（注意： Map 不是 Collection 的子接口）。</li><li>其中<ul><li>List 代表了有序可重复集合，可直接根据元素的索引来访问；</li><li>Set 代表无序不可重复集合，只能根据元素本身来访问；</li><li>Queue 是队列集合；</li><li>Map代表的是存储 key-value 对的集合，可根据元素的 key 来访问 value 。</li></ul></li><li>图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是<code>ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap</code>等实现类。</li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120224248.png" class="lozad"></p><p> <img alt="img" data-src="https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190118095106326-273814633.png" class="lozad"> </p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>Collection 是一个接口，因此无法直接创建对象，所以使用它的实现类 ArrayList 来创建对象，进而用来举例。</p><h2 id="常用方法（掌握10个）"><a href="#常用方法（掌握10个）" class="headerlink" title="常用方法（掌握10个）"></a>常用方法（掌握10个）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; container = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;String&gt; container2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add() remove() size() contains() </span></span><br><span class="line">    container.add(<span class="string">"东邪"</span>);</span><br><span class="line">    container.add(<span class="string">"西毒"</span>);</span><br><span class="line">    container.add(<span class="string">"南帝"</span>);</span><br><span class="line">    container.add(<span class="string">"北丐"</span>);</span><br><span class="line">    container.add(<span class="string">"中神通"</span>);</span><br><span class="line">    System.out.println(container);  <span class="comment">// [东邪, 西毒, 南帝, 北丐, 中神通]</span></span><br><span class="line"></span><br><span class="line">    container.remove(<span class="string">"西毒"</span>);</span><br><span class="line">    System.out.println(container);  <span class="comment">// [东邪, 南帝, 北丐, 中神通]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(container.size());   <span class="comment">// 4</span></span><br><span class="line">    System.out.println(container.contains(<span class="string">"西毒"</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    container2.add(<span class="string">"AAA"</span>);</span><br><span class="line">    container2.add(<span class="string">"BBB"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addAll()  removeAll() containsAll()</span></span><br><span class="line">    container.addAll(container2);</span><br><span class="line">    System.out.println(container);  <span class="comment">//[东邪, 南帝, 北丐, 中神通, AAA, BBB]</span></span><br><span class="line">    System.out.println(container.containsAll(container2));  <span class="comment">//true</span></span><br><span class="line">    container.removeAll(container2);</span><br><span class="line">    System.out.println(container);  <span class="comment">//[东邪, 南帝, 北丐, 中神通]</span></span><br><span class="line">    System.out.println(container.containsAll(container2));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear() isEmpty()</span></span><br><span class="line">    container.clear();</span><br><span class="line">    System.out.println(container.isEmpty());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合转为数组，并遍历</span></span><br><span class="line">    <span class="comment">// (1) 普通for循环</span></span><br><span class="line">    <span class="keyword">for</span> (String c : container2)&#123;</span><br><span class="line">            System.out.print(c + <span class="string">" "</span>);  <span class="comment">//AAA BBB</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    Object[] objects = container2.toArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;objects.length;i++)&#123;</span><br><span class="line">        System.out.print(objects[i] + <span class="string">" "</span>); <span class="comment">//AAA BBB</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (2) 增强for循环</span></span><br><span class="line">    <span class="keyword">for</span> (Object obj:objects)&#123;</span><br><span class="line">        System.out.print(obj + <span class="string">" "</span>);    <span class="comment">//AAA BBB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3) 迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; ite = container2.iterator();</span><br><span class="line">        <span class="keyword">while</span> (ite.hasNext())&#123;</span><br><span class="line">            String next = ite.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"BBB"</span>.equals(next))&#123;</span><br><span class="line">                ite.remove();   <span class="comment">//删除BBB</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(container2); <span class="comment">//[AAA]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶方法（）"><a href="#进阶方法（）" class="headerlink" title="进阶方法（）"></a>进阶方法（）</h2><h2 id="⭐迭代器-Iterator-原理简介"><a href="#⭐迭代器-Iterator-原理简介" class="headerlink" title="⭐迭代器 Iterator 原理简介"></a>⭐迭代器 Iterator 原理简介</h2><p>在上面代码中，遍历集合元素用到了迭代器。</p><p> Iterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合和数组中的元素。</p><p> 注意：<strong>Iterator只能单向移动</strong> 。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//Collection接口的iterator方法</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td><strong>hasNext( )</strong></td><td>如果迭代器中还有元素，则返回 true</td></tr><tr><td><strong>next( )</strong></td><td>返回迭代器中的下一个元素</td></tr><tr><td><strong>remove( )</strong></td><td>删除集合里上一次 next 方法返回的元素</td></tr></tbody></table><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120223510.png" class="lozad"></p><h1 id="集合与泛型"><a href="#集合与泛型" class="headerlink" title="集合与泛型"></a>集合与泛型</h1><p>前面发现，创建集合对象时加入了泛型，为什么需要泛型？我们先来看个例子：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">"My is none T"</span>);</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">  String name = (String) list.get(i); <span class="comment">//取出Integer时，运行时出现异常，因此类型不安全</span></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"name:"</span> + name)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不加泛型，List默认是Object，所以加一个String和Integer值是合法的，但是在取数据用的时候，忽略之前的兼容，会出现ClassCastException。</p><p>Collection 虽然可以存储各种对象，但是通常只存储同一类型的对象，例如String</p><p>因此在KDK5之后，加入了泛型，使我们在设计方法或类时支持泛型，在编译期进行语法检查，运行时擦除泛型</p><h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><p>泛型，即“<strong>参数化类型</strong>”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>将数据类型作为参数进行传递，应用到方法、类或接口上。</p><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><ul><li>泛型的主要目标是<strong>提高 Java 程序的类型安全</strong>。 </li><li>消除强制类型转换。避免类型转换的麻烦。储存的是什么类型，取出的就是什么类型</li><li>将运行期异常（ClassCastException） 提升到 编译期 （不加泛型时，编译时就可以看到黄色波浪线警告）</li><li>潜在的性能收益 </li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191122160322.png" class="lozad"></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>格式：</p><ul><li>修饰符  &lt;代表泛型的变量&gt;  返回值类型  方法名（参数）{ }</li></ul><p>特点：调用方法时，确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e + <span class="string">"---"</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">new</span> Container();</span><br><span class="line">        container.insert(<span class="string">"你好"</span>);</span><br><span class="line">        container.insert(<span class="number">11</span>);</span><br><span class="line">        container.insert(<span class="number">11.90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">你好---java.lang.String</span><br><span class="line"><span class="number">11</span>---java.lang.Integer</span><br><span class="line"><span class="number">11.9</span>---java.lang.Double</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>格式 ： <code>修饰符 interface 接口名 &lt;代表泛型的变量&gt; {}</code></p><p>实现接口时旧确定泛型的类型。创建对象时只能创建该泛型类型的对象。这种方式适合确定性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContainerImpl</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">getinfo</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">implements</span> <span class="title">ContainerImpl</span> &lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"---"</span> + s.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getinfo</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ContainerImpl&lt;String&gt; container = <span class="keyword">new</span> Container();</span><br><span class="line">        container.insert(<span class="string">"你好"</span>);</span><br><span class="line">        <span class="comment">//container.insert(11);   //报错Error int无法转换为String</span></span><br><span class="line">        <span class="comment">//container.insert(11.90);    //报错Error double无法转换为String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">你好---java.lang.String</span><br></pre></td></tr></table></figure><p>实现类不确定泛型的类型，直到创建对象时，才确定泛型的类型。这种方式更加灵活，适合范围较广的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContainerImpl</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">getinfo</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ContainerImpl</span> &lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e + <span class="string">"---"</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getinfo</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ContainerImpl&lt;String&gt; container = <span class="keyword">new</span> Container&lt;String&gt;();</span><br><span class="line">        container.insert(<span class="string">"你好"</span>);</span><br><span class="line"></span><br><span class="line">        Container&lt;Integer&gt; container2 = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">        container2.insert(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h2><p>当使用泛型类或接口时，传递的数据中泛型类型不确定，可以通过通配符 &lt;?&gt; 来确定</p><p>注意：泛型没有继承关系。如：</p><p><code>Collection&lt;Object&gt; list  = new ArrayList&lt;String&gt;();</code>这种写法是错误的，</p><p><code>ArrayList&lt;Object&gt;</code>和 <code>ArrayList&lt;String&gt;</code>没有任何关系。 </p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191122164957.png" class="lozad"></p><h2 id="通配符的上下限"><a href="#通配符的上下限" class="headerlink" title="通配符的上下限"></a>通配符的上下限</h2><p>那么有时候我们也不想让所有类都能作为泛型的类型怎么办？</p><p>这时候，就要了解通配符的上下限了。</p><p>Java的泛型可以使用通配符指定一个泛型的上限和下限</p><p>上限：只能接收该类型及其子类</p><ul><li>格式：<code>类型名称 &lt;? extends 类&gt; 对象名称</code></li></ul><p>下限；只能接收该类型及其父类</p><ul><li>格式：<code>类型名称 &lt;? super 类&gt; 对象名称</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(Collection&lt;? extends Number&gt; collection)</span> </span>&#123;</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getString</span><span class="params">(Collection&lt;? <span class="keyword">super</span> String&gt; collection)</span> </span>&#123;</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Collection&lt;Integer&gt; c1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collection&lt;Float&gt; c2 = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line">        Collection&lt;String&gt; c3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collection&lt;Number&gt; c4 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        Collection&lt;Object&gt; c5 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试上限</span></span><br><span class="line">        getNumber(c1);</span><br><span class="line">        getNumber(c2);</span><br><span class="line">        <span class="comment">//getNumber(c3);  //编译报错。String不是Number的子类</span></span><br><span class="line">        getNumber(c4);</span><br><span class="line">        <span class="comment">//getNumber(c5);  //编译报错。Object不是Number的子类</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 测试下限</span></span><br><span class="line">        getString(c3);</span><br><span class="line">        <span class="comment">//getString(c4);  //编译报错。Number不是String的父类</span></span><br><span class="line">        getString(c5);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>统计一个数组中大于某个元素的个数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h1&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://yanghanblog.oss-cn-hangzhou.aliyunc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 异常</title>
    <link href="https://cometorbityh.github.io/2019/11/20/JAVA-%E5%BC%82%E5%B8%B8/"/>
    <id>https://cometorbityh.github.io/2019/11/20/JAVA-异常/</id>
    <published>2019-11-20T10:52:27.000Z</published>
    <updated>2019-11-20T15:38:35.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p><code>java.lang.RunTime</code> 类代表Java程序的运行时环境 。</p><p> 在<strong>每一个JVM进程</strong>里面都会存在有一个<strong>Runtime类的对象</strong>，这个类的主要功能是取得一些与运行时有关时环境的属性或者创建新的进程等操作。 </p><p>Runtime只有一个对象，在其它类无法使用new关键字来创建Runtime对象，该对象我们称之为“”单例对象”。</p><p>同时Runtime的设计模式称之为单例模式，是23种设计模式的其中一种。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120190401.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120190814.png" class="lozad"></p><h2 id="初识-单例模式"><a href="#初识-单例模式" class="headerlink" title="初识 单例模式"></a>初识 单例模式</h2><p>从Runtime的源码来看 ，我们可以总结出单例模式的设计思路了：</p><ol><li>创建一个私有的静态的对象（只加载一次）</li><li>构造器私有化（防止外部类创建对象）</li><li>写一个静态方法（可直接调用方法获得对象）</li></ol><p>现在模仿Runtime类来创建一个单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个私有的静态的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);  <span class="comment">//true，证明是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime-常见方法"><a href="#Runtime-常见方法" class="headerlink" title="Runtime 常见方法"></a>Runtime 常见方法</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Process exec(String command) throws IOException</td><td>执行 可以打开应用 或执行命令</td></tr><tr><td>native long freeMemory()</td><td>JVM虚拟机当前可用的内存，单位字节</td></tr><tr><td>native long totalMemory()</td><td>此电脑最多为JVM分配的内存，单位字节</td></tr><tr><td>native long maxMemory()</td><td>JVM总内存，单位字节</td></tr><tr><td>native int availableProcessors()</td><td>获得JVM运行的可用核数</td></tr><tr><td>void gc()</td><td>释放掉垃圾空间<br>  *  GC（Garbage Collector）垃圾收集器，指的是释放无用的内存空间。<br>  *  GC 会由系统不定期进行自动的回收，或者调用Runtime类中的 gc() 方法 手动回收</td></tr></tbody></table><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的继承体系结构"><a href="#异常的继承体系结构" class="headerlink" title="异常的继承体系结构"></a>异常的继承体系结构</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120200111.png" class="lozad"></p><h2 id="异常的5个关键字"><a href="#异常的5个关键字" class="headerlink" title="异常的5个关键字"></a>异常的5个关键字</h2><p><code>throws</code>：用在方法签名中，声明该方法可能抛出的异常</p><p><code>throw</code>：抛出异常</p><p><code>try</code>：将被监听的代码放在try代码块中</p><p><code>catch</code>：捕获异常</p><p><code>finally</code>:无论是否捕获到异常，都会执行其中的代码。主要用于<strong>回收</strong>在try块中打开的<strong>资源</strong>(如数据库连接、网络连接、磁盘文件)</p><p><strong>只有finally块执行完成后。才会回来执行try块或catch块中的return或throw语句。若finally块中使用了return或throw等种植方法的语句，则不会跳回执行，直接停止。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = divide(<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(result);     <span class="comment">//finally...  2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = a/b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = divide(<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(result);     <span class="comment">//finally...  66666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = a/b;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">//未执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"b can not be zero"</span>);   <span class="comment">//未执行</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">66666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JAVA中try、catch、finally带return的执行顺序总结"><a href="#JAVA中try、catch、finally带return的执行顺序总结" class="headerlink" title="JAVA中try、catch、finally带return的执行顺序总结"></a>JAVA中try、catch、finally带return的执行顺序总结</h2><p>转载自：<a href="https://www.cnblogs.com/pcheng/p/10968841.html" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/10968841.html</a></p><p>　　</p><p>异常处理中，try、catch、finally的执行顺序，大家都知道是按顺序执行的。即，</p><ul><li>如果try中没有异常，则顺序为try→finally，</li><li>如果try中有异常，则顺序为try→catch→finally。</li></ul><p>但是当try、catch、finally中加入return之后，就会有几种不同的情况出现。</p><p>下面分别来说明一下。也可以跳到最后直接看总结。</p><p><strong>一、try中带有return</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">testReturn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"try:"</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"catch:"</span> + i);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"finally:"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------输出-------------</span><br><span class="line"><span class="keyword">try</span>:<span class="number">2</span></span><br><span class="line"><span class="keyword">finally</span>:<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>因为当try中带有return时，会先执行return前的代码，然后暂时保存需要return的信息，再执行finally中的代码，最后再通过return返回之前保存的信息。所以，这里方法返回的值是try中计算后的2，而非finally中计算后的3。</p><p>但有一点需要注意，再看另外一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">testReturn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"try:"</span> + list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"catch:"</span> + list);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"finally:"</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------输出-------------</span><br><span class="line"><span class="keyword">try</span>:[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">finally</span>:[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>看完这个例子，可能会发现问题，刚提到return时会临时保存需要返回的信息，不受finally中的影响，为什么这里会有变化？其实问题出在参数类型上，上一个例子用的是基本类型，这里用的引用类型。list里存的不是变量本身，而是变量的地址，所以当finally通过地址改变了变量，还是会影响方法返回值的。</p><p><strong>二、catch中带有return</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">testReturn3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"try:"</span> + i);</span><br><span class="line">        <span class="keyword">int</span> x = i / <span class="number">0</span> ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"catch:"</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"finally:"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------输出-------------</span><br><span class="line"><span class="keyword">try</span>:<span class="number">2</span></span><br><span class="line"><span class="keyword">catch</span>:<span class="number">3</span></span><br><span class="line"><span class="keyword">finally</span>:<span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>catch中return与try中一样，会先执行return前的代码，然后暂时保存需要return的信息，再执行finally中的代码，最后再通过return返回之前保存的信息。所以，这里方法返回的值是try、catch中累积计算后的3，而非finally中计算后的4。</p><p><strong>三、finally中带有return</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">testReturn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"try:"</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"catch:"</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"finally:"</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------输出-------------</span><br><span class="line"><span class="keyword">try</span>:<span class="number">2</span></span><br><span class="line"><span class="keyword">finally</span>:<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当finally中有return的时候，try中的return会失效，在执行完finally的return之后，就不会再执行try中的return。这种写法，编译是可以编译通过的，但是编译器会给予警告，所以不推荐在finally中写return，这会破坏程序的完整性，而且一旦finally里出现异常，会导致catch中的异常被覆盖。</p><p><strong>总结：</strong></p><p>1、finally中的代码总会被执行。</p><p>2、当try、catch中有return时，也会执行finally。return的时候，要注意返回值的类型，是否受到finally中代码的影响。</p><p>3、finally中有return时，会直接在finally中退出，导致try、catch中的return失效。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120195955.png" class="lozad"></p><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120195736.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120195400.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191120195540.png" class="lozad"></p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h1 id="日志框架-log4j-和-log4j2"><a href="#日志框架-log4j-和-log4j2" class="headerlink" title="日志框架 log4j 和 log4j2"></a>日志框架 log4j 和 log4j2</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Runtime&quot;&gt;&lt;a href=&quot;#Runtime&quot; class=&quot;headerlink&quot; title=&quot;Runtime&quot;&gt;&lt;/a&gt;Runtime&lt;/h1&gt;&lt;p&gt;&lt;code&gt;java.lang.RunTime&lt;/code&gt; 类代表Java程序的运行时环境 。&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA 日期相关类 概述</title>
    <link href="https://cometorbityh.github.io/2019/11/19/JAVA-%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB-%E6%A6%82%E8%BF%B0/"/>
    <id>https://cometorbityh.github.io/2019/11/19/JAVA-日期相关类-概述/</id>
    <published>2019-11-19T02:52:11.000Z</published>
    <updated>2019-11-19T13:29:19.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h1><h1 id="1-DecimalFormat"><a href="#1-DecimalFormat" class="headerlink" title="1 DecimalFormat"></a>1 DecimalFormat</h1><p>DecimalFormat可以对数字进行格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3333333.666666</span>;</span><br><span class="line">    DecimalFormat df = <span class="keyword">new</span> DecimalFormat();</span><br><span class="line">    System.out.println(df.format(d));   <span class="comment">// 3,333,333.667</span></span><br><span class="line"></span><br><span class="line">    df.setGroupingSize(<span class="number">2</span>);      <span class="comment">//每2位一个分隔符</span></span><br><span class="line">    df.setGroupingUsed(<span class="keyword">true</span>);</span><br><span class="line">    df.setMaximumFractionDigits(<span class="number">6</span>); <span class="comment">//设置小数部分最大位数（默认3位）</span></span><br><span class="line">    df.setMinimumIntegerDigits(<span class="number">5</span>); <span class="comment">//设置整数部分最大位数</span></span><br><span class="line"></span><br><span class="line">    DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();</span><br><span class="line">    dfs.setGroupingSeparator(<span class="string">'-'</span>);  <span class="comment">//设置分隔符</span></span><br><span class="line">    dfs.setDecimalSeparator(<span class="string">'*'</span>);   <span class="comment">//设置小数点</span></span><br><span class="line">    df.setDecimalFormatSymbols(dfs);</span><br><span class="line">    String d1 = df.format(d);</span><br><span class="line">    System.out.println(d1);     <span class="comment">//3-33-33-33*666666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-BigInteger"><a href="#2-BigInteger" class="headerlink" title="2 BigInteger"></a>2 BigInteger</h1><p>当我们定义一个数超出这个数的范围时会报错，但是我们却必须使用这个数值和类型时该怎么办？</p><p>Java中有一个类 java.math.BigInteger 可以表示任意长度，就是用来<code>处理数值溢出问题</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Integer.MAX_VALUE);  <span class="comment">//2147483647</span></span><br><span class="line">    BigInteger bi1 = <span class="keyword">new</span> BigInteger(<span class="string">"2147483648"</span>);  <span class="comment">//超出Int范围</span></span><br><span class="line">    BigInteger bi2 = <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">    System.out.println(<span class="string">"bi1-bi2="</span>+(bi1.subtract(bi2).intValue()));   <span class="comment">//此时结果范围在Integer之内</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(Long.MAX_VALUE);  <span class="comment">//9223372036854775807</span></span><br><span class="line">    BigInteger bi3 = <span class="keyword">new</span> BigInteger(<span class="string">"9223372036854775807"</span>);  <span class="comment">//超出Long范围</span></span><br><span class="line">    BigInteger bi4 = <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">    System.out.println(<span class="string">"bi3-bi4="</span>+(bi3.subtract(bi4).longValue()));   <span class="comment">//此时结果范围在Long之内</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-BigDecimal"><a href="#3-BigDecimal" class="headerlink" title="3 BigDecimal"></a>3 BigDecimal</h1><p>用double进行数值计算时，会出现精度问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d2=<span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">double</span> d3=<span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"d1-d2="</span>+(d1-d2));   <span class="comment">//0.8999999999999999</span></span><br><span class="line">    System.out.println(<span class="string">"d1-d3="</span>+(d1-d3));   <span class="comment">//1.1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们在进行科学计算/财务计算时，一般使用另一个类：BigDecimal来表示任意精度，可以用来<code>处理精度问题</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(<span class="string">"2"</span>);</span><br><span class="line">    BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.2"</span>);</span><br><span class="line">    BigDecimal bd3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.1"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"bd1-bd2="</span>+(bd1.subtract(bd2).doubleValue()));   <span class="comment">//减法 0.8</span></span><br><span class="line">    System.out.println(<span class="string">"bd1-bd3="</span>+(bd1.subtract(bd3).doubleValue()));   <span class="comment">//0.9</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日期相关类&quot;&gt;&lt;a href=&quot;#日期相关类&quot; class=&quot;headerlink&quot; title=&quot;日期相关类&quot;&gt;&lt;/a&gt;日期相关类&lt;/h1&gt;&lt;h1 id=&quot;1-DecimalFormat&quot;&gt;&lt;a href=&quot;#1-DecimalFormat&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA Object:常见方法概述</title>
    <link href="https://cometorbityh.github.io/2019/11/19/JAVA-Object-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://cometorbityh.github.io/2019/11/19/JAVA-Object-常见方法概述/</id>
    <published>2019-11-19T02:51:49.000Z</published>
    <updated>2019-11-19T12:35:48.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>java.lang.Object类是所有类的根，即所有类都直接或间接继承Object类，每个类都将Object当作超类。</p><p><strong><font color="red">所有的对象，数组都实现了 Object 的方法</font></strong></p><p>native关键字：Java具体是由C写的代码，native可以调用这些代码协助完成源码编写。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>getClass( )</td><td>获得java.lang.Class对象，在反射时会用（该类用final修饰，<strong>不可重写</strong>）</td><td></td></tr><tr><td>hashCode( )</td><td>hashSet集合确保对象唯一性</td><td></td></tr><tr><td><strong>equals( )</strong></td><td>判断是否是同一个对象，默认比较引用的地址（可重写）</td><td></td></tr><tr><td><strong>toString( )</strong></td><td>代表这类字符串【格式：<code>全限定类名@十六进制hashcode</code>】（可重写）</td><td></td></tr><tr><td><font color="red">clone( )</font></td><td>克隆对象（深拷贝 、 浅拷贝）</td><td></td></tr><tr><td>finalize( )</td><td>gc回收对象时会调用的方法</td><td></td></tr><tr><td>notify( )</td><td>（多线程相关）线程等待唤醒机制</td><td></td></tr><tr><td>notifyAll( )</td><td>（多线程相关）</td><td></td></tr><tr><td>wait( )</td><td>（多线程相关）</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="clone"><a href="#clone" class="headerlink" title="clone( )"></a>clone( )</h2><p> 克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝。 </p><p> 在<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>中对象的克隆有深克隆和浅克隆之分。有这种区分的原因是Java中分为基本数据类型和引用数据类型，对于不同的数据类型在内存中的存储的区域是不同的。基本数据类型存储在栈中，引用数据类型存储在堆中。 </p><p>clone的步骤：</p><ol><li>对象的类实现Cloneable接口；</li><li>覆盖Object类的clone()方法 （<strong>覆盖clone()方法，访问修饰符设为public，默认是protected</strong>）；</li><li>在clone()方法中调用super.clone()；</li></ol><p>clone( ) 的浅拷贝</p><p> 指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String country, String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//getter , setter , toString()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现Cloneable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重写clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter , setter , toString()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="string">"中国"</span>,<span class="string">"北京"</span>);</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"XiaoHei"</span>,address);</span><br><span class="line">        User u2 = (User)u1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(u1 == u2);</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改u1的Address的city属性</span></span><br><span class="line">        u1.getAddress().setCity(<span class="string">"上海"</span>);</span><br><span class="line">        System.out.println(u1 == u2);</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'北京'</span>&#125;&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'北京'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'上海'</span>&#125;&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'上海'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，克隆前后的对象不相等，因为他们本来就不是同一个对象，因此不相等</p><p>但是当u1修改属性值时，为什么u2也跟着修改？</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191119165826.png" class="lozad"></p><p>原来，这2个对象的address都指向同一个引用，但这个address引用的内容发生变化时，这2个对象的address的值也就随之发生变化了，这就是浅拷贝。</p><p>那么如何使克隆后的对象不受影响呢？这就要用到深拷贝了</p><p>clone( ) 的深拷贝</p><p> 不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 实现Cloneable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String country, String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//getter , setter , toString()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现Cloneable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重写clone方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = (User)<span class="keyword">super</span>.clone();</span><br><span class="line">        Address address = (Address) user.address.clone();</span><br><span class="line">        user.setAddress(address);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter , setter , toString()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="string">"中国"</span>,<span class="string">"北京"</span>);</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"XiaoHei"</span>,address);</span><br><span class="line">        User u2 = (User)u1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(u1 == u2);</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改u1的Address的city属性</span></span><br><span class="line">        u1.getAddress().setCity(<span class="string">"上海"</span>);</span><br><span class="line">        System.out.println(u1 == u2);</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'北京'</span>&#125;&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'北京'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'上海'</span>&#125;&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'XiaoHei'</span>, address=Address&#123;country=<span class="string">'中国'</span>, city=<span class="string">'北京'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>首先给Address类重写clone方法，然后修改User类中的clone方法，使其克隆User对象时同时克隆Address对象。</p><p>这样克隆后的对象就不会受到前对象修改数据时的影响了。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191119165719.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类&quot;&gt;&lt;/a&gt;Object类&lt;/h1&gt;&lt;p&gt;java.lang.Object类是所有类的根，即所有类都直接或间接继承Object类，每个类都将O
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA String类</title>
    <link href="https://cometorbityh.github.io/2019/11/18/JAVA-String%E7%B1%BB/"/>
    <id>https://cometorbityh.github.io/2019/11/18/JAVA-String类/</id>
    <published>2019-11-18T11:44:53.000Z</published>
    <updated>2019-11-24T15:10:28.195Z</updated>
    
    <content type="html"><![CDATA[<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191124230956.png" class="lozad"></p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="使用String对象存储字符串"><a href="#使用String对象存储字符串" class="headerlink" title="使用String对象存储字符串"></a>使用String对象存储字符串</h2><p>创建String对象常见的3种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line"></span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(<span class="string">"str2 = "</span> + str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chs = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String (chs);</span><br><span class="line">    System.out.println(<span class="string">"str3 = "</span> + str3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡是用“=”直接创建字符串对象的，都是保存在字符串常量池；</p><p>使用 new 关键字创建字符串对象的，保存的是指向栈内存对象的地址。</p><p> String类位于java.lang包下，是Java语言的核心类，提供了字符串的<strong>比较、查找、截取、大小写转换</strong>等操作；</p><p>Java语言为“+”连接符（字符串连接符）以及对象转换为字符串提供了特殊的支持，字符串对象可以使用“+”连接其他对象。 </p><h2 id="String本质——char数组"><a href="#String本质——char数组" class="headerlink" title="String本质——char数组"></a>String本质——char数组</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123232752.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191118201135.png" class="lozad"></p><p>根据上面的代码和源码，我们可以看出，</p><p>String类被final关键字修饰，因此无法被继承，且其成员方法都默认是final方法。</p><ul><li>在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。 </li></ul><p><font color="red">String的本质就是一个char数组！！！</font></p><p>由于有final的存在，该数组就是常量，通过初始化后，值就是不可变的了，也就证明了String的<font color="red">不可变性</font></p><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><p><font color="red">不可变：一旦一个字符串被创建后。它的值就不能被修改了。</font></p><p>在这里有个疑惑，为什么是不可变的？String对象不是可以修改吗？</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">    str1 = <span class="string">"def"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------控制台--------</span><br><span class="line">str1 = abc</span><br><span class="line">str1 = def</span><br></pre></td></tr></table></figure><p>不急，我们首先来看看这2个是同一对象嘛，案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">    System.out.println(<span class="string">"hashcode = "</span>+ str1.hashCode());</span><br><span class="line">    str1 = <span class="string">"def"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">    System.out.println(<span class="string">"hashcode = "</span>+ str1.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">--------控制台--------</span><br><span class="line">str1 = abc</span><br><span class="line">hashcode = <span class="number">96354</span></span><br><span class="line">str1 = def</span><br><span class="line">hashcode = <span class="number">99333</span></span><br></pre></td></tr></table></figure><p>可以看出，修改前后的2个String对象的hashcode不一样，这说明这2个不是同一个对象。</p><p>其实不是改变了，只是这个引用指向的对象不一样了。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191124000919.png" class="lozad"></p><p>这可能是巧合，我们在看一个案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">    System.out.println(<span class="string">"hashcode = "</span>+ str1.hashCode());</span><br><span class="line"></span><br><span class="line">    str1 = str1.concat(<span class="string">"def"</span>);  <span class="comment">//等价于 str1 = str1 + "def";</span></span><br><span class="line">    System.out.println(<span class="string">"str1 = "</span> + str1);</span><br><span class="line">    System.out.println(<span class="string">"hashcode = "</span>+ str1.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这2个对象的hashcode还是不同的，这是为什么呢？我们来看下concat方法的源码：</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191118202217.png" class="lozad"></p><p>可以看出，concat方法的返回值是一个<strong>全新的String对象</strong>，原来String的底层源码也隐藏着这么一层复杂的逻辑。</p><p><strong>因此说String对象具有不可变性。</strong></p><h2 id="String类常用的方法及使用"><a href="#String类常用的方法及使用" class="headerlink" title="String类常用的方法及使用"></a>String类常用的方法及使用</h2><table><thead><tr><th>常见方法</th><th>作用</th></tr></thead><tbody><tr><td>public toCharArray()</td><td>将String对象转换为char数组</td></tr><tr><td>public char charAt(int index)</td><td>获得char数组的对应下标的元素</td></tr><tr><td>public int compareTo(String anotherString)</td><td>比较2个字符串的字典顺序</td></tr><tr><td>public int compareToIgnoreCase(String anotherString)</td><td>比较2个字符串的字典顺序（忽略大小写）</td></tr><tr><td>public String concat(String str)</td><td>增长字符串</td></tr><tr><td>public int indexOf(String str)</td><td>获得另一字符串第一次在本字符串出现的索引值（从前往后找），若不存在则返回-1</td></tr><tr><td>public int lastIndexOf(String str)</td><td>获得另一字符串第一次在本字符串出现的索引值（从后往前找），若不存在则返回-1</td></tr><tr><td>public boolean contains(CharSequence s)</td><td>判断是否包含该字符串</td></tr><tr><td>public boolean startsWith(String prefix)</td><td>判断该字符串是否以另一字符串开始的</td></tr><tr><td>public boolean endsWith(String suffix)</td><td>判断该字符串是否以另一字符串结尾的</td></tr><tr><td><code>public boolean equals(Object anObject)</code></td><td>判断2个字符串的值是否相等（String重写了equals方法）</td></tr><tr><td>public int length()</td><td>获取该字符串的长度（注意与length属性的区别）</td></tr><tr><td>public String[] split(String regex)</td><td>将字符串按照固定符号分割成一个字符串数组</td></tr><tr><td>public String toLowerCase()</td><td>将字符串转为小写</td></tr><tr><td>public String toUpperCase()</td><td>将字符串转为大写</td></tr><tr><td>public String trim()</td><td>去掉字符串的前后空格</td></tr><tr><td>public static String valueOf(int i)</td><td>把传入的数据转为字符串</td></tr><tr><td>public static String format(String format, Object… args)</td><td>格式化字符串</td></tr><tr><td>public String replace(CharSequence target, CharSequence replacement)</td><td>将所有的指定字符串替换为新字符串</td></tr><tr><td>public String substring(int beginIndex, int endIndex)</td><td>返回一个新字符串，他是此字符串的子字符串 <strong>[ begin,end )</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.stringtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">        method02();</span><br><span class="line">        method03();</span><br><span class="line">        method04();</span><br><span class="line">        method05();</span><br><span class="line">        method06();</span><br><span class="line">        method07();</span><br><span class="line">        method08();</span><br><span class="line">        method09();</span><br><span class="line">        method10();</span><br><span class="line">        method11();</span><br><span class="line">        method12();</span><br><span class="line">        method13();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  toCharArray()  charAt()  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str1.toCharArray();</span><br><span class="line">        System.out.println(chars[<span class="number">2</span>]);   <span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = str1.charAt(<span class="number">1</span>);</span><br><span class="line">        System.out.println(c);      <span class="comment">//b</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  compareTo(String str)   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   str1.compareTo(str2)</span></span><br><span class="line"><span class="comment">         *   长度不同，内容不同，比较的是2个字符串的第一个同位置但不同字符的字典顺序</span></span><br><span class="line"><span class="comment">         *   长度不同，但前面所有内容都相同，则比较长度</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"def"</span>;</span><br><span class="line">        <span class="keyword">int</span> pos1 = str1.compareTo(str2);</span><br><span class="line">        System.out.println(pos1);    <span class="comment">//-3，字典顺序a-97,d-100</span></span><br><span class="line"></span><br><span class="line">        String str3 = <span class="string">"abc"</span>;</span><br><span class="line">        String str4 = <span class="string">"abcde"</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = str3.compareTo(str4);</span><br><span class="line">        System.out.println(pos2);    <span class="comment">//-2，比较长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* compareToIgnoreCase() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"aBc"</span>;</span><br><span class="line">        System.out.println(str1.compareTo(str2));   <span class="comment">//32</span></span><br><span class="line">        System.out.println(str1.compareToIgnoreCase(str2)); <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* concat() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"hello"</span>;</span><br><span class="line">        str1 = str1.concat(str2);</span><br><span class="line">        System.out.println(str1);    <span class="comment">//abchello</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* contain()  startsWith()  endsWith() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"hello123"</span>;</span><br><span class="line">        String str2 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(str1.contains(str2));    <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.startsWith(<span class="string">"hell"</span>));    <span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.startsWith(<span class="string">"123"</span>));  <span class="comment">//false</span></span><br><span class="line">        System.out.println(str1.endsWith(<span class="string">"hello"</span>));     <span class="comment">//false</span></span><br><span class="line">        System.out.println(str1.endsWith(<span class="string">"123"</span>));   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* indexOf()  lastIndexOf() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"hello123"</span>;</span><br><span class="line">        String str2 = <span class="string">"lo"</span>;</span><br><span class="line">        System.out.println(str1.indexOf(str2));    <span class="comment">//3</span></span><br><span class="line">        System.out.println(str1.lastIndexOf(str2));    <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* equals() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"hello"</span>;  <span class="comment">//存放在字符串常量池</span></span><br><span class="line">        String str2 = <span class="string">"hello"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);  <span class="comment">//指向栈内存的对象的地址值</span></span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);  <span class="comment">//指向栈内存的对象的地址值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));    <span class="comment">//true,比较内容，说明String重写equals方法</span></span><br><span class="line">        System.out.println(str1==str2);           <span class="comment">//true,比较地址值</span></span><br><span class="line">        System.out.println(str1.equals(str3));    <span class="comment">//true,比较内容</span></span><br><span class="line">        System.out.println(str1==str3);           <span class="comment">//false,比较地址</span></span><br><span class="line">        System.out.println(str3.equals(str4));    <span class="comment">//true,比较内容</span></span><br><span class="line">        System.out.println(str3==str4);           <span class="comment">//false,比较地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* length()  length */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"helloWorld"</span>;</span><br><span class="line">        System.out.println(str1.length());  <span class="comment">//10</span></span><br><span class="line">        String[] strs = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line">        System.out.println(strs.length);  <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* split()*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String fruits = <span class="string">"apple,banana,orange"</span>;</span><br><span class="line">        String[] fruits1 = fruits.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit: fruits1)&#123;</span><br><span class="line">            System.out.print(fruit + <span class="string">" "</span>);  <span class="comment">//apple banana orange</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* toLowerCase() toUpperCase() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"AbcDeF"</span>;</span><br><span class="line">        System.out.println(str1.toLowerCase()); <span class="comment">//abcdef</span></span><br><span class="line">        System.out.println(str1.toUpperCase()); <span class="comment">//ABCDEF</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trim() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"     AbcDeF "</span>;</span><br><span class="line">        String str2 = <span class="string">"  Abc   DeF "</span>;</span><br><span class="line">        System.out.println(str1.trim());    <span class="comment">//AbcDeF</span></span><br><span class="line">        System.out.println(str2.trim());    <span class="comment">//Abc   DeF</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valueOf() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">2</span>;</span><br><span class="line">        System.out.println(String.valueOf(i));    <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* format() replace() substring() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = String.format(<span class="string">"Hello: %s,%s"</span>,<span class="string">"小明"</span>,<span class="string">"小红"</span>);   <span class="comment">//Hello: 小明,小红</span></span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="string">"大家好才是真的好"</span>;</span><br><span class="line">        str2 = str2.replace(<span class="string">"好"</span>,<span class="string">"坏"</span>);</span><br><span class="line">        System.out.println(str2);   <span class="comment">//大家坏才是真的坏</span></span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"www.taobao.com"</span>;</span><br><span class="line">        String url1 = url.substring(<span class="number">3</span>);</span><br><span class="line">        System.out.println(url1);   <span class="comment">//.taobao.com</span></span><br><span class="line">        String url2 = url.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(url2);   <span class="comment">//www</span></span><br><span class="line">        String url3 = url.substring(url.indexOf(<span class="string">"."</span>)+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(url3);   <span class="comment">//taobao</span></span><br><span class="line">        String url4 = url.substring(url.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>,<span class="number">14</span>);</span><br><span class="line">        System.out.println(url4);   <span class="comment">//com</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池。</p><p>字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，<strong>常量池中一定不存在两个相同的字符串</strong>。</p><p> 当执行String s1 = “AB”时，JVM首先会去字符串常量池中检查是否存在”AB”对象，如果不存在，则在字符串常量池中创建”AB”对象，并将”AB”对象的地址返回给s1；如果存在，则不创建任何对象，直接将字符串常量池中”AB”对象的地址返回给s1。 </p><h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern() 方法"></a>intern() 方法</h2><p>直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。</p><p><strong>JDK1.7的改动：</strong></p><ul><li>将String常量池 从 Perm 区移动到了 Java Heap区</li><li>String.intern() 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li></ul><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"AB"</span>;</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">"AB"</span>);</span><br><span class="line">    String s3 = <span class="string">"A"</span>;</span><br><span class="line">    String s4 = <span class="string">"B"</span>;</span><br><span class="line">    String s5 = <span class="string">"A"</span> + <span class="string">"B"</span>;</span><br><span class="line">    String s6 = s3 + s4;</span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1 == s6.intern());<span class="comment">//true</span></span><br><span class="line">    System.out.println(s2 == s2.intern());<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">解析：真正理解此题目需要清楚以下三点</span><br><span class="line"><span class="number">1</span>）直接使用双引号声明出来的String对象会直接存储在常量池中；</span><br><span class="line"><span class="number">2</span>）String对象的intern方法会得到字符串对象在常量池中对应的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</span><br><span class="line"><span class="number">3</span>） 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c命令获得<span class="class"><span class="keyword">class</span>文件对应的<span class="title">JVM</span>字节码指令就可以看出来。</span></span><br><span class="line"><span class="class">————————————————</span></span><br><span class="line">原文链接：https://blog.csdn.net/ifwinds/article/details/80849184</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191123234609.png" class="lozad"></p><h1 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer  + StringBuilder"></a>StringBuffer  + StringBuilder</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>StringBuffer  类称为字符串缓冲区，所表示的是一个字符序列，这个类必须使用new创建对象，</p><p>线程安全，效率低</p><p>和 String 类不同的是：StringBuffer  是一个可变的类</p><p>StringBuilder  类与StringBuffer  类兼容，但是线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.stringtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.beans.binding.StringBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"你好，"</span>);</span><br><span class="line">        System.out.println(stringBuffer.hashCode());    <span class="comment">//460141958</span></span><br><span class="line">        System.out.println(stringBuffer);    <span class="comment">//你好,</span></span><br><span class="line">        stringBuffer.append(<span class="string">"世界！"</span>);</span><br><span class="line">        System.out.println(stringBuffer.hashCode());    <span class="comment">//460141958</span></span><br><span class="line">        System.out.println(stringBuffer);    <span class="comment">//你好，世界！</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"你好,"</span>);</span><br><span class="line">        System.out.println(stringBuilder.hashCode());   <span class="comment">//1163157884</span></span><br><span class="line">        System.out.println(stringBuilder);  <span class="comment">//你好,</span></span><br><span class="line">        stringBuilder.append(<span class="string">"未来！"</span>);</span><br><span class="line">        System.out.println(stringBuilder.hashCode());   <span class="comment">//1163157884</span></span><br><span class="line">        System.out.println(stringBuilder);  <span class="comment">//你好,未来！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.stringtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.beans.binding.StringBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* String拼接字符串 */</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">            str =str + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"String cost time:"</span> + (end - begin));    <span class="comment">//String cost time:8463</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* StringBuffer拼接字符串 */</span></span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">            stringBuffer.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"StringBuffer cost time:"</span> + (end - begin));  <span class="comment">//StringBuffer cost time:3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* StringBuilder拼接字符串 */</span></span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">            stringBuilder.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder cost time:"</span> + (end - begin)); <span class="comment">//StringBuilder cost time:1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据看，String花费的时间远远多于StringBuffer和StringBuilder。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>查看源码：</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191118233257.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191118235001.png" class="lozad"></p><p>可以看出，</p><p>StringBuffer对象在进行append时，</p><p>​    加入了同步锁，这样保证了线程安全，但是带来的代价就是多线程时效率不高。</p><p>​    并且append()返回的还是原来的对象，因此<font color="red">StringBuffer从始至终都是一个对象</font>，其实这是StringBuffer在进行扩容的操作。</p><p>StringBuilder对象在进行append时，</p><p>​    没有加入同步锁，这样无法保证了线程安全，但是好处就是多线程时效率高。</p><p>​    并且append()返回的还是原来的对象，因此<font color="red">StringBuilder从始至终都是一个对象</font>，其实这是StringBuilder在进行扩容的操作。</p><p>因此相对于String来说，StringBuffer和StringBuilder的性能要好很多，因为它们始终只有一个对象，而String是保存在字符串常量池中，可能会保存非常多的对象，十分影响性能。</p><blockquote><p><strong>三者区别</strong></p><p>String类不可变，对象一旦被创建，其值便不可被修改，可以使用new关键字或 = 创建对象</p><p>StringBuffer类是可变的，对象创建后可修改，线程安全，效率低，必须使用new关键字创建对象</p><p>StringBuilder类是可变的，对象创建后可修改，线程不安全，效率高，必须使用new关键字创建对象</p><p>执行效率：StringBuilder &gt; StringBuffer &gt; String</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>将一个数字字符串转换成逗号分隔的数字串，（从右向左，每3位数一个逗号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">"请输入数字："</span>);</span><br><span class="line">    String nums = input.next();</span><br><span class="line">    StringBuffer str = <span class="keyword">new</span> StringBuffer(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length()-<span class="number">3</span>;i&gt;<span class="number">0</span>;i=i-<span class="number">3</span>)&#123;</span><br><span class="line">        str.insert(i,<span class="string">','</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">请输入数字：<span class="number">1234567890</span></span><br><span class="line"><span class="number">1</span>,<span class="number">234</span>,<span class="number">567</span>,<span class="number">890</span></span><br></pre></td></tr></table></figure><h1 id="8种基本数据类型的包装类型"><a href="#8种基本数据类型的包装类型" class="headerlink" title="8种基本数据类型的包装类型"></a>8种基本数据类型的包装类型</h1><table><thead><tr><th>基本数据类型</th><th>包装类型</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr></tbody></table><p>使用这8个包装类，能够把某一种基本数据类型的变量转换为引用类型，这样就==可以使用类中的方法==，进行更多操作。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><ul><li>装箱：将基本数据类型包装成对应的包装类型</li><li>拆箱：将包装类型拆开成对应的基本数据类型</li></ul><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>JDK1.5之后，可以进行自动拆装箱的操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    Integer var1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line">    <span class="comment">//拆箱</span></span><br><span class="line">    <span class="keyword">int</span> var2 = var1.intValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动装箱</span></span><br><span class="line">    Integer var3 = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//自动拆箱</span></span><br><span class="line">    <span class="keyword">int</span> var4 = var3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⭐使用常量池"><a href="#⭐使用常量池" class="headerlink" title="⭐使用常量池"></a>⭐使用常量池</h3><p>在自动拆装箱的过程中，Java使用到了常量池。</p><p>需要注意的是：只有数值是<font color="blue">byte范围内（也就是<code>[-128,127]</code>）</font>的时候，才使用到常量池，否则都是分配新的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//手动装箱</span></span><br><span class="line">    Integer i3 = <span class="keyword">new</span> Integer(<span class="number">11</span>);</span><br><span class="line">    Integer i4 = <span class="keyword">new</span> Integer(<span class="number">11</span>);</span><br><span class="line">    System.out.println(i3 == i4);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动装箱</span></span><br><span class="line">    Integer i1 = <span class="number">11</span>;</span><br><span class="line">    Integer i2 = <span class="number">11</span>;</span><br><span class="line">    System.out.println(i1 == i2);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    Integer i5 = <span class="number">128</span>;   <span class="comment">//超出byte范围，将分配新的内存空间</span></span><br><span class="line">    Integer i6 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i5 == i6);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer i7 = -<span class="number">128</span>;</span><br><span class="line">    Integer i8 = -<span class="number">128</span>;</span><br><span class="line">    System.out.println(i7 == i8);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    Integer i9 = -<span class="number">129</span>;</span><br><span class="line">    Integer i10 = -<span class="number">129</span>;</span><br><span class="line">    System.out.println(i9 == i10);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img alt data-src=&quot;https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191124230956.png&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CET6 CORE (1)</title>
    <link href="https://cometorbityh.github.io/2019/11/18/CET6-CORE-1/"/>
    <id>https://cometorbityh.github.io/2019/11/18/CET6-CORE-1/</id>
    <published>2019-11-18T09:44:19.000Z</published>
    <updated>2019-11-20T05:25:50.596Z</updated>
    
    <content type="html"><![CDATA[<p>decline 下降 衰退 拒接绝</p><blockquote><p>refuse fuse-流，往回流，婉拒[一般程度]<br>        reject 拒绝[严重程度] ject-扔 往回扔</p></blockquote><p> derive form 源自于    river小何向下流，即源自于</p><p>&gt; stem from源自于    stem根，根茎<br>originate form源自于<br>    origin名词-起源<br>    original 形容词- 原始的</p><p>deviate from 脱离 偏离 vi-路</p><h2 id="count数数-计算-vi-重要-有影响-有作用"><a href="#count数数-计算-vi-重要-有影响-有作用" class="headerlink" title="count数数 计算 vi-重要 有影响 有作用"></a>count数数 计算 vi-重要 有影响 有作用</h2><blockquote><p>money count 钱重要</p><blockquote><p>matter动词-重要 有影响 有关系 名词-东西 事情 </p></blockquote><p>discount 动词-打折 名词-打折</p><blockquote><p>80% discount打二折</p></blockquote><p>account动词-记账，算账，记录 名词-账目 账户</p><p>bank account银行账户<br>accountant会计师<br>counter 名词- 计算器 计数器 柜台 形容词-相反的 相对的 副词-相反地 相对地 动词-反对<br>OTC over the counter非处方药，在柜台可以卖到的药<br>counterbalance 动词和名词-制衡</p></blockquote><p>graduate名词-毕业生</p><p>&gt; graduate from 从，，，毕业</p><p>candidate 名词-候选人</p><p>fluctuate 动词-波动</p><p>&gt; flu-流动<br>flu流感<br>fluent 流利的，流畅的<br>fluid液体 流体<br>&gt;&gt;solid 名词固体 东形容词-RP牢固的 稳固的 可靠的</p><p>&gt;influence 影响[潜在的，内心的影响]<br>&gt;&gt;affect 影响 fact-做 去做</p><p>&gt;influential 形容词-有影响力的 有权势的<br>名词-有影响里的人 有权势的人<br>indefinite 不明确的 不确定的<br>in-加加在形容词前表示否定 加在其他词前表示进入<br>fin-限制<br>define限定 限制 下定义<br>definition 限定 限制 定义<br>definite 确定的 明确的<br>definitely 一定 肯定<br>finite 有限的<br>infinite无限的</p><p>indicate 暗示 表明 在心里说<br>&gt;dic说<br>predict 预言 预测<br>prediction 预测<br>dictate 口述 口授 命令 支配 我说你写就是命令<br>dictation 口述 口授 命令 支配<br>dictator 发号施令者吗 独裁者</p><p>major 形容词-主要的 重大的 大部分的  名词-专业 动词-主修 专攻<br>majority 大部分<br>the majority of 大部分的<br>minor 名词辅修专业 动词辅修 形容词 次要的 小部分的<br>minority 名词小部分的 少数民族<br>the minority of 少部分的</p><p>potential形容词 有潜力的 有潜能的 潜在的 名词潜力潜能<br>develop your potential 开发潜能</p><p>十五选十 名词<img alt="img" data-src="file:///C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTencent%5CQQTempSys%5C4I%60MDUI8B2C%5DKU_%5BAI$HZ_Y.png" class="lozad">ly=形容词 形容词+ly=副词</p><p>instantaneously 立即地=immediately<br>simultaneously 同时地=at the same time<br>cautiously<br>caution 名词小心谨慎 动词警告=warm<br>cautious形容词 小心的 谨慎的 =careful<br>particularly特别 尤其=especially =in particular<br>specially 特殊地</p><p>permanently 形容词 永恒的 永久的</p><p>constantly持续的 永恒的 不变的 名词常量恒量<br>variable 变量<br>vary 动词变化  very 非常<br>vary form，，，to，，，从。。变化到。。。<br>various变化的<br>variable 能变的 可变的 名词变量</p><p>variation 名词变化<br>variety 名词变化 种类<br>a variety of 各种各样的=all kind of =all sorts of<br>occasionally偶尔地 偶然地<br>occasion 名词 时机 场合<br>occur 发生</p><p>stimulate 动词刺激激励<br>stimulation名词刺激激励激<br>inspire鼓舞<br>motivate 形容词 移动的 运动的 名词动机<br>motivate 使有动机 激励 激发<br>motivate somebody to do something激励某人做某事<br>motion 名词移动 运动<br>motor 摩托车</p><h1 id="tract-拖，拉"><a href="#tract-拖，拉" class="headerlink" title="tract-拖，拉"></a>tract-拖，拉</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>a. 抽象的 <br>v. 提取，抽取，抽出，拔出<br>n. 摘要</td><td>abstract definition  抽象的定义</td><td></td></tr><tr><td>【反】</td><td>concrete</td><td>a. 具体的<br>n.混凝土</td><td></td></tr><tr><td>tractor</td><td>n. 拖拉机</td><td></td><td></td></tr><tr><td>attract</td><td>v. 吸引</td><td></td><td></td></tr><tr><td></td><td>attraction</td><td>n. 吸引</td><td></td></tr><tr><td></td><td>attractive</td><td>a. 有吸引力的</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="ity-…的性质"><a href="#ity-…的性质" class="headerlink" title="-ity  …的性质"></a>-ity  …的性质</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>personality</td><td>n. 个性，名人</td><td></td></tr><tr><td>humanity</td><td>n. 人性，文科</td><td>the  humanities = the arts 文科（总称）<br>the  science 理科</td></tr><tr><td>authority</td><td>n. 权威性，权威，政府当局</td><td>the authorities =  the government 政府当局</td></tr><tr><td>sensitivity</td><td>n. 敏感性</td><td></td></tr><tr><td></td><td>sense</td><td>v. 感觉  n.感觉</td></tr><tr><td></td><td>sensible</td><td>a. 可感觉到的，能感觉到的；明智的</td></tr><tr><td></td><td>sensitive</td><td>a. 敏感的</td></tr><tr><td>credibility</td><td>n. 可信性，可靠性</td><td></td></tr><tr><td></td><td>credit</td><td>n.信用（credit card 信用卡）</td></tr><tr><td></td><td>credible</td><td>a.可信的，有信用的</td></tr><tr><td>【同】</td><td>rely on 依赖，可靠<br>reliable a. 可靠的<br>reliability n.可靠性</td><td></td></tr><tr><td>eligibillity</td><td>n.有资格性</td><td></td></tr><tr><td></td><td>eligiable</td><td>a.有资格的</td></tr><tr><td>feasibility</td><td>n.可行性</td><td></td></tr><tr><td></td><td>feasible</td><td>a.可行的</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="sum-摘，拿"><a href="#sum-摘，拿" class="headerlink" title="sum-摘，拿"></a>sum-摘，拿</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>assume</td><td>v.假设</td><td></td></tr><tr><td></td><td>assumption</td><td>n.假设</td></tr><tr><td>presume</td><td>v.假设</td><td></td></tr><tr><td></td><td>presumption</td><td>n.假设</td></tr></tbody></table><h1 id="sess-坐"><a href="#sess-坐" class="headerlink" title="sess-坐"></a>sess-坐</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>assess</td><td>v.评估</td><td></td></tr><tr><td></td><td>assessment</td><td>n.评估</td></tr><tr><td>asset</td><td>n.资产，财产</td><td></td></tr><tr><td>【同】</td><td>wealth= property</td><td>n. 财产，所有权<br>Intellectual property 知识产权<br>Intellectual a.有知识的  n.知识分子<br>intelligent a.聪明的，智慧的，智能的<br>intelligence n.聪明 智慧 智能 情报（information）<br><br>*CIA 美国中央情报局 central Intelligence Agency <br>AI artificial  a . 人工的 人造的 虚伪的 矫揉造作的   【反】natural 自然的<br><br>knowledge</td></tr><tr><td>access</td><td>v . 接近 靠近<br>n . 通道 途径</td><td>have access to… 由途径得到/接触 …<br></td></tr><tr><td></td><td>accessible</td><td>a . 可接近的 可靠近的 可得到的</td></tr><tr><td>process</td><td>n. 工艺 工序； 过程<br>v . 加工 处理</td><td>microprocessor 微型处理器<br>chip n . 薯片 芯片</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="micro-微小的"><a href="#micro-微小的" class="headerlink" title="micro- 微小的"></a>micro- 微小的</h1><p>formula n. 功时</p><p>formulate v. 用公式表示；系统阐述，系统化说明</p><p>十五选十</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>confidentially</td><td>ad . 秘密地 机密地</td><td></td></tr><tr><td></td><td>confidently</td><td>ad.  自信地</td></tr><tr><td></td><td></td><td></td></tr><tr><td>mysteriously</td><td>ad . 神秘地</td><td></td></tr><tr><td></td><td>mystery</td><td>n . 神秘</td></tr><tr><td></td><td>mysterious</td><td>a . 神秘的</td></tr><tr><td>radically</td><td>根本地</td><td></td></tr><tr><td></td><td>radical</td><td>a. 根本的 ，根本性的 （changes）；激进的 彻底的</td></tr><tr><td>separately</td><td>ad  .  分开地 分别地</td><td></td></tr><tr><td></td><td>separate</td><td>a. 分开的<br>v. 分开 分别<br>separate from… 与 …分开</td></tr><tr><td>frequently</td><td>经常地</td><td></td></tr><tr><td></td><td>frequent</td><td>经常的</td></tr><tr><td></td><td>frequency</td><td>n. 经常 频率</td></tr><tr><td></td><td>consequently</td><td>因此（so， hence，thus， therefore， as a result），结果是</td></tr><tr><td></td><td></td><td>consequent 因此的</td></tr><tr><td></td><td></td><td>consequence n . 结果（result）后果      as a consequence因此</td></tr><tr><td>economically</td><td>ad. 经济地 节俭地 节约地</td><td></td></tr><tr><td></td><td>economic</td><td>a . 经济的  经济学的</td></tr><tr><td></td><td>economy</td><td>n. 经济 节俭 节约</td></tr><tr><td></td><td>economics</td><td>n . 经济学</td></tr><tr><td></td><td>economist</td><td>n. 经济学家</td></tr><tr><td></td><td>economical</td><td>a. 经济的 节俭的</td></tr><tr><td>successively</td><td>连续地</td><td></td></tr><tr><td></td><td>successful</td><td>成功的</td></tr><tr><td></td><td>successfully</td><td>成功地</td></tr><tr><td></td><td>successive</td><td>连续的</td></tr><tr><td>sensible</td><td></td><td></td></tr><tr><td></td><td>sensitive</td><td></td></tr><tr><td>considerate</td><td>a. 考虑周到的（thoughtful） 体贴的</td><td></td></tr><tr><td></td><td>considerable</td><td>a. 值得考虑的 相当多的 相当大的</td></tr><tr><td>optimistic</td><td>a. 乐观的</td><td>optimism 乐观主义<br>optimist 乐观主义者</td></tr><tr><td>pessimistic</td><td>a. 悲观的</td><td>…</td></tr><tr><td></td><td>socialism 社会主义<br>socialist 社会主义者<br>capitalism 资本主义<br>capitalist资本家<br>capital首要的重大的<br>communism 共产主义<br>communist共产主义者<br>common 共同<br>CCP 中国共产党 China communist Party</td><td></td></tr><tr><td>industry</td><td>n. 工业 行业 勤奋 勉励</td><td></td></tr><tr><td></td><td>industrious</td><td>a. 勤奋的 勉励的=hardworking</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>spoil</td><td>v . 溺爱 宠坏；毁坏 破坏（warm）</td><td>green house effect 温室效应<br>Low- carbon life 低碳生活</td></tr><tr><td>underestimate</td><td>v 低估</td><td></td></tr><tr><td></td><td>estimate</td><td>v. n. 估计</td></tr><tr><td></td><td>overestimate</td><td>高估</td></tr><tr><td></td><td>value</td><td>n 价值 价值观<br>v 估值 估价 珍惜 重视<br>life value生活价值观</td></tr><tr><td></td><td>undervalue</td><td>v 低估</td></tr><tr><td></td><td>rate</td><td>n.率 速度 价格 费用 等级<br>jobless rate 失业率<br>at the rate/speed of 以…的速度<br>the first class / rate第一等<br>v 评估 评分 评级 评价<br>overrate 高估<br>underrate 低估</td></tr><tr><td>distribute</td><td>分配 分发 分散 分销</td><td>tribe 部落<br>tribute  贡品 进贡 颂扬 歌功颂德<br>distribution<br><br>attribute …to…将。。。归功于/归因于。。<br>contribute 动。贡献 投稿<br>contribution<br>cooperation名词 合作<br>coworker名词 同事 合伙人</td></tr><tr><td>divide</td><td>v 分开 除</td><td></td></tr><tr><td>divorce</td><td>v n 离婚</td><td></td></tr><tr><td>exhibition</td><td>名词 展览</td><td></td></tr><tr><td></td><td>exhibit 动词 展览 展示</td><td></td></tr><tr><td>collect</td><td>动词收集</td><td></td></tr><tr><td></td><td>collection 名词手机 集合<br>collective 形容 收集的 集体的 共同的<br>collectivism 集体主义<br>individual 个人的 名词 个人个体<br>individualism 个人主义<br>material 物质的 名词 物质 材料<br>materialism 物质主义 唯物主义<br>ideal 理想的 完美的<br>ideal wife理想妻子<br>idealism 理想主义 完美主义 唯心主义<br>maoism毛泽东思想<br>Taoism道家思想<br>the policy of reform and opening up 改革开放政策<br>reform  = revolution 改革<br>revolutionary革命的<br>cause名词 原因 理由 事业 动词 引起造成<br>revolutionary cause革命事业<br>education cause 教育事业</td><td></td></tr><tr><td>except</td><td>除了。。。<br>exception 名词 例外<br>exceptional 例外的 杰出的 弱智的 异常的<br>exceptional children 特殊儿童（智障）<br>disabled children 残疾儿童<br>Negro黑鬼</td><td></td></tr><tr><td>option</td><td>名词 选择 选项<br> opt 名词选择<br>optional可选的 可选择的<br>optional courses选修课<br>compulsory 强制的 必须的  义务的<br>compulsory education 义务教育<br>compulsory courses 必修课</td><td></td></tr><tr><td>expense</td><td>名词 花费 费用<br>expensive 昂贵的<br>excessive 过分的 过多的<br>excess 名词 过多 过分 过多<br>形容词 过多的 过量的 过分的<br>expose 动词暴露曝光<br><br>expose…to…将。。。曝光给…<br>pose名词姿势 动词摆放（put）<br>compose 动词组成 构成 作文 作曲 作图<br>impose <br>impose…on…将什么施加于/强加于。。。<br>do  not impose your ideas on me!</td><td></td></tr><tr><td>amazing</td><td>惊讶的（好的一面）</td><td></td></tr><tr><td>launch</td><td>动词 发动 发起 发射<br>launch a campaign 发起战役</td><td></td></tr><tr><td>neglect</td><td>动词 忽视（ignore）</td><td></td></tr><tr><td>overlook</td><td>动词 俯视 俯瞰 忽视 忽略</td><td></td></tr><tr><td>normal</td><td>正常的 标准的 师范的<br>norm 名词 标准 规范 准则<br>abnormal 不正常的 表态的</td><td></td></tr><tr><td>abuse</td><td>动词 滥用 虐待</td><td></td></tr><tr><td>abandon</td><td>动词 放弃=give up<br>quit 动词 放弃 辞职</td><td></td></tr><tr><td>assign</td><td>动词 分配（任务）<br><br>assignment 作业 任务<br>sign名词 标记标志 征兆 迹象 动词 签名<br>resign <br>resign from this job/company从这个工作/公司辞职</td><td></td></tr><tr><td>treasure</td><td>名词 财宝  财富 动词 珍惜 重视=value</td><td></td></tr><tr><td>dramatic</td><td>形容词 戏剧性的  剧烈的 急剧的<br>drama 名词 戏剧<br>dramatically 戏剧性地 急剧地  剧烈地<br>fierce 激烈的 <br>sharp 锋利的 急剧地 剧烈地<br>sharply 副词<br></td><td></td></tr><tr><td>maintain</td><td>动词维修 维持 声称认为<br>somebody maintains that。。。<br>sustain 动词 维持 持续<br>sustainable 可维持的 可持续的<br>sustainable development 可持续发展<br></td><td></td></tr><tr><td>persist</td><td>彻底的<br><br>persistent坚持的  坚持不懈的<br>persistence 名词 坚持 坚持不懈<br><br>nothing in this world can take the place of persistence<br>persist in doing something <br>insist in doing something 内心的愿望</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>range</td><td>范围 幅度 山脉<br>a range of 一系列的<br>动词 range from … to …范围从…到 …</td><td></td></tr><tr><td>rover</td><td>漫步者</td><td></td></tr><tr><td>rank</td><td>动词名词 排名 排列</td><td></td></tr><tr><td>resolve</td><td>动词 解决 决定 下决心<br>resolve this problem <br>resolution 解决方案 决定 决心 决议<br>settle 动词 定居 解决 <br>settle this problem</td><td></td></tr><tr><td></td><td>solve 解决 溶解<br>solution 解决方案 溶液</td><td></td></tr><tr><td>refine</td><td>动词 提炼 精炼<br>refinement 名词 提炼 精炼<br>government 名词 政府<br>govern 动词 管理 统治 支配<br>governor 统治者 总督 州长 省长</td><td></td></tr><tr><td>step名词 步伐 步子</td><td></td><td></td></tr><tr><td></td><td>oversstep 动词 逾越</td><td></td></tr><tr><td>additional</td><td>额外的 增加的<br>add 动词 增加  补充说<br>addition 增加 额外<br>in addition 此外<br>in addition to  + 名词  除了…之外</td><td></td></tr><tr><td>psychological</td><td>心里的  心理学的<br>psychology 心理学</td><td></td></tr><tr><td>affect</td><td>动词  影响 打动 感动<br>affection 名词 影响  爱情 柔情 <br>affectionate 形容词 柔情似水的  含情脉脉的<br>effect 名词 影响 效果 动词做出来 完成 实现<br>have an effect on = affect<br>effective 有影响的  有效果的<br>take effective measures to do somethinig <br>perfect 完美的<br>imperfect <br>infect 动词 感染 传染 <br>infection 名词 传染  感染<br>infectious 感染的 传染的</td><td></td></tr><tr><td>assimilate</td><td>动词 同化 <br>similar 相似</td><td></td></tr><tr><td>accompany</td><td>动词 陪伴<br>company 公司 伙伴</td><td></td></tr><tr><td>cultivate</td><td>动词 栽培 培养<br>cultivate the spirit of innovation 培养创新精神<br>cultivate the sense of cooperation 培养合作意识<br>cultivate the optimistic spirit <br>动词 栽培 培养<br>cultivate the spirit of innovation 培养创新精神<br>cultivate the sense of cooperation 培养合作意识<br>cultivate the spirit of optimism</td><td></td></tr><tr><td>innovation</td><td>创新<br>novel 小说 新颖的 新奇的<br>innovate 动词  创新<br>innovative 形容词 创新的 创新性的</td><td></td></tr><tr><td>translate</td><td>动词 翻译（笔译）； 转变 转化<br><br>translation<br>interpret 动词  翻译（口译）解释说明<br>interpretation</td><td></td></tr><tr><td>affiliate</td><td>动词 隶属于 附属于 名词 分公司 附属机构</td><td></td></tr><tr><td>circle</td><td>名词 圆圈  圈子<br>the circle of friends 朋友圈<br>circulate 动词 循环 流通<br>circulation</td><td></td></tr><tr><td>enthusiastic</td><td>热情的 热心的<br>enthusiasm 热情  热心</td><td></td></tr><tr><td>identify</td><td>动词 确定 辨别<br><br>identity 名词 身份      ID card 身份证</td><td></td></tr><tr><td>notify</td><td>通知 告知<br>note 注意 知道 笔记 告知</td><td></td></tr><tr><td>quality</td><td>名词  质量  品质<br>qualify 使有资格<br>qualification 名词 资格 品质<br>certificate 名词 证书  文凭</td><td></td></tr><tr><td>penalty</td><td>punishment 名词 惩罚//<br>penalize = punish 动词 惩罚</td><td></td></tr><tr><td>rewarding</td><td>有回报的<br>reward 名词 汇报</td><td></td></tr><tr><td>simplifying</td><td>simple 简单的 <br>simplify 动词 简化</td><td></td></tr><tr><td>suspend</td><td>动词 暂停 中止 吊销<br>suspending<br></td><td></td></tr><tr><td></td><td>overwhelming 压倒性的  不知所措的<br>overwhelm 动词 压倒 使不知所措<br>overwhelmed 不知所措的  被压倒的</td><td></td></tr><tr><td>appealing</td><td>有吸引力的<br>appeal to 吸引 呼吁 上诉</td><td></td></tr><tr><td>soar</td><td>动词 飞涨<br>soaring <br>rocket 火箭 动词 剧增 猛涨 飞涨</td><td></td></tr><tr><td>apply</td><td><br><br>apply to应用于 适用于 <br>apply for 申请<br><br>application 申请 应用  适用<br>supply 供应</td><td></td></tr><tr><td>equivalent</td><td>equ+value 等价的  名词 等价物 等同物<br>equal 相等的</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>shift</td><td>动词 名词 转换 换挡</td><td></td></tr><tr><td>amount</td><td>名词 总量 数量<br>amount to 总量达… 等同于…</td><td></td></tr><tr><td>character</td><td>性格 特点 特征<br>characteristic 有特色的 有特征的 有特点的</td><td></td></tr><tr><td>fresh</td><td>新鲜的  有活力的<br>refresh 动词  使重新焕发活力<br>refreshed 焕发活力的</td><td></td></tr><tr><td><strong>vital</strong></td><td>有活力的 有生命力的 生死攸关的  至关重要的  （important significant）</td><td></td></tr><tr><td>essential</td><td>本质的 精华的  至关重要的  必不可少的 <br>essence 名词 精华 本质</td><td></td></tr><tr><td>tiny</td><td>微小的</td><td></td></tr><tr><td>casual</td><td>放松的 休闲的  随意的<br>casual wear 休闲装</td><td></td></tr><tr><td>total</td><td>总的  名词 总数  总值</td><td></td></tr><tr><td>vulnerable</td><td>脆弱的 易受伤害的 <br>be ~ to …  易受 。。。上海的<br>vulnerability 脆弱性  易受伤害性 弱点</td><td></td></tr><tr><td>avoidable</td><td>可避免的<br>avoid 避免<br>unavoidable 不可避免的</td><td></td></tr><tr><td>intention</td><td>名词  打算 意图  目的<br>intend 动词 打算 企图<br><br>intend to  do something 打算做某事<br><br><br>tend to ,,,趋向于 往往会<br></td><td></td></tr><tr><td>detection</td><td>名词  侦察 侦测<br>detect 侦察 侦探<br>detector 名词 探测器<br>detective 侦探</td><td></td></tr><tr><td>tension</td><td>紧张<br>tense 紧张的</td><td></td></tr><tr><td>documented</td><td>有记录的<br>document 文件 文献 文献记录</td><td></td></tr><tr><td>determined</td><td>决定的  下决心的  坚定的<br>determine 决心 决定  坚定</td><td></td></tr><tr><td>shared</td><td>共享的 共同的<br>share 共享 分享</td><td></td></tr><tr><td>train</td><td>名词 火车 串 动词  培训 训练<br>a train of 一串<br>trained 被培训的 被训练的</td><td></td></tr><tr><td>accustomed</td><td>习惯的<br>accustom  动词 使其习惯</td><td></td></tr><tr><td>specialized</td><td>专门的  专业化的<br>special 特殊的  专业的 专门的<br>specialist 专家 专业人员<br>specialize 使 专门  使专门化  使  专业化</td><td></td></tr><tr><td>maximum</td><td>最大值<br>minimum 最小值</td><td></td></tr><tr><td>principal</td><td>校长 负责人  主要的  首要的<br>principle 原则 <br>in principle在原则上</td><td></td></tr><tr><td>provoke</td><td>动词 挑衅 激怒 激发 激起<br>evoke动词 呼唤 唤起<br>provoking 发人深思的 =  thought<br>far-reaching 形容词 影响深远的 意义深远的</td><td></td></tr><tr><td>basis</td><td>基础<br>base。。。on… 使。。。基于。。。<br>be based on 基于<br></td><td></td></tr><tr><td>monitor</td><td>班长 监视器 显示器 动词 检测 监视</td><td></td></tr><tr><td>symbol</td><td>象征<br>symbolize动词 使象征 象征 = represent<br>represent动词代表=stand for</td><td></td></tr><tr><td>art</td><td>艺术<br>artist 跟上 赶上 =catch up with    = keep up with   =  keep pace with  = follow</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>prevalent</td><td>流行的  普遍的 普及的<br>popular <br>popularize 使流行 使普及</td><td></td></tr><tr><td>component</td><td>组成成分 构成成分  形容词 组成的 构成的</td><td></td></tr><tr><td>consistent</td><td>连续的 连贯的  一致的</td><td></td></tr><tr><td>object</td><td>物理 目标  动词 反对=oppose（oppose to doing something反对做某事）<br><br>objection 反对<br>objective 客观的  名词  目标 <br>reject 拒绝</td><td></td></tr><tr><td>approaching</td><td><br>approach 动词 接近 靠近  处理  探讨（问题）名词 方法  途径</td><td></td></tr><tr><td>underlying</td><td>underline 下划线 动词 在…之下划线 强调 重视<br>underlie 动词 位于…之下  构成….的基础<br>underlying 在下面的 潜在的<br>underlying trend潜在的趋势</td><td></td></tr><tr><td>visualizing</td><td>visualize 动词 设想 想象<br>visual  视觉的<br><br>visual effect视觉效果 <br>vision 名词事业 景象 风景 远见<br>visible 可看得见的 可视 的  明显的<br>invisible</td><td></td></tr><tr><td>surrounding</td><td>环绕的  围绕的 环绕 围绕<br>round <br>surround 动词 环绕 围绕 <br>surroundings 周围的环境</td><td></td></tr><tr><td><strong>attach</strong></td><td>动词 粘贴 衣服<br>touch 触摸<br>detach v. 脱离 分离<br>detach from…与。。。相分离</td><td></td></tr><tr><td><strong>contact</strong></td><td>动词 接触 联系</td><td></td></tr><tr><td><strong>contend</strong></td><td>动词 竞争 争论 声称<br>tend to 趋向于 往往会</td><td></td></tr><tr><td><strong>contract</strong></td><td>v . 收缩 缩短 签合同  订契约  n . 合同 契约</td><td></td></tr><tr><td>conduct</td><td>指挥 带领 引领 进行  n . 行为 运行<br>duct-引导<br>introduce 介绍  引入 引进<br>introduction 介绍 引导<br>conductor n . 指挥家 乘务员 导体</td><td></td></tr><tr><td>contest</td><td>v. + n . 测试 检测 测验  比赛</td><td></td></tr><tr><td>continuous</td><td>连续的  继续的<br>continue</td><td></td></tr><tr><td>endurance</td><td><br>endure v . 使持续  使忍受</td><td></td></tr><tr><td>foster</td><td>v . 养育 培养 <br>cultivate v . 栽培 培养<br>foster the spirit innovation 配演创新精神</td><td></td></tr><tr><td>improve</td><td>v. 改善 改进 提高<br>improvement n . <br>with the improving of living standard of people,more and more people can afford travelling abroad</td><td></td></tr><tr><td>intrinsic</td><td>a . 本质的<br>intrinsically ad . 本质地  本质上地</td><td></td></tr><tr><td>relatively</td><td><br>relate v.联系 叙述 讲述<br>relation n . 联系 关系 叙述 讲述<br>relationship n . 关系<br>relative a. 相联系的 相关的 相对的<br>relatively ad . 相关地 相对地 相互联系地<br>absolutely 绝对地 完全地</td><td></td></tr><tr><td>similarly</td><td>ad . 相似地</td><td></td></tr><tr><td>virtually</td><td></td><td></td></tr><tr><td></td><td>previously ad. 以前地<br>prensently ad . 现在地 目前地<br>laterly 后来<br>later后来</td><td></td></tr><tr><td>increasingly</td><td>越来越…+形容词 increasingly small 越来越小</td><td></td></tr><tr><td>patiently</td><td><br>patient病人 耐心的</td><td></td></tr><tr><td>briefly</td><td>ad . 简洁地 简要地</td><td></td></tr><tr><td>experience</td><td>v . 经历  n . 经验</td><td></td></tr><tr><td>explore</td><td>探索</td><td></td></tr><tr><td>graduate v . 毕业<br>graduate from … 从 …毕业<br>violate v . 违反 违背<br>violation n . 违反 违背<br>violent a. 暴力的<br>violence n . 暴力<br></td><td>operate v . 操作 做手术<br>operation n . 操作 <br>cooperation n . 合作<br></td><td></td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>promote   v . 推动 促进 推销 促销 晋升 升职<br>remote control 遥控<br>motion n . 移动 运动<br>promotion n .</td><td></td><td></td></tr><tr><td>worsen v . 使糟糕 恶化<br>worse  a . 糟糕的<br></td><td></td><td></td></tr><tr><td>widen v . 加宽 扩宽</td><td></td><td></td></tr><tr><td>weaken v . 弱化 削弱 <br>strengthen v . 强化<br>strong a . 强壮的<br>strength n . 强壮 力量 强势</td><td></td><td></td></tr><tr><td>circumstance 处境<br>under no circumstances 在任何情况下都不（放在句首要倒装）<br><strong>under no circumstances should we pollute the environment</strong> <br><strong>under no circumstances will I give up loving you</strong></td><td></td><td></td></tr><tr><td>cover v . 封面 覆该 支付 报道（an event）<br>recover v .  恢复 复苏  = revive v . 复活 复苏</td><td></td><td></td></tr><tr><td><strong>rare</strong> a . 稀少的 稀有的 <br>rare bird 稀有的鸟 与众不同地人 特立独行的人<br>rarely ad. 稀有的  稀少地 几乎不=hardly</td><td></td><td></td></tr><tr><td>realistic a . 现实的 真实的 <br>reality n . 现实</td><td></td><td></td></tr><tr><td>site n . 地点 点<br>website n . 网站 站点</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;decline 下降 衰退 拒接绝&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;refuse fuse-流，往回流，婉拒[一般程度]&lt;br&gt;        reject 拒绝[严重程度] ject-扔 往回扔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; derive form 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>191017-JAVA-IO流(3)-其他流</title>
    <link href="https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO%E6%B5%81-3-%E5%85%B6%E4%BB%96%E6%B5%81/"/>
    <id>https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/</id>
    <published>2019-11-17T07:44:02.000Z</published>
    <updated>2019-11-17T09:10:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/01_%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="lozad"></p><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的<strong>缓冲区数组</strong>，通过缓冲区读写，<strong>减少系统IO次数</strong>，从而提高读写的效率。</p><h2 id="1-字节缓冲流"><a href="#1-字节缓冲流" class="headerlink" title="1 - 字节缓冲流"></a>1 - 字节缓冲流</h2><h3 id="1-1-字节缓冲输出流"><a href="#1-1-字节缓冲输出流" class="headerlink" title="1.1 - 字节缓冲输出流"></a>1.1 - 字节缓冲输出流</h3><p>java.io.BufferedOutputStream extends OutputStream<br>    BufferedOutputStream:字节缓冲输出流</p><pre><code>继承自父类的共性成员方法:    - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。    - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。    - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。    - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。    - public abstract void write(int b) ：将指定的字节输出流。</code></pre><h4 id="1-1-1-构造方法"><a href="#1-1-1-构造方法" class="headerlink" title="1.1.1 - 构造方法"></a>1.1.1 - 构造方法</h4><ul><li>BufferedOutputStream(OutputStream out)  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。<br>BufferedOutputStream(OutputStream out, int size)  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</li><li>参数:<pre><code>OutputStream out:字节输出流     我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率int size:指定缓冲流内部缓冲区的大小,不指定默认</code></pre></li></ul><h4 id="1-1-2-使用步骤-重点"><a href="#1-1-2-使用步骤-重点" class="headerlink" title="1.1.2 - 使用步骤(重点)"></a>1.1.2 - 使用步骤(重点)</h4><p>​        1.创建FileOutputStream对象,构造方法中绑定要输出的目的地<br>​        2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率<br>​        3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中<br>​        4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中(不做此步骤，数据无法成功写入)<br>​        5.释放资源(会先调用flush方法刷新数据,第4部可以省略)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建FileOutputStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">//3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中</span></span><br><span class="line">        bos.write(<span class="string">"我把数据写入到内部缓冲区中"</span>.getBytes());</span><br><span class="line">        <span class="comment">//4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        bos.flush();</span><br><span class="line">        <span class="comment">//5.释放资源(会先调用flush方法刷新数据,第4部可以省略)</span></span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-字节缓冲输入流"><a href="#1-2-字节缓冲输入流" class="headerlink" title="1.2 - 字节缓冲输入流"></a>1.2 - 字节缓冲输入流</h3><p>java.io.BufferedInputStream extends InputStream<br>    BufferedInputStream:字节缓冲输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承自父类的成员方法:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>从输入流中读取数据的下一个字节。</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此输入流并释放与该流关联的所有系统资源。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-1-构造方法"><a href="#1-2-1-构造方法" class="headerlink" title="1.2.1 - 构造方法"></a>1.2.1 - 构造方法</h4><p>​    BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。<br>​    BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。<br>​    参数:<br>​        InputStream in:字节输入流<br>​            我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率<br>​        int size:指定缓冲流内部缓冲区的大小,不指定默认</p><h4 id="1-2-2-使用步骤-重点"><a href="#1-2-2-使用步骤-重点" class="headerlink" title="1.2.2 - 使用步骤(重点)"></a>1.2.2 - 使用步骤(重点)</h4><p>​    1.创建FileInputStream对象,构造方法中绑定要读取的数据源<br>​    2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率<br>​    3.使用BufferedInputStream对象中的方法read,读取文件<br>​    4.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建FileInputStream对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="comment">//3.使用BufferedInputStream对象中的方法read,读取文件</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//int read()从输入流中读取数据的下一个字节。</span></span><br><span class="line">        <span class="comment">/*int len = 0;//记录每次读取到的字节</span></span><br><span class="line"><span class="comment">        while((len = bis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//存储每次读取的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//记录每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-文件复制"><a href="#1-3-文件复制" class="headerlink" title="1.3 - 文件复制"></a>1.3 - 文件复制</h3><p>与之前的IO流一样的步骤，这次加入下效率测试，从结果可见，缓存流的读写速度比普通IO流快很多。</p><p><strong>普通IO流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件复制练习:一读一写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源: c:\\1.jpg</span></span><br><span class="line"><span class="comment">        数据的目的地: d:\\1.jpg</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件复制的步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line"><span class="comment">        2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line"><span class="comment">        3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line"><span class="comment">        4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line"><span class="comment">        5.释放资源</span></span><br><span class="line"><span class="comment">    文件的大小:780,831 字节</span></span><br><span class="line"><span class="comment">    一次读写一个字节:6043毫秒</span></span><br><span class="line"><span class="comment">    使用数组缓冲读取多个字节,写入多个字节:10毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line"><span class="comment">            fos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件复制练习:一读一写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源: c:\\1.jpg</span></span><br><span class="line"><span class="comment">        数据的目的地: d:\\1.jpg</span></span><br><span class="line"><span class="comment">    文件复制的步骤:</span></span><br><span class="line"><span class="comment">        1.创建字节缓冲输入流对象,构造方法中传递字节输入流</span></span><br><span class="line"><span class="comment">        2.创建字节缓冲输出流对象,构造方法中传递字节输出流</span></span><br><span class="line"><span class="comment">        3.使用字节缓冲输入流对象中的方法read,读取文件</span></span><br><span class="line"><span class="comment">        4.使用字节缓冲输出流中的方法write,把读取的数据写入到内部缓冲区中</span></span><br><span class="line"><span class="comment">        5.释放资源(会先把缓冲区中的数据,刷新到文件中)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件的大小:780,831 字节</span></span><br><span class="line"><span class="comment">    一次读写一个字节:32毫秒</span></span><br><span class="line"><span class="comment">    使用数组缓冲读取多个字节,写入多个字节:5毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建字节缓冲输入流对象,构造方法中传递字节输入流</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//2.创建字节缓冲输出流对象,构造方法中传递字节输出流</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//3.使用字节缓冲输入流对象中的方法read,读取文件</span></span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = bis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            bos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-字符缓冲流"><a href="#2-字符缓冲流" class="headerlink" title="2 - 字符缓冲流"></a>2 - 字符缓冲流</h2><h3 id="2-1-字符缓冲输出流"><a href="#2-1-字符缓冲输出流" class="headerlink" title="2.1 - 字符缓冲输出流"></a>2.1 - 字符缓冲输出流</h3><p>java.io.BufferedWriter extends Writer<br>    BufferedWriter:字符缓冲输出流</p><p>继承自父类的共性成员方法:<br>    - void write(int c) 写入单个字符。<br>    - void write(char[] cbuf)写入字符数组。<br>    - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>    - void write(String str)写入字符串。<br>    - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>    - void flush()刷新该流的缓冲。<br>    - void close() 关闭此流，但要先刷新它。</p><h4 id="2-1-1-构造方法"><a href="#2-1-1-构造方法" class="headerlink" title="2.1.1 - 构造方法:"></a>2.1.1 - 构造方法:</h4><p>​    BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。<br>​    BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。<br>​    参数:<br>​        Writer out:字符输出流<br>​            我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率<br>​        int sz:指定缓冲区的大小,不写默认大小</p><h4 id="2-1-2-特有的成员方法"><a href="#2-1-2-特有的成员方法" class="headerlink" title="2.1.2 - 特有的成员方法"></a>2.1.2 - 特有的成员方法</h4><p>​    void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符<br>​    换行:换行符号<br>​    windows:\r\n<br>​    linux:/n<br>​    mac:/r</p><h4 id="2-1-3-使用步骤"><a href="#2-1-3-使用步骤" class="headerlink" title="2.1.3 -  使用步骤"></a>2.1.3 -  使用步骤</h4><p>​    1.创建字符缓冲输出流对象,构造方法中传递字符输出流<br>​    2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中<br>​    3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中<br>​    4.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">        <span class="comment">//1.创建字符缓冲输出流对象,构造方法中传递字符输出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"10_IO\\c.txt"</span>));</span><br><span class="line">        <span class="comment">//2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">"传智播客"</span>);</span><br><span class="line">            <span class="comment">//bw.write("\r\n");</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        bw.flush();</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-字符缓冲输入流"><a href="#2-2-字符缓冲输入流" class="headerlink" title="2.2 - 字符缓冲输入流"></a>2.2 - 字符缓冲输入流</h3><p>java.io.BufferedReader extends Reader<br>    BufferedReader:字符缓冲输入流</p><p>继承自父类的共性成员方法:<br>    int read() 读取单个字符并返回。<br>    int read(char[] cbuf)一次读取多个字符,将字符读入数组。<br>    void close() 关闭该流并释放与之关联的所有资源。</p><h4 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1 -  构造方法:"></a>2.2.1 -  构造方法:</h4><p>​    BufferedReader(Reader in)  创建一个使用默认大小输入缓冲区的缓冲字符输入流。<br>​    BufferedReader(Reader in, int sz)     创建一个使用指定大小输入缓冲区的缓冲字符输入流。<br>​    参数:<br>​        Reader in:字符输入流<br>​            我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率</p><h4 id="2-2-2-特有的成员方法"><a href="#2-2-2-特有的成员方法" class="headerlink" title="2.2.2 - 特有的成员方法"></a>2.2.2 - 特有的成员方法</h4><p>​    String readLine() 读取一个文本行。读取一行数据<br>​        行的终止符号:通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行(\r\n)。<br>​    返回值:<br>​        包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p><h4 id="2-2-3-使用步骤"><a href="#2-2-3-使用步骤" class="headerlink" title="2.2.3 - 使用步骤"></a>2.2.3 - 使用步骤</h4><p>​    1.创建字符缓冲输入流对象,构造方法中传递字符输入流<br>​    2.使用字符缓冲输入流对象中的方法read/readLine读取文本<br>​    3.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流对象,构造方法中传递字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"10_IO\\c.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用字符缓冲输入流对象中的方法read/readLine读取文本</span></span><br><span class="line">        <span class="comment">/*String line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            发下以上读取是一个重复的过程,所以可以使用循环优化</span></span><br><span class="line"><span class="comment">            不知道文件中有多少行数据,所以使用while循环</span></span><br><span class="line"><span class="comment">            while的结束条件,读取到null结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-练习：文本排序"><a href="#2-3-练习：文本排序" class="headerlink" title="2.3 - 练习：文本排序"></a>2.3 - 练习：文本排序</h3><p>练习:</p><p>​        将in.txt的文本内容排序后写入到out.txt</p><p>​        对文本的内容进行排序<br>​        按照(1,2,3….)顺序排序<br>​    分析:<br>​        1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本<br>​        2.创建字符缓冲输入流对象,构造方法中绑定字符输入流<br>​        3.创建字符缓冲输出流对象,构造方法中绑定字符输出流<br>​        4.使用字符缓冲输入流中的方法readline,逐行读取文本<br>​        5.对读取到的文本进行切割,获取行中的序号和文本内容<br>​        6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)<br>​        7.遍历HashMap集合,获取每一个键值对<br>​        8.把每一个键值对,拼接为一个文本行<br>​        9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中<br>​        10.释放资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建字符缓冲输入流对象,构造方法中绑定字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"10_IO\\in.txt"</span>));</span><br><span class="line">        <span class="comment">//3.创建字符缓冲输出流对象,构造方法中绑定字符输出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"10_IO\\out.txt"</span>));</span><br><span class="line">        <span class="comment">//4.使用字符缓冲输入流中的方法readline,逐行读取文本</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//5.对读取到的文本进行切割,获取行中的序号和文本内容</span></span><br><span class="line">            String[] arr = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">//6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)</span></span><br><span class="line">            map.put(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历HashMap集合,获取每一个键值对</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            <span class="comment">//8.把每一个键值对,拼接为一个文本行</span></span><br><span class="line">            line = key + <span class="string">"."</span> + value;</span><br><span class="line">            <span class="comment">//9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中</span></span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();<span class="comment">//写换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//10.释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>#转换流</p><h2 id="1-字符编码和字符集"><a href="#1-字符编码和字符集" class="headerlink" title="1 - 字符编码和字符集"></a>1 - 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img alt data-src="img/1_charset.jpg" class="lozad"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/1_charset.jpg" class="lozad"></p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h3 id="编码问题（乱码）"><a href="#编码问题（乱码）" class="headerlink" title="编码问题（乱码）"></a>编码问题（乱码）</h3><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    FileReader可以读取IDE默认编码格式(UTF-8)的文件</span></span><br><span class="line"><span class="comment">    FileReader读取系统默认编码(中文GBK)会产生乱码���</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"10_IO\\我是GBK格式的文本.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/02_%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="lozad"></p><h2 id="2-InputStreamReader类"><a href="#2-InputStreamReader类" class="headerlink" title="2 - InputStreamReader类"></a>2 - InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><p>java.io.InputStreamReader extends Reader<br>    InputStreamReader:是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码:把看不懂的变成能看懂的)</p><p>继承自父类的共性成员方法:<br>    int read() 读取单个字符并返回。<br>    int read(char[] cbuf)一次读取多个字符,将字符读入数组。<br>    void close() 关闭该流并释放与之关联的所有资源。</p><h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 - 构造方法"></a>2.1 - 构造方法</h3><p>​    InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。<br>​    InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。<br>​    参数:<br>​        InputStream in:字节输入流,用来读取文件中保存的字节<br>​        String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8</p><h3 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 - 使用步骤"></a>2.2 - 使用步骤</h3><p>​    1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称<br>​    2.使用InputStreamReader对象中的方法read读取文件<br>​    3.释放资源<br> <strong>注意事项:</strong>    构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用InputStreamReader读取GBK格式的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\gbk.txt"),"UTF-8");//???</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\gbk.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//你好</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用InputStreamReader读取UTF-8格式的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\utf_8.txt"),"UTF-8");</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\utf_8.txt"</span>));<span class="comment">//不指定默认使用UTF-8</span></span><br><span class="line">        <span class="comment">//2.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><h2 id="3-OutputStreamWriter类"><a href="#3-OutputStreamWriter类" class="headerlink" title="3 - OutputStreamWriter类"></a>3 - OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><p>java.io.OutputStreamWriter extends Writer<br>    OutputStreamWriter: 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码:把能看懂的变成看不懂)</p><p>继续自父类的共性成员方法:<br>    - void write(int c) 写入单个字符。<br>    - void write(char[] cbuf)写入字符数组。<br>    - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>    - void write(String str)写入字符串。<br>    - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>    - void flush()刷新该流的缓冲。</p><ul><li>void close() 关闭此流，但要先刷新它。</li></ul><h3 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 - 构造方法"></a>3.1 - 构造方法</h3><p>​    OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。<br>​    OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。<br>​    参数:<br>          OutputStream out:字节输出流,可以用来写转换之后的字节到文件中<br>          String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8</p><h3 id="3-2-使用步骤"><a href="#3-2-使用步骤" class="headerlink" title="3.2 - 使用步骤"></a>3.2 - 使用步骤</h3><p>​    1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称<br>​    2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)<br>​    3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)<br>​    4.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用转换流OutputStreamWriter写GBK格式的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span></span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\gbk.txt"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="comment">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用转换流OutputStreamWriter写UTF-8格式的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span></span><br><span class="line">    <span class="comment">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\utf_8.txt"),"utf-8");</span></span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\utf_8.txt"</span>));<span class="comment">//不指定默认使用UTF-8</span></span><br><span class="line">    <span class="comment">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="comment">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-练习-：转换文件编码"><a href="#4-练习-：转换文件编码" class="headerlink" title="4 - 练习 ：转换文件编码"></a>4 - 练习 ：转换文件编码</h2><p> 练习：转换文件编码<br>        将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><pre><code>分析:    1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK    2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8    3.使用InputStreamReader对象中的方法read读取文件    4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中    5.释放资源    </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\我是GBK格式的文本.txt"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">//2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\我是utf_8格式的文件.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">//3.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中</span></span><br><span class="line">            osw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 - 概述"></a>1 - 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/3_xuliehua.jpg" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/03_%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%A6%82%E8%BF%B0.bmp" class="lozad"></p><h2 id="2-ObjectOutputStream类"><a href="#2-ObjectOutputStream类" class="headerlink" title="2 - ObjectOutputStream类"></a>2 - ObjectOutputStream类</h2><p>java.io.ObjectOutputStream extends OutputStream<br>    ObjectOutputStream:对象的序列化流<br>    作用:把对象以流的方式写入到文件中保存</p><h3 id="2-1-构造方法-1"><a href="#2-1-构造方法-1" class="headerlink" title="2.1 - 构造方法"></a>2.1 - 构造方法</h3><p>​    ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。<br>​    参数:<br>​        OutputStream out:字节输出流</p><h3 id="2-2-特有的成员方法"><a href="#2-2-特有的成员方法" class="headerlink" title="2.2 - 特有的成员方法"></a>2.2 - 特有的成员方法</h3><p>​    void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。</p><h3 id="2-3-使用步骤"><a href="#2-3-使用步骤" class="headerlink" title="2.3 - 使用步骤"></a>2.3 - 使用步骤</h3><p>​    1.创建ObjectOutputStream对象,构造方法中传递字节输出流<br>​    2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中<br>​    3.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04.ObjectStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常</span></span><br><span class="line"><span class="comment">    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。</span></span><br><span class="line"><span class="comment">    Serializable接口也叫标记型接口</span></span><br><span class="line"><span class="comment">        要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记</span></span><br><span class="line"><span class="comment">        当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记</span></span><br><span class="line"><span class="comment">            有:就可以序列化和反序列化</span></span><br><span class="line"><span class="comment">            没有:就会抛出 NotSerializableException异常</span></span><br><span class="line"><span class="comment">    去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    static关键字:静态关键字</span></span><br><span class="line"><span class="comment">        静态优先于非静态加载到内存中(静态优先于对象进入到内存中)</span></span><br><span class="line"><span class="comment">        被static修饰的成员变量不能被序列化的,序列化的都是对象</span></span><br><span class="line"><span class="comment">        private static int age;</span></span><br><span class="line"><span class="comment">        oos.writeObject(new Person("小美女",18));</span></span><br><span class="line"><span class="comment">        Object o = ois.readObject();</span></span><br><span class="line"><span class="comment">        Person&#123;name='小美女', age=0&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    transient关键字:瞬态关键字</span></span><br><span class="line"><span class="comment">        被transient修饰成员变量,不能被序列化</span></span><br><span class="line"><span class="comment">        private transient int age;</span></span><br><span class="line"><span class="comment">        oos.writeObject(new Person("小美女",18));</span></span><br><span class="line"><span class="comment">        Object o = ois.readObject();</span></span><br><span class="line"><span class="comment">        Person&#123;name='小美女', age=0&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//private static int age;</span></span><br><span class="line">    <span class="comment">//private transient int age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1.创建ObjectOutputStream对象,构造方法中传递字节输出流</span></span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\person.txt"</span>));</span><br><span class="line">       <span class="comment">//2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中</span></span><br><span class="line">       oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"小美女"</span>,<span class="number">18</span>));</span><br><span class="line">       <span class="comment">//3.释放资源</span></span><br><span class="line">       oos.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-ObjectInputStream类"><a href="#3-ObjectInputStream类" class="headerlink" title="3 - ObjectInputStream类"></a>3 - ObjectInputStream类</h2><p>java.io.ObjectInputStream extends InputStream<br>ObjectInputStream:对象的反序列化流<br>作用:把文件中保存的对象,以流的方式读取出来使用</p><h3 id="3-1-构造方法-1"><a href="#3-1-构造方法-1" class="headerlink" title="3.1 - 构造方法"></a>3.1 - 构造方法</h3><p>​    ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。<br>​    参数:<br>​        InputStream in:字节输入流</p><h3 id="3-2-特有的成员方法"><a href="#3-2-特有的成员方法" class="headerlink" title="3.2 - 特有的成员方法"></a>3.2 - 特有的成员方法</h3><p>​    Object readObject() 从 ObjectInputStream 读取对象。</p><h3 id="3-3-使用步骤"><a href="#3-3-使用步骤" class="headerlink" title="3.3 - 使用步骤"></a>3.3 - 使用步骤</h3><p>​    1.创建ObjectInputStream对象,构造方法中传递字节输入流<br>​    2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件<br>​    3.释放资源<br>​    4.使用读取出来的对象(打印)</p><p> readObject方法声明抛出了ClassNotFoundException(class文件找不到异常)<br> 当不存在对象的class文件时抛出此异常<br> 反序列化的前提:<br>    1.类必须实现Serializable<br>    2.必须存在类对应的class文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ObjectInputStream对象,构造方法中传递字节输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\person.txt"</span>));</span><br><span class="line">        <span class="comment">//2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="comment">//4.使用读取出来的对象(打印)</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        Person p = (Person)o;</span><br><span class="line">        System.out.println(p.getName()+p.getAge());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-练习：序列化集合"><a href="#4-练习：序列化集合" class="headerlink" title="4 - 练习：序列化集合"></a>4 - 练习：序列化集合</h2><pre><code>    当我们想在文件中保存多个对象的时候    可以把多个对象存储到一个集合中    对集合进序列化和反序列化分析:    1.定义一个存储Person对象的ArrayList集合    2.往ArrayList集合中存储Person对象    3.创建一个序列化流ObjectOutputStream对象    4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化    5.创建一个反序列化ObjectInputStream对象    6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合    7.把Object类型的集合转换为ArrayList类型    8.遍历ArrayList集合    9.释放资源</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义一个存储Person对象的ArrayList集合</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.往ArrayList集合中存储Person对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="comment">//3.创建一个序列化流ObjectOutputStream对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\list.txt"</span>));</span><br><span class="line">        <span class="comment">//4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//5.创建一个反序列化ObjectInputStream对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\list.txt"</span>));</span><br><span class="line">        <span class="comment">//6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//7.把Object类型的集合转换为ArrayList类型</span></span><br><span class="line">        ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o;</span><br><span class="line">        <span class="comment">//8.遍历ArrayList集合</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : list2) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p>java.io.PrintStream:打印流<br>        PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。<br>    PrintStream特点:<br>        1.只负责数据的输出,不负责数据的读取<br>        2.与其他输出流不同，PrintStream 永远不会抛出 IOException<br>        3.有特有的方法,print,println<br>            void print(任意类型的值)<br>            void println(任意类型的值并换行)<br>    ## 1 - 构造方法:</p><p>​        PrintStream(File file):输出的目的地是一个文件<br>​        PrintStream(OutputStream out):输出的目的地是一个字节输出流<br>​        PrintStream(String fileName) :输出的目的地是一个文件路径<br>​    PrintStream extends OutputStream<br>​    继承自父类的成员方法:</p><pre><code>- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。- public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。- public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。- public abstract void write(int b) ：将指定的字节输出流。注意:​        如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a​        如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">//System.out.println("HelloWorld");</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建打印流PrintStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">       PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"10_IO\\print.txt"</span>);</span><br><span class="line">       <span class="comment">//如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a</span></span><br><span class="line">       ps.write(<span class="number">97</span>);</span><br><span class="line">       <span class="comment">//如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</span></span><br><span class="line">       ps.println(<span class="number">97</span>);</span><br><span class="line">       ps.println(<span class="number">8.8</span>);</span><br><span class="line">       ps.println(<span class="string">'a'</span>);</span><br><span class="line">       ps.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">       ps.println(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//释放资源</span></span><br><span class="line">       ps.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以改变输出语句的目的地(打印流的流向)<br>    输出语句,默认在控制台输出<br>    使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地<br>        static void setOut(PrintStream out)<br>          重新分配“标准”输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"我是在控制台输出"</span>);</span><br><span class="line"></span><br><span class="line">       PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"10_IO\\目的地是打印流.txt"</span>);</span><br><span class="line">       System.setOut(ps);<span class="comment">//把输出语句的目的地改变为打印流的目的地</span></span><br><span class="line">       System.out.println(<span class="string">"我在打印流的目的地中输出"</span>);</span><br><span class="line"></span><br><span class="line">       ps.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://cometorbityh.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cometorbityh.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://cometorbityh.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>191016_JAVA_IO流(2)_IO流</title>
    <link href="https://cometorbityh.github.io/2019/11/16/191016-JAVA-IO%E6%B5%81-2-IO%E6%B5%81/"/>
    <id>https://cometorbityh.github.io/2019/11/16/191016-JAVA-IO流-2-IO流/</id>
    <published>2019-11-16T13:28:49.000Z</published>
    <updated>2019-11-17T16:04:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/IO%E6%B5%81.png" class="lozad"></p><h2 id="1、字节输出流（内存-—-gt-硬盘）"><a href="#1、字节输出流（内存-—-gt-硬盘）" class="headerlink" title="1、字节输出流（内存 —&gt; 硬盘）"></a>1、字节输出流（内存 —&gt; 硬盘）</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191116155749.png" class="lozad"></p><h3 id="1-1、OutputStream"><a href="#1-1、OutputStream" class="headerlink" title="1.1、OutputStream"></a>1.1、OutputStream</h3><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><h3 id="1-2、FileOutputStream"><a href="#1-2、FileOutputStream" class="headerlink" title="1.2、FileOutputStream"></a>1.2、FileOutputStream</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称（文件路径）写入文件。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><p><strong>写入数据的原理(内存–&gt;硬盘)</strong><br>        java程序–&gt;JVM(java虚拟机)–&gt;OS(操作系统)–&gt;OS调用写数据的方法–&gt;把数据写入到文件中</p><p><strong>字节输出流的使用步骤(重点):</strong></p><pre><code>1.传递路径：创建一个FileOutputStream对象,构造方法中传递写入数据的目的地2.写入数据：调用FileOutputStream对象中的方法write,把数据写入到文件中3.释放资源：(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 传递路径</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\IO\\a.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据(单个字节)</span></span><br><span class="line">        <span class="comment">//fos.write(97);//a (97---&gt;1100001---&gt;a，查询ASCII表)</span></span><br><span class="line">        <span class="comment">//写入数据(多个字节)</span></span><br><span class="line">        <span class="comment">//byte[] bytes = &#123;65,66,67,68,69&#125;;      //ABCDE</span></span><br><span class="line">        <span class="comment">//byte[] bytes = &#123;-65,-66,-67,68,69&#125;;   //烤紻E</span></span><br><span class="line">        <span class="comment">//fos.write(bytes);</span></span><br><span class="line">        <span class="comment">//fos.write(bytes,1,2);//BC</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串转为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes2 = <span class="string">"你好"</span>.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(bytes2));<span class="comment">//[-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        fos.write(bytes2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2、续写-换行"><a href="#1-2-2、续写-换行" class="headerlink" title="1.2.2、续写/ 换行"></a>1.2.2、续写/ 换行</h4><p>上述代码虽然成功写入了数据，但是每次重新运行都会清空数据重新创建文件，那么如何做到不清空数据，并且每次写入时换行？</p><p>我们需要用到FIleOUtputStrem类的2个参数的构造方法，它可以做到<strong>追加写/ 续写</strong><br>       <code>FileOutputStream(String name, boolean append)</code>创建一个向具有指定 name 的文件中写入数据的输出文件流。<br>       <code>FileOutputStream(File file, boolean append)</code>创建一个向指定 File 对象表示的文件中写入数据的文件输出流。<br>        参数:<br>           String name,File file:写入数据的目的地<br>           boolean append:追加写开关<br>            true:创建对象不会覆盖源文件,继续在文件的末尾追加写数据<br>            false:创建一个新文件,覆盖源文件<br>    写换行:写换行符号<br>        windows:\r\n<br>        linux:/n</p><p>​         mac:/r</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 传递路径（追加写）</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\IO\\a.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据(多个字节)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            fos.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());   <span class="comment">//换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191116163150.png" class="lozad"></p><h2 id="2、字节输入流（硬盘-—-gt-内存）"><a href="#2、字节输入流（硬盘-—-gt-内存）" class="headerlink" title="2、字节输入流（硬盘 —&gt; 内存）"></a>2、字节输入流（硬盘 —&gt; 内存）</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191116163514.png" class="lozad"></p><h3 id="2-1、InputStream"><a href="#2-1、InputStream" class="headerlink" title="2.1、InputStream"></a>2.1、InputStream</h3><p>int read()从输入流中读取数据的下一个字节。<br>int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。<br>void close() 关闭此输入流并释放与该流关联的所有系统资源。</p><h3 id="2-2、FileInputStream"><a href="#2-2、FileInputStream" class="headerlink" title="2.2、FileInputStream"></a>2.2、FileInputStream</h3><h4 id="2-2-1、构造方法"><a href="#2-2-1、构造方法" class="headerlink" title="2.2.1、构造方法"></a>2.2.1、构造方法</h4><p>FileInputStream(String name)<br>        FileInputStream(File file)<br>        参数:读取文件的数据源<br>            String name:文件的路径<br>            File file:文件<br>        构造方法的作用:<br>            1.会创建一个FileInputStream对象<br>            2.会把FileInputStream对象指定构造方法中要读取的文件</p><pre><code>读取数据的原理(硬盘--&gt;内存)    java程序--&gt;JVM--&gt;OS--&gt;OS读取数据的方法--&gt;读取文件字节输入流的使用步骤(重点):    1.创建FileInputStream对象,构造方法中绑定要读取的数据源    2.使用FileInputStream对象中的方法read,读取文件    3.释放资源</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 传递路径（追加写）</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\IO\\a.txt"</span>); <span class="comment">//(a.txt保存的数据为 "abc")</span></span><br><span class="line">    <span class="comment">//读取数据(单个字节)</span></span><br><span class="line">    <span class="comment">/*int content = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(content);      //97</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        content = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(content);      //98</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        content = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(content);      //99</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        content = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(content);      //-1 (读完)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据(循环读取，读到-1时结束)</span></span><br><span class="line">    <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.print(len);  //979899</span></span><br><span class="line"><span class="comment">            System.out.print((char)len);    //abc</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据（多个字节，byte数组）</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//存储读取到的多个字节</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//记录每次读取的有效字节个数</span></span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把整个byte数组转换成字符串，本例中除了 abc 其余都是空格，造成资源浪费</span></span><br><span class="line">        <span class="comment">//System.out.println(new String(bytes));</span></span><br><span class="line">        <span class="comment">//String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、案例：文件复制"><a href="#3、案例：文件复制" class="headerlink" title="3、案例：文件复制"></a>3、案例：文件复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(常用方法)</span><br><span class="line">   A --&gt;|获取| A1[Decision]</span><br><span class="line">   A --&gt;|判断| A2[Result one]</span><br><span class="line">   A --&gt;|创建+删除| A3[Result two]</span><br><span class="line">   A1 --&gt; a11[&quot;public String getAbsolutePath()&quot;]</span><br><span class="line">   A1 --&gt; a12[Decision]</span><br><span class="line">   A1 --&gt; a13[Decision]</span><br></pre></td></tr></table></figure><p>文件复制练习:一读一写</p><pre><code>明确:    数据源: c:\\1.jpg    数据的目的地: d:\\1.jpg文件复制的步骤:    1.创建一个字节输入流对象,构造方法中绑定要读取的数据源    2.创建一个字节输出流对象,构造方法中绑定要写入的目的地    3.使用字节输入流对象中的方法read读取文件    4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中    5.释放资源</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line"><span class="comment">            fos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、字符输入流"><a href="#3、字符输入流" class="headerlink" title="3、字符输入流"></a>3、字符输入流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用字节流读取中文文件</span></span><br><span class="line"><span class="comment">    1个中文</span></span><br><span class="line"><span class="comment">        GBK:占用两个字节</span></span><br><span class="line"><span class="comment">        UTF-8:占用3个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"09_IOAndProperties\\c.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1、Reader"><a href="#3-1、Reader" class="headerlink" title="3.1、Reader"></a>3.1、Reader</h3><p>java.io.Reader:字符输入流,是字符输入流的最顶层的父类,是一个抽象类，定义了一些共性的成员方法,</p><p>共性的成员方法:<br>   <code>int read()</code> 读取单个字符并返回。<br>   <code>int read(char[] cbuf)</code>一次读取多个字符,将字符读入数组。<br>   <code>void close()</code> 关闭该流并释放与之关联的所有资源。</p><h3 id="3-2、FileReader"><a href="#3-2、FileReader" class="headerlink" title="3.2、FileReader"></a>3.2、FileReader</h3><p>java.io.FileReader extends InputStreamReader extends Reader<br>FileReader:文件字符输入流<br>作用:把硬盘文件中的数据以字符的方式读取到内存中</p><p><strong>构造方法:</strong><br>    FileReader(String fileName)<br>    FileReader(File file)<br>    参数:读取文件的数据源<br>        String fileName:文件的路径<br>        File file:一个文件<br>    FileReader构造方法的作用:<br>        1.创建一个FileReader对象<br>        2.会把FileReader对象指向要读取的文件<br><strong>字符输入流的使用步骤:</strong><br>    1.创建FileReader对象,构造方法中绑定要读取的数据源<br>    2.使用FileReader对象中的方法read读取文件<br>    3.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建FileReader对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"09_IOAndProperties\\c.txt"</span>);</span><br><span class="line">    <span class="comment">//2.使用FileReader对象中的方法read读取文件</span></span><br><span class="line">    <span class="comment">//int read() 读取单个字符并返回。</span></span><br><span class="line">    <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fr.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.print((char)len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int read(char[] cbuf)一次读取多个字符,将字符读入数组。</span></span><br><span class="line">    <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//该数组用来存储读取到的多个字符</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//记录的是每次读取的有效字符个数</span></span><br><span class="line">    <span class="keyword">while</span>((len = fr.read(cs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                String类的构造方法</span></span><br><span class="line"><span class="comment">                String(char[] value) 把字符数组转换为字符串</span></span><br><span class="line"><span class="comment">                String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(cs,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.释放资源</span></span><br><span class="line">    fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、字符输出流"><a href="#4、字符输出流" class="headerlink" title="4、字符输出流"></a>4、字符输出流</h2><h3 id="4-1、Writer"><a href="#4-1、Writer" class="headerlink" title="4.1、Writer"></a>4.1、Writer</h3><p>java.io.Writer:字符输出流,是所有字符输出流的最顶层的父类,是一个抽象类</p><p><strong>共性的成员方法:</strong><br>    - void write(int c) 写入单个字符。<br>    - void write(char[] cbuf)写入字符数组。<br>    - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>    - void write(String str)写入字符串。<br>    - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>    - void flush()刷新该流的缓冲。<br>    - void close() 关闭此流，但要先刷新它。</p><h3 id="4-2、FileWriter"><a href="#4-2、FileWriter" class="headerlink" title="4.2、FileWriter"></a>4.2、FileWriter</h3><p>java.io.FileWriter extends OutputStreamWriter extends Writer<br>FileWriter:文件字符输出流<br>作用:把内存中字符数据写入到文件中</p><p><strong>构造方法:</strong><br>    FileWriter(File file)根据给定的 File 对象构造一个 FileWriter 对象。<br>    FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。<br>    参数:写入数据的目的地<br>        String fileName:文件的路径<br>        File file:是一个文件<br>    构造方法的作用:<br>        1.会创建一个FileWriter对象<br>        2.会根据构造方法中传递的文件/文件的路径,创建文件<br>        3.会把FileWriter对象指向创建好的文件</p><p><strong>字符输出流的使用步骤(重点):</strong><br>    1.创建FileWriter对象,构造方法中绑定要写入数据的目的地<br>    2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程，因为计算机是按照字节存储的)<br>    3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中<br>    4.释放资源(会先把内存缓冲区中的数据刷新到文件中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建FileWriter对象,构造方法中绑定要写入数据的目的地</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\d.txt"</span>);</span><br><span class="line">    <span class="comment">//2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)</span></span><br><span class="line">    <span class="comment">//void write(int c) 写入单个字符。</span></span><br><span class="line">    fw.write(<span class="number">97</span>);</span><br><span class="line">    <span class="comment">//3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">    <span class="comment">//fw.flush();</span></span><br><span class="line">    <span class="comment">//4.释放资源(会先把内存缓冲区中的数据刷新到文件中)</span></span><br><span class="line">    fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flush方法和close方法的区别<br>        - flush ：刷新缓冲区，流对象可以继续使用。<br>        - close:  先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建FileWriter对象,构造方法中绑定要写入数据的目的地</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\e.txt"</span>);</span><br><span class="line">    <span class="comment">//2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)</span></span><br><span class="line">    <span class="comment">//void write(int c) 写入单个字符。</span></span><br><span class="line">    fw.write(<span class="number">97</span>);</span><br><span class="line">    <span class="comment">//3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">    fw.flush();</span><br><span class="line">    <span class="comment">//刷新之后流可以继续使用</span></span><br><span class="line">    fw.write(<span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.释放资源(会先把内存缓冲区中的数据刷新到文件中)</span></span><br><span class="line">    fw.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//close方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了</span></span><br><span class="line">    fw.write(<span class="number">99</span>);<span class="comment">//IOException: Stream closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\f.txt"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] cs = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">    <span class="comment">//void write(char[] cbuf)写入字符数组。</span></span><br><span class="line">    fw.write(cs);<span class="comment">//abcde</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</span></span><br><span class="line">    fw.write(cs,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//bcd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void write(String str)写入字符串。</span></span><br><span class="line">    fw.write(<span class="string">"传智播客"</span>);<span class="comment">//传智播客</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</span></span><br><span class="line">    fw.write(<span class="string">"黑马程序员"</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//程序员</span></span><br><span class="line"></span><br><span class="line">    fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>续写和换行</strong><br>    续写,追加写:使用两个参数的构造方法<br>        FileWriter(String fileName, boolean append)<br>        FileWriter(File file, boolean append)<br>        参数:<br>            String fileName,File file:写入数据的目的地<br>            boolean append:续写开关 true:不会创建新的文件覆盖源文件,可以续写; false:创建新的文件覆盖源文件<br>     换行:换行符号<br>        windows:\r\n<br>        linux:/n<br>        mac:/r</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Writer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\g.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            fw.write(<span class="string">"HelloWorld"</span>+i+<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO流的异常处理"><a href="#IO流的异常处理" class="headerlink" title="IO流的异常处理"></a>IO流的异常处理</h1><h2 id="1、JDK7前-try…catch…finally"><a href="#1、JDK7前-try…catch…finally" class="headerlink" title="1、JDK7前 try…catch…finally"></a>1、JDK7前 try…catch…finally</h2><p>在jdk1.7之前使用try catch finally 处理流中的异常<br>    格式:<br>        try{<br>            可能会产出异常的代码<br>        }catch(异常类变量 变量名){<br>            异常的处理逻辑<br>        }finally{<br>            一定会指定的代码<br>            资源释放<br>        }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提高变量fw的作用域,让finally可以使用</span></span><br><span class="line">        <span class="comment">//变量在定义的时候,可以没有值,但是使用的时候必须有值</span></span><br><span class="line">        <span class="comment">//fw = new FileWriter("09_IOAndProperties\\g.txt",true); 执行失败,fw没有值,fw.close会报错</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//可能会产出异常的代码</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"w:\\09_IOAndProperties\\g.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                fw.write(<span class="string">"HelloWorld"</span>+i+<span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="comment">//异常的处理逻辑</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定会指定的代码</span></span><br><span class="line">            <span class="comment">//创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放</span></span><br><span class="line">            <span class="keyword">if</span>(fw!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch</span></span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2、JDK7新特性"><a href="#2、JDK7新特性" class="headerlink" title="2、JDK7新特性"></a>2、JDK7新特性</h2><p>在try的后边可以增加一个(),在括号中可以定义流对象<br>    那么这个流对象的作用域就在try中有效<br>    try中的代码执行完毕,会自动把流对象释放,不用写finally<br>    格式:<br>        try(定义流对象;定义流对象….){<br>            可能会产出异常的代码<br>        }catch(异常类变量 变量名){<br>            异常的处理逻辑<br>        }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="comment">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可能会产出异常的代码</span></span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">            fos.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">//异常的处理逻辑</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、JDK9新特性"><a href="#3、JDK9新特性" class="headerlink" title="3、JDK9新特性"></a>3、JDK9新特性</h2><p>JDK9新特性<br>    try的前边可以定义流对象<br>    在try后边的()中可以直接引入流对象的名称(变量名)<br>    在try代码执行完毕之后,流对象也可以释放掉,不用写finally<br>    格式:<br>        A a = new A();<br>        B b = new B();<br>        try(a,b){<br>            可能会产出异常的代码<br>        }catch(异常类变量 变量名){<br>            异常的处理逻辑<br>        }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">    <span class="comment">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(fis;fos)&#123;</span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">            fos.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fos.write(1);//此时会报异常，Stream Closed流已关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Properties集合介绍"><a href="#Properties集合介绍" class="headerlink" title="Properties集合介绍"></a>Properties集合介绍</h1><p>java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;<br>    Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。<br>    Properties集合是一个唯一和IO流相结合的集合<br>        可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储<br>        可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用</p><p>属性列表中每个键及其对应值都是一个字符串。<br>    Properties集合是一个双列集合,key和value默认都是字符串</p><h2 id="1、Properties基本使用"><a href="#1、Properties基本使用" class="headerlink" title="1、Properties基本使用"></a>1、Properties基本使用</h2><p><strong>使用Properties集合存储数据,遍历取出Properties集合中的数据</strong><br>    Properties集合是一个双列集合,key和value默认都是字符串<br>    Properties集合有一些操作字符串的特有方法<br>        Object setProperty(String key, String value) 调用 Hashtable 的方法 put。<br>        String getProperty(String key) 通过key找到value值,此方法相当于Map集合中的get(key)方法<br>        Set<string> stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串,此方法相当于Map集合中的keySet方法</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Properties集合对象</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//使用setProperty往集合中添加数据</span></span><br><span class="line">    prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line">    <span class="comment">//prop.put(1,true);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用stringPropertyNames把Properties集合中的键取出,存储到一个Set集合中</span></span><br><span class="line">    Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历Set集合,取出Properties集合的每一个键</span></span><br><span class="line">    <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">        <span class="comment">//使用getProperty方法通过key获取value</span></span><br><span class="line">        String value = prop.getProperty(key);</span><br><span class="line">        System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2、store()——Properties数据存储到硬盘</p><p>可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储<br>void store(OutputStream out, String comments)<br>void store(Writer writer, String comments)<br>参数:<br>    OutputStream out:字节输出流,不能写入中文<br>    Writer writer:字符输出流,可以写中文<br>    String comments:注释,用来解释说明保存的文件是做什么用的<br>            不能使用中文,会产生乱码,默认是Unicode编码<br>            一般使用””空字符串</p><p>使用步骤:<br>    1.创建Properties集合对象,添加数据<br>    2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地<br>    3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储<br>    4.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建Properties集合对象,添加数据</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">    <span class="comment">//FileWriter fw = new FileWriter("09_IOAndProperties\\prop.txt");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line">    <span class="comment">//prop.store(fw,"save data");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    <span class="comment">//fw.close();</span></span><br><span class="line"></span><br><span class="line">    prop.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"09_IOAndProperties\\prop2.txt"</span>),<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、load-——Properties读取硬盘数据（⭐）"><a href="#3、load-——Properties读取硬盘数据（⭐）" class="headerlink" title="3、load()——Properties读取硬盘数据（⭐）"></a>3、load()——Properties读取硬盘数据（⭐）</h2><p>可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用<br>    void load(InputStream inStream)<br>    void load(Reader reader)<br>    参数:<br>        InputStream inStream:字节输入流,不能读取含有中文的键值对<br>        Reader reader:字符输入流,能读取含有中文的键值对<br>    使用步骤:<br>        1.创建Properties集合对象<br>        2.使用Properties集合对象中的方法load读取保存键值对的文件<br>        3.遍历Properties集合<br>    注意:<br>        1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)<br>        2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取<br>        3.存储键值对的文件中,键与值默认都是字符串,不用再加引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建Properties集合对象</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//2.使用Properties集合对象中的方法load读取保存键值对的文件</span></span><br><span class="line">    prop.load(<span class="keyword">new</span> FileReader(<span class="string">"09_IOAndProperties\\prop.txt"</span>));</span><br><span class="line">    <span class="comment">//prop.load(new FileInputStream("09_IOAndProperties\\prop.txt"));</span></span><br><span class="line">    <span class="comment">//3.遍历Properties集合</span></span><br><span class="line">    Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">        String value = prop.getProperty(key);</span><br><span class="line">        System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO流&quot;&gt;&lt;a href=&quot;#IO流&quot; class=&quot;headerlink&quot; title=&quot;IO流&quot;&gt;&lt;/a&gt;IO流&lt;/h1&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://yanghanblog.oss-cn-hangzhou.aliyuncs.co
      
    
    </summary>
    
      <category term="Java" scheme="https://cometorbityh.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cometorbityh.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://cometorbityh.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>191013_JAVA_IO流(1)_File类</title>
    <link href="https://cometorbityh.github.io/2019/11/13/191013_JAVA_IO%E6%B5%81(1)_File%E7%B1%BB/"/>
    <id>https://cometorbityh.github.io/2019/11/13/191013_JAVA_IO流(1)_File类/</id>
    <published>2019-11-13T07:18:02.000Z</published>
    <updated>2019-11-17T09:11:10.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1、基本描述"><a href="#1、基本描述" class="headerlink" title="1、基本描述"></a>1、基本描述</h2><p>操作对象：文件和文件夹</p><p>概述：<code>java.io.File</code> 类是文件和目录路径名的抽象表示形式，主要用于文件和目录的创建、查找和删除等操作。<br>    java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作<br>    我们可以使用File类的方法<br>        创建一个文件/文件夹<br>        删除文件/文件夹<br>        获取文件/文件夹<br>        判断文件/文件夹是否存在<br>        对文件夹进行遍历<br>        获取文件的大小<br>    File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法</p><pre><code>重点:记住这三个单词    file:文件    directory:文件夹/目录    path:路径</code></pre><h2 id="2、-复习-路径的写法"><a href="#2、-复习-路径的写法" class="headerlink" title="2、[复习]路径的写法"></a>2、[复习]路径的写法</h2><h3 id="2-1、路径"><a href="#2-1、路径" class="headerlink" title="2.1、路径"></a>2.1、路径</h3><p>路径可以是以文件结尾,也可以是以文件夹结尾<br>路径可以是相对路径,也可以是绝对路径<br>路径可以是存在,也可以是不存在<br>创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况</p><h3 id="2-2、路径的分类"><a href="#2-2、路径的分类" class="headerlink" title="2.2、路径的分类"></a>2.2、路径的分类</h3><ul><li>绝对路径:是一个完整的路径<pre><code>    以盘符(c:,D:)开始的路径        c:\\a.txt        C:\\Users\itcast\\IdeaProjects\\shungyuan\\123.txt        D:\\demo\\b.txt相对路径:是一个简化的路径    相对指的是相对于当前项目的根目录(C:\\Users\itcast\\IdeaProjects\\shungyuan)    如果使用当前项目的根目录,路径可以简化书写    C:\\Users\itcast\\IdeaProjects\\shungyuan\\123.txt--&gt;简化为: 123.txt(可以省略项目的根目录)注意:    1.路径是不区分大小写    2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠</code></pre></li></ul><h2 id="3、静态成员变量及常用方法"><a href="#3、静态成员变量及常用方法" class="headerlink" title="3、静态成员变量及常用方法"></a>3、静态成员变量及常用方法</h2><h3 id="3-1、静态成员变量"><a href="#3-1、静态成员变量" class="headerlink" title="3.1、静态成员变量"></a>3.1、静态成员变量</h3><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>static String pathSeparator</td><td>路径分隔符（1个字符串）：Windows为分号，Linux为冒号</td></tr><tr><td>static char pathSeparatorChar</td><td>路径分隔符（字符）：与上述功能一致</td></tr><tr><td>static String separator</td><td>默认名称分隔符（1个字符串）：Windows为反斜杠，Linux为正斜杠</td></tr><tr><td>static char separatorChar</td><td>默认名称分隔符（字符）：与上述功能一致</td></tr></tbody></table><h3 id="3-2、构造方法"><a href="#3-2、构造方法" class="headerlink" title="3.2、构造方法"></a>3.2、构造方法</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>public File(String pathname）</td><td>通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例</td></tr><tr><td>public File(String parent, String child)</td><td>从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例</td></tr><tr><td>public File(File parent, String child)</td><td>从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例</td></tr></tbody></table><h3 id="3-3、常用方法"><a href="#3-3、常用方法" class="headerlink" title="3.3、常用方法"></a>3.3、常用方法</h3><h4 id="3-3-1、获取功能的方法"><a href="#3-3-1、获取功能的方法" class="headerlink" title="3.3.1、获取功能的方法"></a>3.3.1、获取功能的方法</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>public String getAbsolutePath()</code></td><td>返回此File的绝对路径名字符串</td></tr><tr><td><code>public String getPath()</code></td><td>将此File转换为路径名字符串</td></tr><tr><td><code>public String getName()</code></td><td>返回由此File表示的文件或目录的名称</td></tr><tr><td><code>public long length()</code></td><td>返回由此File表示的文件的长度（单位：字节）</td></tr></tbody></table><h4 id="3-3-2、判断功能的方法"><a href="#3-3-2、判断功能的方法" class="headerlink" title="3.3.2、判断功能的方法"></a>3.3.2、判断功能的方法</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>public boolean exists()</code></td><td>此File表示的文件或目录是否实际存在</td></tr><tr><td><code>public boolean isDirectory()</code></td><td>判断构造方法中给定的路径是否以文件夹结尾</td></tr><tr><td><code>public boolean isFile()</code></td><td>判断构造方法中给定的路径是否以文件结尾</td></tr></tbody></table><p>注意：isDirectory()和isFile()的使用前提：路径存在，否则都会返回false</p><p>硬盘中只有文件夹和文件，因此 isDirectory()和isFile() 是互斥的</p><h4 id="3-3-3、创建-删除功能的方法"><a href="#3-3-3、创建-删除功能的方法" class="headerlink" title="3.3.3、创建 + 删除功能的方法"></a>3.3.3、创建 + 删除功能的方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public boolean mkdir()</code></td><td>true：文件夹不存在，创建单级空文件夹<br>false：文件夹已存在 / 构造方法路径不存在</td></tr><tr><td><code>public boolean mkdirs()</code></td><td>true：文件夹不存在，创建单级空文件夹 / 多级空文件夹 <br>false：文件夹已存在，或构造方法路径不存在</td></tr><tr><td><code>public boolean createNewFile</code></td><td>true：文件不存在，在file对象提供的路径<strong>创建一个空文件</strong>；false：文件存在；<br>file对象的路径必须存在，若不存在会抛出异常<code>IOException</code></td></tr><tr><td><code>public boolean delete()</code></td><td>删除FIle对象对应的文件夹/ 文件（直接删除硬盘的，不走回收站）<br>true：删除成功<br>false：删除失败 / 构造方法路径不存在</td></tr></tbody></table><h4 id="3-3-4、遍历目录功能的方法"><a href="#3-3-4、遍历目录功能的方法" class="headerlink" title="3.3.4、遍历目录功能的方法"></a>3.3.4、遍历目录功能的方法</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>public String[] list()</code></td><td>遍历File对象给出的<strong>目录</strong>中的所有文件和文件夹的<strong>名称</strong>，将其保存在String数组中</td></tr><tr><td><code>public List[] listFiles()</code></td><td>遍历File对象给出的<strong>目录</strong>中的所有文件和文件夹的<strong>全路径</strong>，将其保存在List数组中</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.xs.LSInputList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//demo01();</span></span><br><span class="line">        <span class="comment">//demo02();</span></span><br><span class="line">        <span class="comment">//demo03();</span></span><br><span class="line">        <span class="comment">//demo04();</span></span><br><span class="line">        <span class="comment">//demo05();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 文件路径名</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\IO"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\IO\\demo1.txt"</span>);</span><br><span class="line">        System.out.println(f1);     <span class="comment">// C:\IO</span></span><br><span class="line">        System.out.println(f2);     <span class="comment">// C:\IO\demo1.txt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"C:\\IO"</span>, <span class="string">"demo2.txt"</span>);</span><br><span class="line">        System.out.println(f3);     <span class="comment">// C:\IO\demo2.txt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(f1, <span class="string">"demo3.txt"</span>);</span><br><span class="line">        System.out.println(f4);     <span class="comment">// C:\IO\demo3.tx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取功能的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\Administrator.RG4-44\\Desktop\\demo01\\demo01.iml"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"demo01.iml"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取file对象的绝对路径字符串（相对/绝对都转为绝对）</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());   <span class="comment">//C:\Users\Administrator.RG4-44\Desktop\demo01\demo01.iml</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());   <span class="comment">//C:\Users\Administrator.RG4-44\Desktop\demo01\demo01.iml</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取file对象的路径字符串（路径保持原样）</span></span><br><span class="line">        System.out.println(f1.getPath());   <span class="comment">//C:\Users\Administrator.RG4-44\Desktop\demo01\demo01.iml</span></span><br><span class="line">        System.out.println(f2.getPath());   <span class="comment">//demo01.iml</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//File类的toString() == getPath()</span></span><br><span class="line">        System.out.println(f1.toString());  <span class="comment">//C:\Users\Administrator.RG4-44\Desktop\demo01\demo01.iml</span></span><br><span class="line">        System.out.println(f2.toString());  <span class="comment">//demo01.iml</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取File对象的路径的结尾部分</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\Administrator.RG4-44\\Desktop\\demo01"</span>);</span><br><span class="line">        System.out.println(f1.getName());   <span class="comment">//demo01.iml</span></span><br><span class="line">        System.out.println(f3.getName());   <span class="comment">//demo01</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取FIle对象指向的文件大小（单位字节，注意文件夹没有大小）</span></span><br><span class="line">        System.out.println(f1.length());    <span class="comment">//939</span></span><br><span class="line">        System.out.println(f3.length());    <span class="comment">//4096</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断功能的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"F:\\IO"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\aaa.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(f1.exists())&#123;</span><br><span class="line">            System.out.println(f1.isFile());        <span class="comment">//false</span></span><br><span class="line">            System.out.println(f1.isDirectory());   <span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若不存在，则没必要获取</span></span><br><span class="line">        <span class="keyword">if</span> (f2.exists())&#123;</span><br><span class="line">            System.out.println(f2.isFile());        <span class="comment">//true</span></span><br><span class="line">            System.out.println(f2.isDirectory());   <span class="comment">//false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 + 删除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo04</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建单级文件夹</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\test01"</span>);       <span class="comment">//文件夹名为 “test01.txt”</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\test02.txt"</span>);   <span class="comment">//文件夹名为 "test02"</span></span><br><span class="line">        System.out.println(f1.mkdir());     <span class="comment">//true</span></span><br><span class="line">        System.out.println(f2.mkdir());     <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建单级/多级文件夹</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\aaa"</span>);</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\bbb\\ccc.txt"</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());    <span class="comment">//true</span></span><br><span class="line">        System.out.println(f4.mkdirs());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        File f5 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\file01.txt"</span>);    <span class="comment">//文件名为 "file01.txt"</span></span><br><span class="line">        File f6 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\file02"</span>);        <span class="comment">//文件名为 "file02"</span></span><br><span class="line">        System.out.println(f5.createNewFile());    <span class="comment">//true</span></span><br><span class="line">        System.out.println(f6.createNewFile());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件/文件夹</span></span><br><span class="line">        File f7 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\aaa"</span>);</span><br><span class="line">        File f8 = <span class="keyword">new</span> File(<span class="string">"F:\\IO\\aaa.txt"</span>);</span><br><span class="line">        System.out.println(f7.delete());</span><br><span class="line">        System.out.println(f8.delete());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历目录功能的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo05</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历目录的文件和文件夹（包括隐藏文件/文件夹）</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"F:\\IO"</span>);</span><br><span class="line">        String[] list = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String fileName: list)&#123;</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            bbb</span></span><br><span class="line"><span class="comment">            file01.txt</span></span><br><span class="line"><span class="comment">            file02</span></span><br><span class="line"><span class="comment">            test01</span></span><br><span class="line"><span class="comment">            test02.txt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"F:\\IO"</span>);</span><br><span class="line">        File[] files = f2.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file:files)&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            F:\IO\bbb</span></span><br><span class="line"><span class="comment">            F:\IO\file01.txt</span></span><br><span class="line"><span class="comment">            F:\IO\file02</span></span><br><span class="line"><span class="comment">            F:\IO\test01</span></span><br><span class="line"><span class="comment">            F:\IO\test02.txt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;headerlink&quot; title=&quot;File类&quot;&gt;&lt;/a&gt;File类&lt;/h1&gt;&lt;h2 id=&quot;1、基本描述&quot;&gt;&lt;a href=&quot;#1、基本描述&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="Java" scheme="https://cometorbityh.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cometorbityh.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://cometorbityh.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>191111——JavaWeb之Session+Cookie</title>
    <link href="https://cometorbityh.github.io/2019/11/11/191111%E2%80%94%E2%80%94JavaWeb%E4%B9%8BSession-Cookie/"/>
    <id>https://cometorbityh.github.io/2019/11/11/191111——JavaWeb之Session-Cookie/</id>
    <published>2019-11-11T12:43:17.000Z</published>
    <updated>2019-11-13T07:14:12.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111214022.png" class="lozad"></p><ol><li>会话：一次会话中包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li></ul></li><li>功能：在一次会话的范围内的多次请求间，共享数据</li><li>方式：<ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>概念</p><ul><li>Cookie本意“小饼干”，是客户端会话技术，将数据保存在客户端。</li></ul><p>实现原理</p><ul><li>基于响应头set-cookie和请求头cookie实现</li></ul><p>Cookie的执行步骤：</p><table><thead><tr><th>步骤</th><th>方法</th></tr></thead><tbody><tr><td>1. 创建Cookie对象</td><td>Cookie cookie = new Cookie(String name, String value)</td></tr><tr><td>2. 发送Cookie</td><td>response.addCookie(Cookie cookie);</td></tr><tr><td>3. 获取Cookie,而后遍历Cookie</td><td>Cookie[] cookies = request.getCookies();</td></tr></tbody></table><p>分别访问2个Servlet，Servlet发送Cookie，Servlet2获取Cookie并遍历，前提是浏览器不能关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieDemo01"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Cookie对象</span></span><br><span class="line">        Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">"msg"</span>, <span class="string">"success"</span>);</span><br><span class="line">        Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">"code"</span>, <span class="string">"404"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发送Cookie</span></span><br><span class="line">        response.addCookie(cookie1);</span><br><span class="line">        response.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.young.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieDemo02"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieDemo02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//3.获取Cookie</span></span><br><span class="line"></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie:cookies)&#123;</span><br><span class="line">            String name = cookie.getName();</span><br><span class="line">            String value = cookie.getValue();</span><br><span class="line">            System.out.println(name + <span class="string">"---"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------控制台----------------</span><br><span class="line">msg---success</span><br><span class="line">code---<span class="number">404</span></span><br><span class="line">device---<span class="number">11</span></span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191112131129.png" class="lozad"></p><p>有关Cookie的问题</p><blockquote><p> <strong>一次可不可以发送多个cookie?</strong></p><ul><li>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li></ul><p><strong>cookie在浏览器中保存多长时间？</strong></p><p>​    默认情况下，当浏览器关闭后，Cookie数据被销毁</p><p>​    实现持久化存储：在发送Cookie前加入方法<code>setMaxAge(int seconds)</code>即可。second的取值为：</p><ul><li><p>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p></li><li><p>负数：默认值</p></li><li><p>零：删除cookie信息 </p><p><strong>cookie能不能存中文？</strong></p></li></ul><p>​    在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3)</p><p>​    在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p><p><strong>cookie共享问题</strong></p><p>同Tomcat服务器的多个web项目：</p><ul><li><p>默认情况下cookie不能共享</p></li><li><p>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，则可以将path设置为<strong>“/“</strong></p></li></ul><p>不同Tomcat服务器的多个web项目：</p><ul><li>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</li><li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></blockquote><p>Cookie的特点和作用<br>     1. cookie存储数据在客户端浏览器，因此<strong>不安全</strong><br>     2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</p><pre><code>* 作用：    1. cookie一般用于存出少量的不太敏感的数据    2. 在不登录的情况下，完成服务器对客户端的身份识别</code></pre><h2 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h2><pre><code>1. 概念：    * Java Server Pages： java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象：    * 在jsp页面中不需要获取和创建，可以直接使用的对象    * jsp一共有9个内置对象。    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似            * response.getWriter()和out.write()的区别：                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter()数据输出永远在out.write()之前5. 案例:改造Cookie案例</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol><li><p>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p></li><li><p>快速入门：</p><ol><li>获取HttpSession对象：<br> HttpSession session = request.getSession();</li><li>使用HttpSession对象：<br> 获取数据：Object getAttribute(String name)<br> 存储数据：void setAttribute(String name, Object value)<br> 移除数据：void removeAttribute(String name)  </li></ol></li><li><p>原理</p><ul><li><p><strong>Session的实现是依赖于Cookie的。</strong></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191113144224.png" class="lozad"></p></li></ul></li><li><p>细节：</p><ol><li><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</p><ul><li><p>默认情况下。不是。</p></li><li><p>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。<br> Cookie c = new Cookie(“JSESSIONID”,session.getId());<br>   c.setMaxAge(60*60);<br> response.addCookie(c);</p></li><li><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191113150745.png" class="lozad"></p></li></ul></li></ol></li></ol><ol start="2"><li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p><ul><li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul><li>session的钝化（序列化）：<ul><li>在服务器正常关闭之前，将session对象序列化到硬盘上</li></ul></li><li>session的活化（反序列化）：<ul><li>在服务器启动后，将session文件转化为内存中的session对象即可。</li></ul></li></ul></li></ul></li><li><p>session什么时候被销毁？</p><ol><li>服务器关闭</li><li>session对象调用invalidate() 。</li><li>session默认失效时间 30分钟<br> 选择性配置修改<br> `<session-config><pre><code>&lt;session-timeout&gt;30&lt;/session-timeout&gt;</code></pre></session-config>`</li></ol><ol start="5"><li>session的特点</li><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><ul><li>session与Cookie的区别：<ol><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术&lt;/h1&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://yanghanblog.oss-cn-hangzhou.aliyunc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>191107——JavaWeb之Response</title>
    <link href="https://cometorbityh.github.io/2019/11/11/191107%E2%80%94%E2%80%94Javaweb%E4%B9%8BResponse/"/>
    <id>https://cometorbityh.github.io/2019/11/11/191107——Javaweb之Response/</id>
    <published>2019-11-11T07:00:21.000Z</published>
    <updated>2019-11-15T15:20:38.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http（二）"><a href="#Http（二）" class="headerlink" title="Http（二）"></a>Http（二）</h1><p>响应消息：服务器端发送给客户端的数据</p><h2 id="响应字符串格式"><a href="#响应字符串格式" class="headerlink" title="响应字符串格式"></a>响应字符串格式</h2><blockquote><p>​        HTTP/1.1 200 OK<br>​        Content-Type: text/html;charset=UTF-8<br>​        Content-Length: 101<br>​        Date: Wed, 06 Jun 2018 07:08:42 GMT</p><pre><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  hello , response  &lt;/body&gt;&lt;/html&gt;</code></pre></blockquote><h2 id="响应消息的数据格式"><a href="#响应消息的数据格式" class="headerlink" title="响应消息的数据格式"></a>响应消息的数据格式</h2><h3 id="（1）响应行"><a href="#（1）响应行" class="headerlink" title="（1）响应行"></a>（1）响应行</h3><p>​    组成：协议/版本    响应状态码    状态码描述</p><ul><li><p>响应状态码：服务器告知客户端浏览器本次请求和响应的一个状态（3位数字）</p><table><thead><tr><th>分类</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>1xx</td><td>服务器接收客户端消息，但没有接收完成，<br> 等待一段时间后，发送1xx多状态码</td><td></td></tr><tr><td>2xx</td><td>成功</td><td>200：响应成功</td></tr><tr><td>3xx</td><td>重定向</td><td>302 重定向； <br>304 本地缓存（客户端本地已有，访问缓存即可）</td></tr><tr><td>4xx</td><td>客户端错误</td><td>404：请求路径没有对应资源 <br>405：请求方式没有对应的doxxx方法</td></tr><tr><td>5xx</td><td>服务器端错误</td><td>500：服务器内部出现异常</td></tr></tbody></table></li></ul><h3 id="（2）响应头"><a href="#（2）响应头" class="headerlink" title="（2）响应头"></a>（2）响应头</h3><p>​        格式：头名称：值</p><table><thead><tr><th>常见的响应头</th><th>描述</th></tr></thead><tbody><tr><td>Content-Type</td><td>服务器告知客户端本次响应体的数据格式 + 编码格式</td></tr><tr><td>Content-Length</td><td>响应体长度</td></tr><tr><td>Content-Disposition</td><td>服务器告知客户端以何种格式打开响应体数据<br>* in-line：默认值，在当前页面内打开<br>* attachment；filename=xxx：以附件形式打开响应体。如文件下载</td></tr></tbody></table><h3 id="（3）响应空行"><a href="#（3）响应空行" class="headerlink" title="（3）响应空行"></a>（3）响应空行</h3><h3 id="（4）响应体"><a href="#（4）响应体" class="headerlink" title="（4）响应体"></a>（4）响应体</h3><p>​        响应体包含的是：真实传输的数据</p><h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><h2 id="功能1：设置响应消息"><a href="#功能1：设置响应消息" class="headerlink" title="功能1：设置响应消息"></a>功能1：设置响应消息</h2><h3 id="（1）设置响应行"><a href="#（1）设置响应行" class="headerlink" title="（1）设置响应行"></a>（1）设置响应行</h3><table><thead><tr><th>作用</th><th>方法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>setStatus(int sc)</td></tr></tbody></table><h3 id="（2）设置响应头"><a href="#（2）设置响应头" class="headerlink" title="（2）设置响应头"></a>（2）设置响应头</h3><table><thead><tr><th>作用</th><th>方法</th></tr></thead><tbody><tr><td>设置/修改响应体</td><td>setHeader(String name,String value)</td></tr></tbody></table><h3 id="（3）设置响应体"><a href="#（3）设置响应体" class="headerlink" title="（3）设置响应体"></a>（3）设置响应体</h3><p>​    步骤：</p><ul><li><p>获取输出流</p><table><thead><tr><th>类型</th><th>方法</th></tr></thead><tbody><tr><td>字符输出流</td><td>PrintWriter getWriter()</td></tr><tr><td>字节输出流</td><td>ServletOutputStream getOutputStream()</td></tr></tbody></table></li><li><p>使用输出流，将数据输出到客户端浏览器</p></li></ul><h2 id="功能2：重定向"><a href="#功能2：重定向" class="headerlink" title="功能2：重定向"></a>功能2：重定向</h2><p>重定向：资源跳转的方式</p><h3 id="（1）方法"><a href="#（1）方法" class="headerlink" title="（1）方法"></a>（1）方法</h3><table><thead><tr><th>步骤</th><th>方法</th></tr></thead><tbody><tr><td>1.设置状态码为302</td><td>response.setStatus(302);</td></tr><tr><td>2.设置响应头location，其值为重定向的路径</td><td>response.setHeader(“location”,”/demo/responseDemo2”);</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">--- FirstServlet----------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/firstServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is firstServlet..."</span>);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        response.setStatus(<span class="number">302</span>);</span><br><span class="line">        response.setHeader(<span class="string">"location"</span>,<span class="string">"/demo01/secondServlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- SecondServlet----------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/secondServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is secondServlet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111155151.png" class="lozad"></p><p>这2个方法中，302和location都是固定值，只有重定向的路径是变量，每次写起来有点麻烦，因此Response类提供了一个方法，用来简化书写。</p><table><thead><tr><th>作用</th><th>方法</th></tr></thead><tbody><tr><td>重定向</td><td>sendRedirect(String path)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/demo01/secondServlet"</span>);</span><br></pre></td></tr></table></figure><h3 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h3><ul><li><p>地址栏路径改变，路径为重定向后的url</p></li><li><p>重定向可以访问服务器外部的资源  </p><p><code>response.sendRedirect(&quot;http://www.baidu.com&quot;);</code></p></li><li><p>重定向是2次请求（因此不能使用request域来共享数据）</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111160153.png" class="lozad"></p></li></ul><h3 id="（3）重定向与请求转发"><a href="#（3）重定向与请求转发" class="headerlink" title="（3）重定向与请求转发"></a>（3）重定向与请求转发</h3><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111163824.png" class="lozad"></p><h3 id="（1）输出字符数据"><a href="#（1）输出字符数据" class="headerlink" title="（1）输出字符数据"></a>（1）输出字符数据</h3><p>服务器获取字符输出流输出到浏览器页面，</p><p>步骤：1. 获取字符输出流        2. 输出数据</p><p>注意：输出到浏览器时，可能会产生中文乱码，只要是因为服务器和浏览器的编码不一致导致的，</p><p>因此在获取输出流之前需要：①设置该流的默认编码 ② 告知浏览器响应体使用的编码。</p><p>使用<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>方法可解决中文乱码问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/responseServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置编码，防止浏览器乱码</span></span><br><span class="line">        <span class="comment">//设置流的默认编码</span></span><br><span class="line">        <span class="comment">//response.setCharacterEncoding("utf-8");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式1</span></span><br><span class="line">        <span class="comment">//告知浏览器，服务器发送的消息体数据的编码，建议浏览器使用该编码解码（其中也设置了流编码）</span></span><br><span class="line">        <span class="comment">//response.setHeader("content-type","text/html;charset=utf-8");</span></span><br><span class="line">        <span class="comment">//方式2</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取字符输出流对象，获取的流的默认编码是ISO-8859-1</span></span><br><span class="line">        PrintWriter pw = response.getWriter();</span><br><span class="line">        <span class="comment">//3.输出数据</span></span><br><span class="line">        pw.write(<span class="string">"你好，response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111162208.png" class="lozad"></p><h3 id="（2）输出字节数据"><a href="#（2）输出字节数据" class="headerlink" title="（2）输出字节数据"></a>（2）输出字节数据</h3><p>服务器获取字节输出流输出到浏览器页面。</p><p>步骤：1. 获取字节输出流        2. 输出数据</p><p>中文乱码的解决方法与输出字符数据一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/responseServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置编码，防止浏览器乱码</span></span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        <span class="comment">//2.获取字节输出流对象</span></span><br><span class="line">        ServletOutputStream sos = response.getOutputStream();</span><br><span class="line">        <span class="comment">//3.输出数据</span></span><br><span class="line">        sos.write(<span class="string">"你好，response"</span>.getBytes(<span class="string">"utf-8"</span>));    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http（二）&quot;&gt;&lt;a href=&quot;#Http（二）&quot; class=&quot;headerlink&quot; title=&quot;Http（二）&quot;&gt;&lt;/a&gt;Http（二）&lt;/h1&gt;&lt;p&gt;响应消息：服务器端发送给客户端的数据&lt;/p&gt;
&lt;h2 id=&quot;响应字符串格式&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>191107——JavaWeb之Request</title>
    <link href="https://cometorbityh.github.io/2019/11/07/191107%E2%80%94%E2%80%94Javaweb%E4%B9%8BRequest/"/>
    <id>https://cometorbityh.github.io/2019/11/07/191107——Javaweb之Request/</id>
    <published>2019-11-07T07:00:13.000Z</published>
    <updated>2019-11-15T15:22:31.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http（一）"><a href="#Http（一）" class="headerlink" title="Http（一）"></a>Http（一）</h1><p>Hyper Text Transfer Protocol超文本传输协议</p><p>传输协议：数据的传输协议/规则，定义了客户端和服务端通信时，发送数据的格式（请求消息和响应消息的格式）</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191110094840.png" class="lozad"></p><p>特点</p><ul><li>基于TCP／IP的高级协议（TCP是安全的协议，因此Http也是安全的协议）</li><li>默认端口号：80</li><li>基于请求/响应模型：一次请求对应一次响应，请求和响应一一对应。</li><li>无状态的协议：请求之间相互独立，不能交互数据</li></ul><p>历史版本</p><ul><li>1.0：每次请求都会建立一个新的连接。比如访问百度时，需要 获取到很多css和图片，每次请求到一张图片后都会断开连接，这样出现的结果就是耗时且耗费连接资源</li><li>1.1：复用上次请求的连接。每次请求到一张图片后会等待一段时间，若这段时间内还有数据要发送，就默认使用刚才那个连接，知道最后一个请求之后等待一段时间，发现没有数据需要发送了，即断开连接。</li></ul><h2 id="请求消息的数据格式"><a href="#请求消息的数据格式" class="headerlink" title="请求消息的数据格式"></a>请求消息的数据格式</h2><p>请求行</p><ul><li><p>请求方式  请求url  请求协议/版本</p></li><li><p>请求方式：Http协议有7种请求方式，常用的有get和post</p></li><li><table><thead><tr><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>请求参数在请求行的url后</td><td>请求参数在请求体中</td></tr><tr><td>请求的url长度有限制，</td><td>请求的url长度无限制</td></tr><tr><td>不太安全</td><td>相对安全</td></tr></tbody></table></li></ul><p>请求头（键值对的格式）</p><ul><li><p>请求头名称：请求头值</p><table><thead><tr><th>常见请求头</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><strong><font color="red">User-Agent</font></strong></td><td>浏览器告知服务器，其使用的浏览器版本信息</td><td>在服务器端获取该头的信息，解决浏览器兼容问题<br>（不同浏览器解析数据方法不一样，<br>     使得用户用不同的浏览器访问同一个资源看到相同的界面）</td></tr><tr><td>Accept</td><td>告知服务器，其可解析可接收的文件格式</td><td></td></tr><tr><td>Accept-Language</td><td>支持的语言环境</td><td></td></tr><tr><td>Accept-Encoding</td><td>支持的压缩格式</td><td></td></tr><tr><td><strong><font color="red">Referer</font></strong></td><td>告知服务器，当前请求的来源</td><td>防盗链<br>做统计工作</td></tr><tr><td>Connection</td><td>连接：keep-alive，保持活着，表示的是该连接可被复用</td><td></td></tr><tr><td>Upgrade-insecure</td><td>升级信息</td><td></td></tr></tbody></table><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191110103246.png" class="lozad"></p></li></ul><p>请求空行</p><ul><li>分隔POST的请求头和请求体</li></ul><p>请求体（只有Post有请求体，Get没有）</p><ul><li>封装POST请求消息的请求参数</li></ul><h1 id="Request请求"><a href="#Request请求" class="headerlink" title="Request请求"></a>Request请求</h1><p>回忆之前创建Servlet类时，service方法中有2个参数，ServletRequest req和ServletResponse res，这2个参数分别封装了请求信息和响应消息。</p><h2 id="1-request对象和response对象的原理"><a href="#1-request对象和response对象的原理" class="headerlink" title="1. request对象和response对象的原理"></a>1. request对象和response对象的原理</h2><p>request和response对象是由服务器创建的，而我们的任务就是使用它们；</p><p>request对象是来获取请求信息的，response对象是来设置响应消息的</p><h2 id="2-request对象的继承体系结构"><a href="#2-request对象的继承体系结构" class="headerlink" title="2. request对象的继承体系结构"></a>2. request对象的继承体系结构</h2><p><code>ServletRequest</code>接口，<code>HttpServletRequest</code>接口继承自<code>ServletRequest</code>接口，而<code>org.apache.catalina.connector.RequestFacade</code>类继承<code>HttpServletRequest</code>接口，这个类是<code>tomcat</code>定义的，<code>tomcat</code>创建这个<code>request</code>对象，并传递给<code>service</code>方法</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191110164523.png" class="lozad"></p><h2 id="3-request对象的功能"><a href="#3-request对象的功能" class="headerlink" title="3. request对象的功能"></a>3. request对象的功能</h2><h3 id="3-1-获取请求消息数据（-3）"><a href="#3-1-获取请求消息数据（-3）" class="headerlink" title="3.1. 获取请求消息数据（*3）"></a>3.1. 获取请求消息数据（*3）</h3><h4 id="（1）获取请求行数据"><a href="#（1）获取请求行数据" class="headerlink" title="（1）获取请求行数据"></a>（1）获取请求行数据</h4><p><code>GET /ProjectName/demo1?name=zhangsan HTTP/1.1</code></p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>String  getMethod()</td><td>获取请求方式 ：GET</td></tr><tr><td><font color="red"><strong>String getContextPath()</strong></font></td><td>获取虚拟目录：/ProjectName</td></tr><tr><td>String getServletPath()</td><td>获取Servlet路径: /demo1</td></tr><tr><td>String getQueryString()</td><td>获取get方式请求参数：name=zhangsan</td></tr><tr><td><font color="red"><strong>String getRequestURI()</strong></font></td><td>获取请求URI：/ProjectName/demo1</td></tr><tr><td>StringBuffer getRequestURL()</td><td>获取请求URL：<a href="http://localhost/ProjectName/demo1" target="_blank" rel="noopener">http://localhost/ProjectName/demo1</a></td></tr><tr><td>String getRemoteAddr()</td><td>获取客户机的IP地址：</td></tr><tr><td>String getProtocol()</td><td>获取协议及版本：HTTP/1.1</td></tr></tbody></table><p>URI ：统一资源标识符 ： /ProjectName/demo1——共和国</p><p>URL：统一资源定位符 ：<a href="http://localhost/ProjectName/demo1——中华人民共和国" target="_blank" rel="noopener">http://localhost/ProjectName/demo1——中华人民共和国</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"获取请求方式method："</span>+request.getMethod());</span><br><span class="line">        System.out.println(<span class="string">"获取虚拟目录："</span>+request.getContextPath());</span><br><span class="line">        System.out.println(<span class="string">"获取Servlet路径："</span>+request.getServletPath());</span><br><span class="line">        System.out.println(<span class="string">"获取get方式的请求参数："</span>+request.getQueryString());</span><br><span class="line">        System.out.println(<span class="string">"获取请求的URI："</span>+request.getRequestURI());</span><br><span class="line">        System.out.println(<span class="string">"获取请求的URL："</span>+request.getRequestURL());</span><br><span class="line">        System.out.println(<span class="string">"获取客户机IP地址："</span>+request.getRemoteAddr());</span><br><span class="line">        System.out.println(<span class="string">"获取客户机协议及版本："</span>+request.getProtocol());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）获取请求头数据"><a href="#（2）获取请求头数据" class="headerlink" title="（2）获取请求头数据"></a>（2）获取请求头数据</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><font color="red"><strong>String getHeader(String name)</strong></font></td><td>通过请求头的名称获取请求头的值</td></tr><tr><td>Enumeration<string> getHeaderNames()</string></td><td>获取所有的请求头名称；注意该枚举类型实际是<strong>迭代器</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有请求头的名称</span></span><br><span class="line">        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">        <span class="comment">//根据名称获取对应请求头的值</span></span><br><span class="line">        <span class="keyword">while</span>(headerNames.hasMoreElements())&#123;</span><br><span class="line">            String name = headerNames.nextElement();</span><br><span class="line">            String value = request.getHeader(name);</span><br><span class="line">            System.out.println(name + <span class="string">"---"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- 控制台数据----------------------------------------</span><br><span class="line"></span><br><span class="line">host---localhost:<span class="number">8080</span></span><br><span class="line">connection---keep-alive</span><br><span class="line">cache-control---max-age=<span class="number">0</span></span><br><span class="line">upgrade-insecure-requests---<span class="number">1</span></span><br><span class="line">user-agent---Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">75.0</span>.3770.142 Safari/<span class="number">537.36</span></span><br><span class="line">accept---text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3</span></span><br><span class="line"><span class="comment">accept-encoding---gzip, deflate, br</span></span><br><span class="line"><span class="comment">accept-language---zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="comment">cookie---JSESSIONID=B2F7464DCB3037A05D6AF248ED2F938E; device=11</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求头数据：user-agent</span></span><br><span class="line">        String agent = request.getHeader(<span class="string">"user-agent"</span>);</span><br><span class="line">        System.out.println(agent);</span><br><span class="line">        <span class="comment">//根据agent判断浏览器版本</span></span><br><span class="line">        <span class="keyword">if</span>(agent.contains(<span class="string">"Chrome"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"It is Chrome"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(agent.contains(<span class="string">"firefox"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"It is FireFox"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- 控制台数据----------------------------------------</span><br><span class="line"></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">75.0</span>.3770.142 Safari/<span class="number">537.36</span></span><br><span class="line">It is Chrome</span><br></pre></td></tr></table></figure><h4 id="（3）获取请求体数据"><a href="#（3）获取请求体数据" class="headerlink" title="（3）获取请求体数据"></a>（3）获取请求体数据</h4><p>请求体中封装了POST请求的请求参数，只有POST方式有请求体；</p><p>request对象将请求体封装成<strong>流</strong>，因此需要用获取流的方式来获取请求体的内容</p><p><strong>获取步骤：</strong></p><ul><li>获取流对象<ul><li><code>BufferedReader getReader()</code>：获取字符输入流，只能操作字符数据</li><li><code>ServletInputStream getInputStream()</code>：获取字节输入流，可以操作所有类型数据（文件，图片等）</li></ul></li><li>从流对象中获取数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">--- index.jsp----------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form action=<span class="string">"/demo01/requestDemo"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"输入用户名"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"输入密码"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">            &lt;input type=<span class="string">"submit"</span> value=<span class="string">"注册"</span>&gt;&lt;br&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- RequestDemo.java----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求消息的请求体</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.读取字符流</span></span><br><span class="line">        BufferedReader br = request.getReader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取数据</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 控制台数据----------------------------------------</span><br><span class="line">username=zhangsan&amp;password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191110202427.png" class="lozad"></p><h3 id="3-2-其他功能"><a href="#3-2-其他功能" class="headerlink" title="3.2. 其他功能"></a>3.2. 其他功能</h3><h4 id="（1）获取请求参数通用方式（GET、POST均可）"><a href="#（1）获取请求参数通用方式（GET、POST均可）" class="headerlink" title="（1）获取请求参数通用方式（GET、POST均可）"></a>（1）获取请求参数通用方式（GET、POST均可）</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong><font color="red">String  getParameter(String name)</font></strong></td><td>通过参数名获取参数值</td></tr><tr><td>String  getParameterValues(String name)</td><td>根据参数名获取参数值的数组（复选框）</td></tr><tr><td>Enumeration&lt;String.&gt;   getParameterNames()</td><td>获取所有请求的参数名称</td></tr><tr><td>Map&lt;String,String[]&gt;  getParameterMap()</td><td>获取所有参数的map集合</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/demo01/requestDemo"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"输入用户名"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"输入密码"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"game"</span>&gt;游戏</span><br><span class="line">      &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"study"</span>&gt;学习</span><br><span class="line">      &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"sing"</span>&gt;唱歌&lt;br&gt;</span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> value=<span class="string">"注册"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.client.sei.ValueSetter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.ValidationEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        System.out.println(<span class="string">"getParameter ---&gt; "</span>+ <span class="string">"username:"</span> + username + <span class="string">","</span> + <span class="string">"password:"</span> + password);</span><br><span class="line">        <span class="comment">/*-------------------------------*/</span></span><br><span class="line">        String[] hobbies = request.getParameterValues(<span class="string">"hobby"</span>);</span><br><span class="line">        System.out.print(<span class="string">"getParameterValues ---&gt; "</span> + <span class="string">"hobby:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String hobby:hobbies)&#123;</span><br><span class="line">            System.out.print(hobby + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">/*-------------------------------*/</span></span><br><span class="line">        Enumeration&lt;String&gt; parameterNames = request.getParameterNames();</span><br><span class="line">        System.out.print(<span class="string">"getParameterNames ---&gt; "</span>);</span><br><span class="line">        <span class="keyword">while</span> (parameterNames.hasMoreElements())&#123;</span><br><span class="line">            String name = parameterNames.nextElement();</span><br><span class="line">            String value = request.getParameter(name);</span><br><span class="line">            System.out.print(name + <span class="string">":"</span> + value + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">/*-------------------------------*/</span></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        System.out.println(<span class="string">"getParameterMap ---&gt;"</span>);</span><br><span class="line">        <span class="comment">//遍历Map的Key</span></span><br><span class="line">        Set&lt;String&gt; keyset = parameterMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String name : keyset)&#123;</span><br><span class="line">            System.out.print(name + <span class="string">":"</span>);</span><br><span class="line">            <span class="comment">//获取key对应的value数组</span></span><br><span class="line">            String[] values = parameterMap.get(name);</span><br><span class="line">            <span class="keyword">for</span> (String value : values)&#123;</span><br><span class="line">                System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111135924.png" class="lozad"></p><h4 id="（2）获取请求参数中文乱码解决"><a href="#（2）获取请求参数中文乱码解决" class="headerlink" title="（2）获取请求参数中文乱码解决"></a>（2）获取请求参数中文乱码解决</h4><ul><li><p>get方式：tomcat8 已经将中文乱码问题解决，不会出现中文乱码</p></li><li><p>post方式：未解决。</p><ul><li><p>解决方案：获取参数前，设置request的编码</p></li><li><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>request.setCharacterEncoding(“utf-8”);</td><td>设置request的编码为utf-8</td></tr></tbody></table></li></ul></li></ul><h4 id="（3）请求转发"><a href="#（3）请求转发" class="headerlink" title="（3）请求转发"></a>（3）请求转发</h4><p>一种在<strong>服务器内部</strong>的资源跳转的方式。因此不会改变地址栏url</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111140815.png" class="lozad"></p><table><thead><tr><th align="center">步骤</th><th align="center">方法</th></tr></thead><tbody><tr><td align="center">通过request对象获取请求转发器对象</td><td align="center">request.getRequestDispatcher(String path)</td></tr><tr><td align="center">使用请求转发器对象来进行资源转发</td><td align="center">forward(ServletRequest request, ServletResponse response)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/secondServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is secondServlet..."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/firstServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is firstServlet..."</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/secondServlet"</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111142159.png" class="lozad"></p><blockquote><p>特点：</p><ul><li><p>浏览器地址不发生变化</p></li><li><p>只能转发到服务器内部的资源；如下代码无法转发到百度服务器</p></li></ul><p><code>request.getRequestDispatcher(&quot;http://www.baidu.com&quot;).forward(request,response);</code></p><ul><li>转发是一次请求，不是两次请求</li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111142820.png" class="lozad"></p></blockquote><h4 id="（4）共享数据"><a href="#（4）共享数据" class="headerlink" title="（4）共享数据"></a>（4）共享数据</h4><blockquote><p>域对象：一个有作用范围的对象，可以在范围内共享数据</p><p>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</p></blockquote><p><strong>request域的三个方法</strong></p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>void  setAttribute(String name,Object obj)</td><td>在request域中存储数据</td></tr><tr><td>Object  getAttribute(String name)</td><td>在request域中通过键获取值</td></tr><tr><td>void  removeAttribute(String name)</td><td>在request域中移除键所对应的键值对</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">---------------FirstServlet.java-----------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/firstServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is firstServlet..."</span>);</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>,<span class="string">"success!"</span>);</span><br><span class="line"></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/secondServlet"</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------SecondServlet.java-----------------</span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/secondServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Object msg = request.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">        System.out.println(<span class="string">"msg --&gt;"</span> + msg);</span><br><span class="line">        System.out.println(<span class="string">"this is secondServlet..."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------控制台-----------------</span><br><span class="line"><span class="keyword">this</span> is firstServlet...</span><br><span class="line">msg --&gt;success!</span><br><span class="line"><span class="keyword">this</span> is secondServlet...</span><br></pre></td></tr></table></figure><h4 id="（5）获取ServletContext对象"><a href="#（5）获取ServletContext对象" class="headerlink" title="（5）获取ServletContext对象"></a>（5）获取ServletContext对象</h4><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>ServletContext getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---------------RequestDemo.java-----------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.client.sei.ValueSetter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.ValidationEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServletContext servletContext = request.getServletContext();</span><br><span class="line">        System.out.println(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------控制台-----------------</span><br><span class="line">org.apache.catalina.core.ApplicationContextFacade@<span class="number">3060</span>c493</span><br></pre></td></tr></table></figure><h1 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h1><p>概念：代表整个web应用，可以和程序的容器(服务器)来通信</p><h2 id="1-获取方式（2种）"><a href="#1-获取方式（2种）" class="headerlink" title="1. 获取方式（2种）"></a>1. 获取方式（2种）</h2><table><thead><tr><th>获取方式</th><th>方法</th></tr></thead><tbody><tr><td>通过request对象获取</td><td>request.getServletContext()</td></tr><tr><td>通过HttpServlet获取</td><td>this.getServletContext()</td></tr></tbody></table><h2 id="2-ServletContext的功能"><a href="#2-ServletContext的功能" class="headerlink" title="2. ServletContext的功能"></a>2. ServletContext的功能</h2><h3 id="（1）获取MIME类型"><a href="#（1）获取MIME类型" class="headerlink" title="（1）获取MIME类型"></a>（1）获取MIME类型</h3><ul><li>MIME类型：在互联网通信过程中定义的一种<strong>文件数据类型</strong>的标准<ul><li>格式： 大类型/小类型  （例：text/html， image/jpeg）</li></ul></li><li>获取：<code>String getMimeType(String file)</code></li></ul><h3 id="（2）域对象：共享数据"><a href="#（2）域对象：共享数据" class="headerlink" title="（2）域对象：共享数据"></a>（2）域对象：共享数据</h3><p>ServletContext对象范围：共享所有用户所有请求的数据</p><ul><li>setAttribute(String name,Object value)</li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li></ul><h3 id="（3）获取文件的真实-服务器-路径"><a href="#（3）获取文件的真实-服务器-路径" class="headerlink" title="（3）获取文件的真实(服务器)路径"></a>（3）获取文件的真实(服务器)路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.young.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/servletContextDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取ServletContext对象</span></span><br><span class="line">        ServletContext context1 = request.getServletContext();</span><br><span class="line">        ServletContext context2 = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        System.out.println(context1);</span><br><span class="line">        System.out.println(context2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取MIME类型</span></span><br><span class="line">        String mimeType = context2.getMimeType(<span class="string">"a.jpg"</span>);</span><br><span class="line">        System.out.println(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件真实路径</span></span><br><span class="line">        String test01 = context2.getRealPath(<span class="string">"/WEB-INF/classes/test01.txt"</span>);    <span class="comment">//src目录下访问资源</span></span><br><span class="line">        System.out.println(test01);</span><br><span class="line">        String test02 = context2.getRealPath(<span class="string">"/WEB-INF/test02.txt"</span>);    <span class="comment">//WEB-INF目录下访问资源</span></span><br><span class="line">        System.out.println(test02);</span><br><span class="line">        String test03 = context2.getRealPath(<span class="string">"/test03.txt"</span>);    <span class="comment">//web目录下访问资源</span></span><br><span class="line">        System.out.println(test03);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------- 控制台输出结果 ----------------------</span><br><span class="line">org.apache.catalina.core.ApplicationContextFacade@<span class="number">1f</span>5b43b6</span><br><span class="line">org.apache.catalina.core.ApplicationContextFacade@<span class="number">1f</span>5b43b6</span><br><span class="line">image/jpeg</span><br><span class="line">C:\Users\Administrator.RG4-<span class="number">44</span>\Desktop\demo01\out\artifacts\demo01_war_exploded\WEB-INF\classes\test01.txt</span><br><span class="line">C:\Users\Administrator.RG4-<span class="number">44</span>\Desktop\demo01\out\artifacts\demo01_war_exploded\WEB-INF\test02.txt</span><br><span class="line">C:\Users\Administrator.RG4-<span class="number">44</span>\Desktop\demo01\out\artifacts\demo01_war_exploded\test03.txt</span><br></pre></td></tr></table></figure><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191111203926.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http（一）&quot;&gt;&lt;a href=&quot;#Http（一）&quot; class=&quot;headerlink&quot; title=&quot;Http（一）&quot;&gt;&lt;/a&gt;Http（一）&lt;/h1&gt;&lt;p&gt;Hyper Text Transfer Protocol超文本传输协议&lt;/p&gt;
&lt;p&gt;传输协议：数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>191106——JavaWeb之Servlet</title>
    <link href="https://cometorbityh.github.io/2019/11/06/191106%E2%80%94%E2%80%94JavaWeb%E4%B9%8BServlet/"/>
    <id>https://cometorbityh.github.io/2019/11/06/191106——JavaWeb之Servlet/</id>
    <published>2019-11-06T09:16:13.000Z</published>
    <updated>2019-11-11T07:02:46.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="1-Servlet简介"><a href="#1-Servlet简介" class="headerlink" title="1. Servlet简介"></a>1. Servlet简介</h2><p>servlet = server applet，字面意思是：运行在服务器端的小程序</p><p>servlet就是一个接口，定义了Java类被浏览器访问到的<strong>规则</strong>。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106173327.png" class="lozad"></p><p>##2. 实现Servlet及其执行原理</p><p>查看Java EE8文档，发现servlet定义了5个方法。当一个类实现Servlet接口时，需要重写Servlet的方法。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106173539.png" class="lozad"></p><p><strong>定义一个类实现Servlet接口的4个步骤：</strong></p><p>（1）创建JAVA EE项目</p><p>（2）定义一个类，实现Servlet接口</p><p>（3）实现Servlet接口的抽象方法</p><p>（4）配置Servlet（在web.xml中配置）</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106175434.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106175913.png" class="lozad"></p><p><strong>执行原理：</strong></p><p>当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径；</p><p>查找web.xml文件，是否有<code>&lt;url-pattern&gt;</code>标签体内容；</p><p>若有，则找到对应的<code>&lt;servlet-class&gt;</code>全类名；</p><p>tomcat会将字节码文件加载进内存，并且创建其对象，调用其方法。（<font color="red">反射操作</font>）</p><h2 id="3-Servlet的生命周期"><a href="#3-Servlet的生命周期" class="headerlink" title="3. Servlet的生命周期"></a>3. Servlet的生命周期</h2><table><thead><tr><th>方法</th><th>作用</th><th>生命周期</th></tr></thead><tbody><tr><td>void init</td><td>初始化的方法，在Servlet被创建时执行，只执行一次</td><td>被创建</td></tr><tr><td>void service</td><td>提供服务的方法，每一个Servlet被访问时都会被执行，可执行多次</td><td>提供服务</td></tr><tr><td>void destroy</td><td>销毁的方法，在服务器<strong>正常关闭</strong>时执行，只执行一次</td><td>被销毁</td></tr></tbody></table><table><thead><tr><th>其他2个方法</th><th></th></tr></thead><tbody><tr><td>ServletConfig  getServletConfig</td><td>获取ServletConfig对象，servlet的配置对象</td></tr><tr><td>String  getServletInfo</td><td>获取Servlet的一些信息：版本、作者…</td></tr></tbody></table><blockquote><p><strong>Servlet对象什么时候被创建？</strong></p><p>默认情况：第一次被访问时创建。</p><p>特殊情况：在服务器启动时创建。配置<code>web.xml</code>下的<code>&lt;servlet&gt;</code>中的<code>&lt;load-on-startup&gt;</code>。</p><ul><li>当值为负整数时，第一次被访问时创建。</li><li>当值为正整数或0时，在服务器启动时创建。值的范围为[0,10]</li></ul><p><strong>一个servlet在内存中有几个对象？</strong></p><p>Servlet的init方法只执行1次，说明一个Servlet在内存中只存在一个对象，因此servlet是单例的。</p><ul><li>多个用户同时访问时，可能存在安全问题。因此尽量不在Servlet中定义成员变量。若定义了成员变量，也不要有修改值的操作，因为这个变量会被所有用户访问到。</li></ul><p><strong>destroy方法是在servlet对象被销毁之前执行还是之后执行？</strong></p><p>好比临终遗言般，destroy应该是在Servlet销毁之前执行，一般用于释放资源。</p></blockquote><h2 id="4-Servlet-3-0注解配置"><a href="#4-Servlet-3-0注解配置" class="headerlink" title="4. Servlet 3.0注解配置"></a>4. Servlet 3.0注解配置</h2><p>Servlet 3.0加入了注解配置，使得Servlet可以不用配置web.xml文件，直接在Servlet类上添加注解<code>@WebServlet(&quot;/demo&quot;)</code>，其中<code>/demo</code>是url-pattern，这样子就大大简化了代码，也不需要配置servlet-name了。</p><p>urlpartten：Servlet访问路径，是个数组，因此可以设置多个路径</p><ul><li>一个Servlet可以设置多个访问路径：<code>@WebServlet({&quot;/aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;})</code></li><li>路径配置规则（*是通配符，优先级是最低的）<ul><li>/xxx：单层路径（/*随意起名都可访问该Servlet类）</li><li>/xxx/xxx：双层路径（/xxx/*表示第二层随意起名都可访问该Servlet类）</li><li>*.do（注意前面不加“/”）</li></ul></li></ul><h2 id="5-Servlet的体系结构"><a href="#5-Servlet的体系结构" class="headerlink" title="5. Servlet的体系结构"></a>5. Servlet的体系结构</h2><p>通过之前的小案例，了解了Servlet的基本操作。但是发现每次实现Servlet接口都要重写其5个方法，单往往我们只需要其中的service方法，其他4个方法一般不会使用。因此有没有什么方式能让我们只需要重写service方法就行了呢？有！</p><p>我们去看下Servlet接口的继承结构：</p><p>Servlet接口有一个实现类GenericServlet，这个类是个抽象类。而抽象类GenericServlet还有一个子类，名为HttpServlet，也是一个抽象类。这2个抽象类都能更简便的让我们重写Servlet的某些方法，而不是重写所有方法。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106184710.png" class="lozad"></p><p>GenericServlet抽象类将Serrvlet接口中其他的方法做了默认空实现，只保留service( )方法作为抽象，也就是说，定义一个继承GenericServlet的Servlet类时，只需重写service（）方法即可，其他方法可以选择性的按照需求重写。</p><p>虽然GenericServlet抽象类很方便，但是我们实际开发时也很少使用GenericServlet，通常我们会使用HttpServlet抽象类</p><p>HttpServlet继承自GenericServlet抽象类，是Http协议的一种封装，可以简化操作</p><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><p>Service源码中获取了请求的方法，判断这个请求方式执行的方法， 因此我们无需像GenericServlet类一样重写service方法，而是重写对应的请求方法执行的方法，如doGet()、doPost()等7种。</p><ul><li>定义类继承HttpServlet</li><li>复写doGet() / doPost()方法，当请求方法是get时，调用doGet方法，当请求是Post时，调用doPost方法，我们现在已知的post请求只有一种（表单method = post），其余均为get请求。</li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191110172508.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;h2 id=&quot;1-Servlet简介&quot;&gt;&lt;a href=&quot;#1-Servlet简介&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>191106——Git基本操作</title>
    <link href="https://cometorbityh.github.io/2019/11/03/191106%E2%80%94%E2%80%94Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://cometorbityh.github.io/2019/11/03/191106——Git基本操作/</id>
    <published>2019-11-03T12:00:46.000Z</published>
    <updated>2019-11-06T13:45:04.679Z</updated>
    
    <content type="html"><![CDATA[<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/Git&GitHub.bmp" class="lozad"></p><h1 id="1-版本控制工具"><a href="#1-版本控制工具" class="headerlink" title="1. 版本控制工具"></a>1. 版本控制工具</h1><p>集中式版本控制工具：SVN、CVS、VSS…</p><p>分布式版本控制工具：Git、Mercurial、Bazaar、Darcs…</p><h1 id="2-Git"><a href="#2-Git" class="headerlink" title="2. Git"></a>2. Git</h1><h2 id="2-1-Git的优势"><a href="#2-1-Git的优势" class="headerlink" title="2.1. Git的优势"></a>2.1. Git的优势</h2><ul><li>大部分操作在本地完成，无需联网（分布式版本控制，相当于本地仓库，因此无需联网）</li><li>完整性保证</li><li>尽可能添加数据而不是删除或修改数据（删除修改都是不可逆的操作）</li><li>分支操作非常快加流畅</li><li>与Linux命令全面兼容（他俩一个爹：Linux）</li></ul><h2 id="2-2-Git结构"><a href="#2-2-Git结构" class="headerlink" title="2.2. Git结构"></a>2.2. Git结构</h2><img style="zoom: 50%;" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191103202636.png" class="lozad"><p>##<strong>2.3. Git</strong> <strong>和代码托管中心</strong> </p><h3 id="2-3-1-代码托管中心的任务：维护远程库"><a href="#2-3-1-代码托管中心的任务：维护远程库" class="headerlink" title="2.3.1 代码托管中心的任务：维护远程库"></a>2.3.1 代码托管中心的任务：维护远程库</h3><ul><li><p>局域网环境下</p></li><li><p>GitLab 服务器 </p></li><li><p>外网环境下 </p><ul><li><p>GitHub </p></li><li><p>码云</p></li></ul></li></ul><h1 id="3-本地库及其命令"><a href="#3-本地库及其命令" class="headerlink" title="3. 本地库及其命令"></a>3. 本地库及其命令</h1><h2 id="3-1-本地库和远程库"><a href="#3-1-本地库和远程库" class="headerlink" title="3.1 本地库和远程库"></a>3.1 本地库和远程库</h2><p>（1）<strong>团队内部协作</strong></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191103222223.png" class="lozad"></p><p>（2）<strong>跨团队协作</strong></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191103222100.png" class="lozad"></p><p>##3.2. 本地库操作命令</p><h3 id="3-2-1-本地库初始化-签名"><a href="#3-2-1-本地库初始化-签名" class="headerlink" title="3.2.1 本地库初始化 + 签名"></a>3.2.1 本地库初始化 + 签名</h3><h4 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h4><p>命令：    <code>git init</code></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191103224243.png" class="lozad"></p><p>注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要随意修改。 </p><h4 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h4><p><strong>作用：</strong>区分不同开发人员的身份</p><p><strong>格式：</strong>（举例，用户名与Email无实际联系）</p><ul><li>用户名：tom</li><li>Email：<a href="mailto:goodMorning@hello.com" target="_blank" rel="noopener">goodMorning@hello.com</a></li></ul><p><strong>注意：</strong>该签名和用于登录远程库（即代码托管中心）的账号密码无任何关系。</p><p><strong>命令：</strong></p><ul><li><p>项目级别/仓库级别：只在当前本地库范围生效（信息保存在<code>.git</code>目录下的<code>config</code>文件中）</p></li><li><p><code>git config user.name tom_pro</code> </p></li><li><p><code>git config user.email goodMorning_pro@hello.com</code> </p></li><li><p>系统用户级别：登录当前操作系统的用户范围 （信息保存位置：系统<code>~</code>家目录下的<code>.gitconfig</code>文件）</p></li><li><p><code>git config --global user.name tom_glb</code> </p></li><li><p><code>git config --global user.email goodMorning_glb@hello.com</code></p></li><li><p>级别优先级：</p><ul><li>就近原则（项目级别 &gt; 系统级别，二者都有时采用项目级别的签名）</li><li>若只有系统级别的签名：以系统用户级别的签名为准</li><li>当二者都没有是不允许的。</li></ul></li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104163310.png" class="lozad"></p><p>###3.2.2. 基本操作</p><p>新建一个文件，工作区添加到暂存区，提交到本地库</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104171255.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104171645.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104172119.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104172318.png" class="lozad"></p><p><img alt="image-20191104172831494" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191104172831494.png" class="lozad"></p><p>修改一个文件，添加到暂存区，提交到本地库</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104173348.png" class="lozad"></p><p>查看提交日志</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104173800.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104174651.png" class="lozad"></p><p><strong>前进后退版本</strong></p><p>索引值能前进后退版本，^和~只能后退版本。</p><p>该命令中存在hard参数，在reset命令中，还有soft和mixed参数</p><ul><li>soft参数：仅在本地库移动HEAD指针</li><li>mixed参数：在本地库移动HEAD指针，重置暂存区</li><li>hard参数：在本地库移动HEAD指针，重置暂存区，重置工作区</li></ul><p><img alt="image-20191104175559414" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191104175559414.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191104180134.png" class="lozad"></p><p><strong>删除文件找回</strong></p><p>前提：删除前，文件存在时的状态提交到了本地库 （之前已经把要找回的文件提交到了本地库）</p><p><code>git reset --hard [指针位置]</code>:</p><p>指针位置：</p><ul><li>删除操作已提交到本地库，指针位置指向历史记录（永久删除文件后找回）</li><li>删除操作未提交到本地库，指针位置指向HEAD（添加到暂存区的删除文件找回）</li></ul><p>永久删除文件后找回</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105143653.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105144037.png" class="lozad"></p><p>添加到暂存区的删除文件找回</p><p><img alt="image-20191105144540571" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191105144540571.png" class="lozad"></p><p>比较差异（比较不同版本的同一文件的差异）</p><p>git diff [文件名]：将工作区的文件和暂存区进行比较</p><p>git diff [本地库历史版本] [文件名]：将工作区中的文件和本地库历史记录比较</p><p>不带文件名 比较多个文件</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105150327.png" class="lozad"></p><h3 id="3-2-3-分支管理"><a href="#3-2-3-分支管理" class="headerlink" title="3.2.3. 分支管理"></a>3.2.3. 分支管理</h3><p>查看分支 git branch -v</p><p>创建分支 git branch [分支名]</p><p>切换分支 git checkout [分支名]</p><p>合并分支</p><p>​    切换到接收修改的分支上（被合并的，变更内容的分支）</p><p>git checkout [被合并的分支名]</p><p>​    执行merge命令</p><p>git merge [有新内容的分支名]</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/image-20191105152050105.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105152341.png" class="lozad"></p><p>分支冲突：2个分支同时修改了文件，git不清楚盖如何合并，导致分支冲突</p><p>解决：</p><ul><li>编辑文件，删除特殊符号，修改文件内容后保存退出；</li><li>文件添加到暂存区，提交到本地库（注意此步操作不加文件名）</li></ul><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105153802.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105154151.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105154701.png" class="lozad"></p><p>#4. Git基本原理</p><h2 id="4-1-哈希算法"><a href="#4-1-哈希算法" class="headerlink" title="4.1. 哈希算法"></a>4.1. 哈希算法</h2><p>哈希是一系列的算法，不同hash算法的加密强度不同。哈希算法不可逆。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105155335.png" class="lozad"></p><p>Git底层采用的是SHA-1算法，哈希算法可以用来验证文件</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105155620.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160220.png" class="lozad"></p><p>##4.2. Git 保存版本的机制</p><p><strong>Git</strong> <strong>的文件管理机制</strong> </p><p>Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160429.png" class="lozad"></p><p><strong>Git</strong> <strong>文件管理机制细节</strong> </p><p> Git 的“提交对象”</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160522.png" class="lozad"></p><p>提交对象及其父对象形成的链条</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160542.png" class="lozad"></p><p><strong>Git</strong> <strong>分支管理机制</strong> </p><p><strong>5.3.1</strong> <strong>分支的创建</strong></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160828.png" class="lozad"></p><p><strong>分支的切换</strong></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160859.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160933.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105160946.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105161002.png" class="lozad"></p><p>总而言之，创建分支是创建新的指针，切换分支是切换指针的位置，因此非常高效</p><p>#5. 远程库操作命令</p><h2 id="5-1-GitHub创建仓库"><a href="#5-1-GitHub创建仓库" class="headerlink" title="5.1. GitHub创建仓库"></a>5.1. GitHub创建仓库</h2><p>1.注册账号并登录</p><p>2.创建仓库（远程库）</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105162214.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105162117.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105162517.png" class="lozad"></p><h2 id="5-2-本地库推送到远程库"><a href="#5-2-本地库推送到远程库" class="headerlink" title="5.2. 本地库推送到远程库"></a>5.2. 本地库推送到远程库</h2><p>本地库连接远程库，执行推送操作</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105163212.png" class="lozad"></p><p>刷新远程库，可以看到刚才提交的文件了，点击可查看内容</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105163414.png" class="lozad"></p><p>##5.3. 从远程库克隆项目到本地</p><p>另一个人执行的克隆操作</p><p>复制地址</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105163845.png" class="lozad"></p><p>克隆项目</p><p><img alt="image-20191105164424088" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191105164424088.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105170638.png" class="lozad"></p><p>这样用户2就克隆了用户1的远程库到本地了。</p><p>##5.4. 修改内容重新推送到远程库</p><p>现在，用户2想修改用户1的内容并重新发回到用户1的本地库该怎么弄？</p><p>之前图里看到过，直接推送是不行的， 需要用户1批准用户2，邀请用户2加入团队成为团队成员才能进行推送操作。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105170859.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105171135.png" class="lozad"></p><p><img alt="image-20191105171330106" data-src="C:%5CUsers%5CAdministrator.RG4-44%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191105171330106.png" class="lozad"></p><p>此时用户1成功邀请2成为团队成员</p><p>用户2就可以推送操作了</p><p>###远程库修改的拉取</p><p>pull = fetch + merge 分为2步。git fetch [远程库地址别名] [远程分支名]</p><p>git merge  [远程库地址别名]/[远程分支名]</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105172535.png" class="lozad"></p><p>##5.5. 协同开发的冲突的解决</p><p>当用户1和用户2同时修改了某个文件的同一位置时，分别推送到远程库会出现冲突，即先推送的能成功，后推送的失败，因为远程库根据哈希值比较，若不同则认为你的本地库不是最新的了，因此用户2需要先拉取到本地，进行内容的修改，再进行推送。</p><ul><li>如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 </li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 </li></ul><p>##5.6. 跨团队协作操作</p><p>用户1和用户2是团队A的，用户3是团队B的，现在A对需要把项目给B队去优化，应该怎么做？</p><p>首先团队B的成员要把团队A的远程库fork成自己的远程库，再克隆到本地，修改完成后push，发起pull request</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105174617.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105174723.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105175605.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105175649.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105175738.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105175919.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180018.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180118.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180326.png" class="lozad"></p><p>团队1接受pull request</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180525.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180801.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105180934.png" class="lozad"></p><p>之后团队1就可以拉取远程库了。</p><h2 id="5-7-SSH免密登录"><a href="#5-7-SSH免密登录" class="headerlink" title="5.7. SSH免密登录"></a>5.7. SSH免密登录</h2><p>可以实现免GitHub账号登录，因此使用SSH可以免密登录，需要注意的是这样只能一个账号登陆</p><h1 id="6-Git图形化-lt-eclipse版-gt"><a href="#6-Git图形化-lt-eclipse版-gt" class="headerlink" title="6. Git图形化&lt;eclipse版&gt;"></a>6. Git图形化&lt;eclipse版&gt;</h1><p>##6.1. 新建项目提交到本地库（忽略特定文件）</p><p>以eclipse为例：</p><p>点击Window——&gt; Preferences ——&gt; Team——&gt; Git——&gt;Configuration</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105220404.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105220740.png" class="lozad"></p><p>新建一个Maven项目</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105220909.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191105221719.png" class="lozad"></p><p>将eclipse工程初始化为本地库</p><p>右击工程——&gt;Team——&gt;Share Project ——&gt;Git</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106152424.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106152530.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106152746.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106153450.png" class="lozad"></p><p>解决追踪文件，首先要忽略一些特定文件</p><p><strong>概念：Eclipse 特定文件</strong> </p><p>这些都是 Eclipse 为了管理我们创建的工程而维护的文件，和开发的代码没有 直接关系。最好不要在 Git 中进行追踪，也就是把它们忽略。 </p><p>.classpath 文件 </p><p>.project 文件 </p><p>.settings 目录下所有文件 </p><p><strong>为什么要忽略 Eclipse 特定文件呢？</strong> </p><p>同一个团队中很难保证大家使用相同的 IDE 工具，而 IDE 工具不同时，相关工程特定文件就有可能不同。如果这些文件加入版本控制，那么开发时很可能需要为了这些文件解决冲突</p><p>在家目录的本机用户的<code>.gitconfig</code>同级目录下新建一个<code>java.gitignore</code>，该文件的内容位于 <a href="https://github.com/github/gitignore/blob/master/Java.gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore/blob/master/Java.gitignore</a> </p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106154726.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106154458.png" class="lozad"></p><p>在<code>.gitconfig</code>中添加：</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106154955.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106155136.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106155318.png" class="lozad"></p><p>这样，无论做任何版本操作，这些特定的文件都不会受任何干扰了</p><p>将项目添加到暂存区，右击项目——&gt;Team——&gt;add to Index</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106155723.png" class="lozad"></p><p>将项目提交到本地库，右击项目——&gt;Team——&gt;commit</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106155925.png" class="lozad"></p><p>若再添加新文件，可以直接对其commir，不用add。这就是图形化界面的优势</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106160423.png" class="lozad"></p><h2 id="6-2-推送到远程库"><a href="#6-2-推送到远程库" class="headerlink" title="6.2. 推送到远程库"></a>6.2. 推送到远程库</h2><p>新建远程库，复制链接</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106160700.png" class="lozad"></p><p>右击项目——&gt;Team——&gt;remote——&gt;push</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106160900.png" class="lozad"></p><p>添加所有分支</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161031.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161205.png" class="lozad"></p><p>成功后，回到远程库可查看</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161355.png" class="lozad"></p><h2 id="6-3-克隆工程操作"><a href="#6-3-克隆工程操作" class="headerlink" title="6.3. 克隆工程操作"></a>6.3. 克隆工程操作</h2><p>右击空白处，import——&gt; Git——&gt;Project from Git——&gt;next——&gt;Clone URI——&gt;粘贴URI——&gt;master——&gt;next——&gt;更改保存路径——&gt;完成</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161630.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161745.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161850.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106161936.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162213.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162420.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162438.png" class="lozad"></p><p>克隆结束后，发现项目文件不完整，因为之前忽略了一些特定文件，所以还需要一些操作</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162522.png" class="lozad"></p><p>右击项目，——&gt; configure ——&gt; convert to Maven Project，这样就能自动生成为Maven项目了。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162701.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106162906.png" class="lozad"></p><p>##6.4. 在eclipse解决冲突</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106163325.png" class="lozad"></p><p>分别提交</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106163629.png" class="lozad"></p><p>推送到远程库，第二个推送的人会产生冲突</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106163805.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106163931.png" class="lozad"></p><p>解决：用户2先拉取（pull）,右击项目——&gt;Team——&gt;pull</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164125.png" class="lozad"></p><p>右击冲突文件——&gt;Team——&gt;Merge Tool，可以看到对比</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164218.png" class="lozad"></p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164353.png" class="lozad"></p><p>打开提交界面</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164451.png" class="lozad"></p><p>此时文件图标恢复正常，到远程库即可。</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164643.png" class="lozad"></p><p>查看远程库，推送成功！</p><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191106164721.png" class="lozad"></p><h1 id="7-Git工作流（略）"><a href="#7-Git工作流（略）" class="headerlink" title="7. Git工作流（略）"></a>7. Git工作流（略）</h1><p><strong>概念</strong></p><p>在项目开发过程中使用 Git 的方式</p><p>分类</p><p><strong>集中式工作流</strong></p><p><strong>GitFlow</strong> <strong>工作流</strong></p><p><strong>Forking</strong> <strong>工作流</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img alt data-src=&quot;https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/Git&amp;GitHub.bmp&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-版本控制工具&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="Git" scheme="https://cometorbityh.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://cometorbityh.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
