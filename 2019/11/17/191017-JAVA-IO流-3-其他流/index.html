<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>191017-JAVA-IO流(3)-其他流 | MY</title><meta name="description" content="191017-JAVA-IO流(3)-其他流"><meta name="keywords" content="Java,IO"><meta name="author" content="杨涵"><meta name="copyright" content="杨涵"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="191017-JAVA-IO流(3)-其他流"><meta name="twitter:description" content="191017-JAVA-IO流(3)-其他流"><meta name="twitter:image" content="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png"><meta property="og:type" content="article"><meta property="og:title" content="191017-JAVA-IO流(3)-其他流"><meta property="og:url" content="https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/"><meta property="og:site_name" content="MY"><meta property="og:description" content="191017-JAVA-IO流(3)-其他流"><meta property="og:image" content="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="CET6 CORE (1)" href="https://cometorbityh.github.io/2019/11/18/CET6-CORE-1/"><link rel="next" title="191016_JAVA_IO流(2)_IO流" href="https://cometorbityh.github.io/2019/11/16/191016-JAVA-IO流-2-IO流/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: 杨涵","link":"链接: https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/","source":"来源: MY","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">MY</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">60</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#缓冲流"><span class="toc_mobile_items-text">缓冲流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-字节缓冲流"><span class="toc_mobile_items-text">1 - 字节缓冲流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-字节缓冲输出流"><span class="toc_mobile_items-text">1.1 - 字节缓冲输出流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-1-构造方法"><span class="toc_mobile_items-text">1.1.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-2-使用步骤-重点"><span class="toc_mobile_items-text">1.1.2 - 使用步骤(重点)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-字节缓冲输入流"><span class="toc_mobile_items-text">1.2 - 字节缓冲输入流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2-1-构造方法"><span class="toc_mobile_items-text">1.2.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2-2-使用步骤-重点"><span class="toc_mobile_items-text">1.2.2 - 使用步骤(重点)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-文件复制"><span class="toc_mobile_items-text">1.3 - 文件复制</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-字符缓冲流"><span class="toc_mobile_items-text">2 - 字符缓冲流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-字符缓冲输出流"><span class="toc_mobile_items-text">2.1 - 字符缓冲输出流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-1-构造方法"><span class="toc_mobile_items-text">2.1.1 - 构造方法:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-2-特有的成员方法"><span class="toc_mobile_items-text">2.1.2 - 特有的成员方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-3-使用步骤"><span class="toc_mobile_items-text">2.1.3 -  使用步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-字符缓冲输入流"><span class="toc_mobile_items-text">2.2 - 字符缓冲输入流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-1-构造方法"><span class="toc_mobile_items-text">2.2.1 -  构造方法:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-2-特有的成员方法"><span class="toc_mobile_items-text">2.2.2 - 特有的成员方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-3-使用步骤"><span class="toc_mobile_items-text">2.2.3 - 使用步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-练习：文本排序"><span class="toc_mobile_items-text">2.3 - 练习：文本排序</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-字符编码和字符集"><span class="toc_mobile_items-text">1 - 字符编码和字符集</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字符编码"><span class="toc_mobile_items-text">字符编码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字符集"><span class="toc_mobile_items-text">字符集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#编码问题（乱码）"><span class="toc_mobile_items-text">编码问题（乱码）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-InputStreamReader类"><span class="toc_mobile_items-text">2 - InputStreamReader类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-构造方法"><span class="toc_mobile_items-text">2.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-使用步骤"><span class="toc_mobile_items-text">2.2 - 使用步骤</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#构造方法"><span class="toc_mobile_items-text">构造方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-OutputStreamWriter类"><span class="toc_mobile_items-text">3 - OutputStreamWriter类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-构造方法"><span class="toc_mobile_items-text">3.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-使用步骤"><span class="toc_mobile_items-text">3.2 - 使用步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-练习-：转换文件编码"><span class="toc_mobile_items-text">4 - 练习 ：转换文件编码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#序列化流"><span class="toc_mobile_items-text">序列化流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-概述"><span class="toc_mobile_items-text">1 - 概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-ObjectOutputStream类"><span class="toc_mobile_items-text">2 - ObjectOutputStream类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-构造方法-1"><span class="toc_mobile_items-text">2.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-特有的成员方法"><span class="toc_mobile_items-text">2.2 - 特有的成员方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-使用步骤"><span class="toc_mobile_items-text">2.3 - 使用步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-ObjectInputStream类"><span class="toc_mobile_items-text">3 - ObjectInputStream类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-构造方法-1"><span class="toc_mobile_items-text">3.1 - 构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-特有的成员方法"><span class="toc_mobile_items-text">3.2 - 特有的成员方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-3-使用步骤"><span class="toc_mobile_items-text">3.3 - 使用步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-练习：序列化集合"><span class="toc_mobile_items-text">4 - 练习：序列化集合</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#打印流"><span class="toc_mobile_items-text">打印流</span></a></li></ol></div></div><div id="body-wrap"><div id="web_bg"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#缓冲流"><span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-字节缓冲流"><span class="toc-text">1 - 字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-字节缓冲输出流"><span class="toc-text">1.1 - 字节缓冲输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-构造方法"><span class="toc-text">1.1.1 - 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-使用步骤-重点"><span class="toc-text">1.1.2 - 使用步骤(重点)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-字节缓冲输入流"><span class="toc-text">1.2 - 字节缓冲输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-构造方法"><span class="toc-text">1.2.1 - 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-使用步骤-重点"><span class="toc-text">1.2.2 - 使用步骤(重点)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-文件复制"><span class="toc-text">1.3 - 文件复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-字符缓冲流"><span class="toc-text">2 - 字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-字符缓冲输出流"><span class="toc-text">2.1 - 字符缓冲输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-构造方法"><span class="toc-text">2.1.1 - 构造方法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-特有的成员方法"><span class="toc-text">2.1.2 - 特有的成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-使用步骤"><span class="toc-text">2.1.3 -  使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-字符缓冲输入流"><span class="toc-text">2.2 - 字符缓冲输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-构造方法"><span class="toc-text">2.2.1 -  构造方法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-特有的成员方法"><span class="toc-text">2.2.2 - 特有的成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-使用步骤"><span class="toc-text">2.2.3 - 使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-练习：文本排序"><span class="toc-text">2.3 - 练习：文本排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-字符编码和字符集"><span class="toc-text">1 - 字符编码和字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符编码"><span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符集"><span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码问题（乱码）"><span class="toc-text">编码问题（乱码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-InputStreamReader类"><span class="toc-text">2 - InputStreamReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-构造方法"><span class="toc-text">2.1 - 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-使用步骤"><span class="toc-text">2.2 - 使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-OutputStreamWriter类"><span class="toc-text">3 - OutputStreamWriter类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-构造方法"><span class="toc-text">3.1 - 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-使用步骤"><span class="toc-text">3.2 - 使用步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-练习-：转换文件编码"><span class="toc-text">4 - 练习 ：转换文件编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化流"><span class="toc-text">序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概述"><span class="toc-text">1 - 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ObjectOutputStream类"><span class="toc-text">2 - ObjectOutputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-构造方法-1"><span class="toc-text">2.1 - 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-特有的成员方法"><span class="toc-text">2.2 - 特有的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-使用步骤"><span class="toc-text">2.3 - 使用步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ObjectInputStream类"><span class="toc-text">3 - ObjectInputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-构造方法-1"><span class="toc-text">3.1 - 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-特有的成员方法"><span class="toc-text">3.2 - 特有的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-使用步骤"><span class="toc-text">3.3 - 使用步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-练习：序列化集合"><span class="toc-text">4 - 练习：序列化集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#打印流"><span class="toc-text">打印流</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png)"><div id="post-info"><div id="post-title"><div class="posttitle">191017-JAVA-IO流(3)-其他流</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-17<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-17</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p>
<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/01_%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="lozad"></p>
<p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的<strong>缓冲区数组</strong>，通过缓冲区读写，<strong>减少系统IO次数</strong>，从而提高读写的效率。</p>
<h2 id="1-字节缓冲流"><a href="#1-字节缓冲流" class="headerlink" title="1 - 字节缓冲流"></a>1 - 字节缓冲流</h2><h3 id="1-1-字节缓冲输出流"><a href="#1-1-字节缓冲输出流" class="headerlink" title="1.1 - 字节缓冲输出流"></a>1.1 - 字节缓冲输出流</h3><p>java.io.BufferedOutputStream extends OutputStream<br>    BufferedOutputStream:字节缓冲输出流</p>
<pre><code>继承自父类的共性成员方法:
    - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
    - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
    - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
    - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
    - public abstract void write(int b) ：将指定的字节输出流。</code></pre><h4 id="1-1-1-构造方法"><a href="#1-1-1-构造方法" class="headerlink" title="1.1.1 - 构造方法"></a>1.1.1 - 构造方法</h4><ul>
<li>BufferedOutputStream(OutputStream out)  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。<br>BufferedOutputStream(OutputStream out, int size)  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</li>
<li>参数:<pre><code>OutputStream out:字节输出流
     我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率
int size:指定缓冲流内部缓冲区的大小,不指定默认</code></pre></li>
</ul>
<h4 id="1-1-2-使用步骤-重点"><a href="#1-1-2-使用步骤-重点" class="headerlink" title="1.1.2 - 使用步骤(重点)"></a>1.1.2 - 使用步骤(重点)</h4><p>​        1.创建FileOutputStream对象,构造方法中绑定要输出的目的地<br>​        2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率<br>​        3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中<br>​        4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中(不做此步骤，数据无法成功写入)<br>​        5.释放资源(会先调用flush方法刷新数据,第4部可以省略)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建FileOutputStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">//3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中</span></span><br><span class="line">        bos.write(<span class="string">"我把数据写入到内部缓冲区中"</span>.getBytes());</span><br><span class="line">        <span class="comment">//4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        bos.flush();</span><br><span class="line">        <span class="comment">//5.释放资源(会先调用flush方法刷新数据,第4部可以省略)</span></span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-字节缓冲输入流"><a href="#1-2-字节缓冲输入流" class="headerlink" title="1.2 - 字节缓冲输入流"></a>1.2 - 字节缓冲输入流</h3><p>java.io.BufferedInputStream extends InputStream<br>    BufferedInputStream:字节缓冲输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承自父类的成员方法:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>从输入流中读取数据的下一个字节。</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此输入流并释放与该流关联的所有系统资源。</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-1-构造方法"><a href="#1-2-1-构造方法" class="headerlink" title="1.2.1 - 构造方法"></a>1.2.1 - 构造方法</h4><p>​    BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。<br>​    BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。<br>​    参数:<br>​        InputStream in:字节输入流<br>​            我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率<br>​        int size:指定缓冲流内部缓冲区的大小,不指定默认</p>
<h4 id="1-2-2-使用步骤-重点"><a href="#1-2-2-使用步骤-重点" class="headerlink" title="1.2.2 - 使用步骤(重点)"></a>1.2.2 - 使用步骤(重点)</h4><p>​    1.创建FileInputStream对象,构造方法中绑定要读取的数据源<br>​    2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率<br>​    3.使用BufferedInputStream对象中的方法read,读取文件<br>​    4.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建FileInputStream对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="comment">//3.使用BufferedInputStream对象中的方法read,读取文件</span></span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//int read()从输入流中读取数据的下一个字节。</span></span><br><span class="line">        <span class="comment">/*int len = 0;//记录每次读取到的字节</span></span><br><span class="line"><span class="comment">        while((len = bis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//存储每次读取的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//记录每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-文件复制"><a href="#1-3-文件复制" class="headerlink" title="1.3 - 文件复制"></a>1.3 - 文件复制</h3><p>与之前的IO流一样的步骤，这次加入下效率测试，从结果可见，缓存流的读写速度比普通IO流快很多。</p>
<p><strong>普通IO流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件复制练习:一读一写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源: c:\\1.jpg</span></span><br><span class="line"><span class="comment">        数据的目的地: d:\\1.jpg</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件复制的步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line"><span class="comment">        2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line"><span class="comment">        3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line"><span class="comment">        4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line"><span class="comment">        5.释放资源</span></span><br><span class="line"><span class="comment">    文件的大小:780,831 字节</span></span><br><span class="line"><span class="comment">    一次读写一个字节:6043毫秒</span></span><br><span class="line"><span class="comment">    使用数组缓冲读取多个字节,写入多个字节:10毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line"><span class="comment">            fos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓存流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件复制练习:一读一写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源: c:\\1.jpg</span></span><br><span class="line"><span class="comment">        数据的目的地: d:\\1.jpg</span></span><br><span class="line"><span class="comment">    文件复制的步骤:</span></span><br><span class="line"><span class="comment">        1.创建字节缓冲输入流对象,构造方法中传递字节输入流</span></span><br><span class="line"><span class="comment">        2.创建字节缓冲输出流对象,构造方法中传递字节输出流</span></span><br><span class="line"><span class="comment">        3.使用字节缓冲输入流对象中的方法read,读取文件</span></span><br><span class="line"><span class="comment">        4.使用字节缓冲输出流中的方法write,把读取的数据写入到内部缓冲区中</span></span><br><span class="line"><span class="comment">        5.释放资源(会先把缓冲区中的数据,刷新到文件中)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件的大小:780,831 字节</span></span><br><span class="line"><span class="comment">    一次读写一个字节:32毫秒</span></span><br><span class="line"><span class="comment">    使用数组缓冲读取多个字节,写入多个字节:5毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建字节缓冲输入流对象,构造方法中传递字节输入流</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//2.创建字节缓冲输出流对象,构造方法中传递字节输出流</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//3.使用字节缓冲输入流对象中的方法read,读取文件</span></span><br><span class="line">        <span class="comment">//一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = bis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            bos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符缓冲流"><a href="#2-字符缓冲流" class="headerlink" title="2 - 字符缓冲流"></a>2 - 字符缓冲流</h2><h3 id="2-1-字符缓冲输出流"><a href="#2-1-字符缓冲输出流" class="headerlink" title="2.1 - 字符缓冲输出流"></a>2.1 - 字符缓冲输出流</h3><p>java.io.BufferedWriter extends Writer<br>    BufferedWriter:字符缓冲输出流</p>
<p>继承自父类的共性成员方法:<br>    - void write(int c) 写入单个字符。<br>    - void write(char[] cbuf)写入字符数组。<br>    - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>    - void write(String str)写入字符串。<br>    - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>    - void flush()刷新该流的缓冲。<br>    - void close() 关闭此流，但要先刷新它。</p>
<h4 id="2-1-1-构造方法"><a href="#2-1-1-构造方法" class="headerlink" title="2.1.1 - 构造方法:"></a>2.1.1 - 构造方法:</h4><p>​    BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。<br>​    BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。<br>​    参数:<br>​        Writer out:字符输出流<br>​            我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率<br>​        int sz:指定缓冲区的大小,不写默认大小</p>
<h4 id="2-1-2-特有的成员方法"><a href="#2-1-2-特有的成员方法" class="headerlink" title="2.1.2 - 特有的成员方法"></a>2.1.2 - 特有的成员方法</h4><p>​    void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符<br>​    换行:换行符号<br>​    windows:\r\n<br>​    linux:/n<br>​    mac:/r</p>
<h4 id="2-1-3-使用步骤"><a href="#2-1-3-使用步骤" class="headerlink" title="2.1.3 -  使用步骤"></a>2.1.3 -  使用步骤</h4><p>​    1.创建字符缓冲输出流对象,构造方法中传递字符输出流<br>​    2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中<br>​    3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中<br>​    4.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">        <span class="comment">//1.创建字符缓冲输出流对象,构造方法中传递字符输出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"10_IO\\c.txt"</span>));</span><br><span class="line">        <span class="comment">//2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">"传智播客"</span>);</span><br><span class="line">            <span class="comment">//bw.write("\r\n");</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        bw.flush();</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-字符缓冲输入流"><a href="#2-2-字符缓冲输入流" class="headerlink" title="2.2 - 字符缓冲输入流"></a>2.2 - 字符缓冲输入流</h3><p>java.io.BufferedReader extends Reader<br>    BufferedReader:字符缓冲输入流</p>
<p>继承自父类的共性成员方法:<br>    int read() 读取单个字符并返回。<br>    int read(char[] cbuf)一次读取多个字符,将字符读入数组。<br>    void close() 关闭该流并释放与之关联的所有资源。</p>
<h4 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1 -  构造方法:"></a>2.2.1 -  构造方法:</h4><p>​    BufferedReader(Reader in)  创建一个使用默认大小输入缓冲区的缓冲字符输入流。<br>​    BufferedReader(Reader in, int sz)     创建一个使用指定大小输入缓冲区的缓冲字符输入流。<br>​    参数:<br>​        Reader in:字符输入流<br>​            我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率</p>
<h4 id="2-2-2-特有的成员方法"><a href="#2-2-2-特有的成员方法" class="headerlink" title="2.2.2 - 特有的成员方法"></a>2.2.2 - 特有的成员方法</h4><p>​    String readLine() 读取一个文本行。读取一行数据<br>​        行的终止符号:通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行(\r\n)。<br>​    返回值:<br>​        包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p>
<h4 id="2-2-3-使用步骤"><a href="#2-2-3-使用步骤" class="headerlink" title="2.2.3 - 使用步骤"></a>2.2.3 - 使用步骤</h4><p>​    1.创建字符缓冲输入流对象,构造方法中传递字符输入流<br>​    2.使用字符缓冲输入流对象中的方法read/readLine读取文本<br>​    3.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流对象,构造方法中传递字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"10_IO\\c.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用字符缓冲输入流对象中的方法read/readLine读取文本</span></span><br><span class="line">        <span class="comment">/*String line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        line = br.readLine();</span></span><br><span class="line"><span class="comment">        System.out.println(line);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            发下以上读取是一个重复的过程,所以可以使用循环优化</span></span><br><span class="line"><span class="comment">            不知道文件中有多少行数据,所以使用while循环</span></span><br><span class="line"><span class="comment">            while的结束条件,读取到null结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-练习：文本排序"><a href="#2-3-练习：文本排序" class="headerlink" title="2.3 - 练习：文本排序"></a>2.3 - 练习：文本排序</h3><p>练习:</p>
<p>​        将in.txt的文本内容排序后写入到out.txt</p>
<p>​        对文本的内容进行排序<br>​        按照(1,2,3….)顺序排序<br>​    分析:<br>​        1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本<br>​        2.创建字符缓冲输入流对象,构造方法中绑定字符输入流<br>​        3.创建字符缓冲输出流对象,构造方法中绑定字符输出流<br>​        4.使用字符缓冲输入流中的方法readline,逐行读取文本<br>​        5.对读取到的文本进行切割,获取行中的序号和文本内容<br>​        6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)<br>​        7.遍历HashMap集合,获取每一个键值对<br>​        8.把每一个键值对,拼接为一个文本行<br>​        9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中<br>​        10.释放资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建字符缓冲输入流对象,构造方法中绑定字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"10_IO\\in.txt"</span>));</span><br><span class="line">        <span class="comment">//3.创建字符缓冲输出流对象,构造方法中绑定字符输出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"10_IO\\out.txt"</span>));</span><br><span class="line">        <span class="comment">//4.使用字符缓冲输入流中的方法readline,逐行读取文本</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//5.对读取到的文本进行切割,获取行中的序号和文本内容</span></span><br><span class="line">            String[] arr = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">//6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)</span></span><br><span class="line">            map.put(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历HashMap集合,获取每一个键值对</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            <span class="comment">//8.把每一个键值对,拼接为一个文本行</span></span><br><span class="line">            line = key + <span class="string">"."</span> + value;</span><br><span class="line">            <span class="comment">//9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中</span></span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();<span class="comment">//写换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//10.释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>#转换流</p>
<h2 id="1-字符编码和字符集"><a href="#1-字符编码和字符集" class="headerlink" title="1 - 字符编码和字符集"></a>1 - 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img alt data-src="img/1_charset.jpg" class="lozad"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/1_charset.jpg" class="lozad"></p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码问题（乱码）"><a href="#编码问题（乱码）" class="headerlink" title="编码问题（乱码）"></a>编码问题（乱码）</h3><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    FileReader可以读取IDE默认编码格式(UTF-8)的文件</span></span><br><span class="line"><span class="comment">    FileReader读取系统默认编码(中文GBK)会产生乱码���</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"10_IO\\我是GBK格式的文本.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？</p>
<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/02_%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="lozad"></p>
<h2 id="2-InputStreamReader类"><a href="#2-InputStreamReader类" class="headerlink" title="2 - InputStreamReader类"></a>2 - InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p>java.io.InputStreamReader extends Reader<br>    InputStreamReader:是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码:把看不懂的变成能看懂的)</p>
<p>继承自父类的共性成员方法:<br>    int read() 读取单个字符并返回。<br>    int read(char[] cbuf)一次读取多个字符,将字符读入数组。<br>    void close() 关闭该流并释放与之关联的所有资源。</p>
<h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 - 构造方法"></a>2.1 - 构造方法</h3><p>​    InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。<br>​    InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。<br>​    参数:<br>​        InputStream in:字节输入流,用来读取文件中保存的字节<br>​        String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8</p>
<h3 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 - 使用步骤"></a>2.2 - 使用步骤</h3><p>​    1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称<br>​    2.使用InputStreamReader对象中的方法read读取文件<br>​    3.释放资源<br> <strong>注意事项:</strong>    构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用InputStreamReader读取GBK格式的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\gbk.txt"),"UTF-8");//???</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\gbk.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//你好</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用InputStreamReader读取UTF-8格式的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\utf_8.txt"),"UTF-8");</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\utf_8.txt"</span>));<span class="comment">//不指定默认使用UTF-8</span></span><br><span class="line">        <span class="comment">//2.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<h2 id="3-OutputStreamWriter类"><a href="#3-OutputStreamWriter类" class="headerlink" title="3 - OutputStreamWriter类"></a>3 - OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p>java.io.OutputStreamWriter extends Writer<br>    OutputStreamWriter: 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码:把能看懂的变成看不懂)</p>
<p>继续自父类的共性成员方法:<br>    - void write(int c) 写入单个字符。<br>    - void write(char[] cbuf)写入字符数组。<br>    - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>    - void write(String str)写入字符串。<br>    - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>    - void flush()刷新该流的缓冲。</p>
<ul>
<li>void close() 关闭此流，但要先刷新它。</li>
</ul>
<h3 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 - 构造方法"></a>3.1 - 构造方法</h3><p>​    OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。<br>​    OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。<br>​    参数:<br>          OutputStream out:字节输出流,可以用来写转换之后的字节到文件中<br>          String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8</p>
<h3 id="3-2-使用步骤"><a href="#3-2-使用步骤" class="headerlink" title="3.2 - 使用步骤"></a>3.2 - 使用步骤</h3><p>​    1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称<br>​    2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)<br>​    3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)<br>​    4.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用转换流OutputStreamWriter写GBK格式的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span></span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\gbk.txt"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="comment">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用转换流OutputStreamWriter写UTF-8格式的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span></span><br><span class="line">    <span class="comment">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\utf_8.txt"),"utf-8");</span></span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\utf_8.txt"</span>));<span class="comment">//不指定默认使用UTF-8</span></span><br><span class="line">    <span class="comment">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="comment">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-练习-：转换文件编码"><a href="#4-练习-：转换文件编码" class="headerlink" title="4 - 练习 ：转换文件编码"></a>4 - 练习 ：转换文件编码</h2><p> 练习：转换文件编码<br>        将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<pre><code>分析:
    1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK
    2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8
    3.使用InputStreamReader对象中的方法read读取文件
    4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中
    5.释放资源    </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\我是GBK格式的文本.txt"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">//2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\我是utf_8格式的文件.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">//3.使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中</span></span><br><span class="line">            osw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 - 概述"></a>1 - 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：</p>
<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/3_xuliehua.jpg" class="lozad"></p>
<p><img alt data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/03_%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%A6%82%E8%BF%B0.bmp" class="lozad"></p>
<h2 id="2-ObjectOutputStream类"><a href="#2-ObjectOutputStream类" class="headerlink" title="2 - ObjectOutputStream类"></a>2 - ObjectOutputStream类</h2><p>java.io.ObjectOutputStream extends OutputStream<br>    ObjectOutputStream:对象的序列化流<br>    作用:把对象以流的方式写入到文件中保存</p>
<h3 id="2-1-构造方法-1"><a href="#2-1-构造方法-1" class="headerlink" title="2.1 - 构造方法"></a>2.1 - 构造方法</h3><p>​    ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。<br>​    参数:<br>​        OutputStream out:字节输出流</p>
<h3 id="2-2-特有的成员方法"><a href="#2-2-特有的成员方法" class="headerlink" title="2.2 - 特有的成员方法"></a>2.2 - 特有的成员方法</h3><p>​    void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。</p>
<h3 id="2-3-使用步骤"><a href="#2-3-使用步骤" class="headerlink" title="2.3 - 使用步骤"></a>2.3 - 使用步骤</h3><p>​    1.创建ObjectOutputStream对象,构造方法中传递字节输出流<br>​    2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中<br>​    3.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04.ObjectStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常</span></span><br><span class="line"><span class="comment">    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。</span></span><br><span class="line"><span class="comment">    Serializable接口也叫标记型接口</span></span><br><span class="line"><span class="comment">        要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记</span></span><br><span class="line"><span class="comment">        当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记</span></span><br><span class="line"><span class="comment">            有:就可以序列化和反序列化</span></span><br><span class="line"><span class="comment">            没有:就会抛出 NotSerializableException异常</span></span><br><span class="line"><span class="comment">    去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    static关键字:静态关键字</span></span><br><span class="line"><span class="comment">        静态优先于非静态加载到内存中(静态优先于对象进入到内存中)</span></span><br><span class="line"><span class="comment">        被static修饰的成员变量不能被序列化的,序列化的都是对象</span></span><br><span class="line"><span class="comment">        private static int age;</span></span><br><span class="line"><span class="comment">        oos.writeObject(new Person("小美女",18));</span></span><br><span class="line"><span class="comment">        Object o = ois.readObject();</span></span><br><span class="line"><span class="comment">        Person&#123;name='小美女', age=0&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    transient关键字:瞬态关键字</span></span><br><span class="line"><span class="comment">        被transient修饰成员变量,不能被序列化</span></span><br><span class="line"><span class="comment">        private transient int age;</span></span><br><span class="line"><span class="comment">        oos.writeObject(new Person("小美女",18));</span></span><br><span class="line"><span class="comment">        Object o = ois.readObject();</span></span><br><span class="line"><span class="comment">        Person&#123;name='小美女', age=0&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//private static int age;</span></span><br><span class="line">    <span class="comment">//private transient int age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1.创建ObjectOutputStream对象,构造方法中传递字节输出流</span></span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\person.txt"</span>));</span><br><span class="line">       <span class="comment">//2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中</span></span><br><span class="line">       oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"小美女"</span>,<span class="number">18</span>));</span><br><span class="line">       <span class="comment">//3.释放资源</span></span><br><span class="line">       oos.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-ObjectInputStream类"><a href="#3-ObjectInputStream类" class="headerlink" title="3 - ObjectInputStream类"></a>3 - ObjectInputStream类</h2><p>java.io.ObjectInputStream extends InputStream<br>ObjectInputStream:对象的反序列化流<br>作用:把文件中保存的对象,以流的方式读取出来使用</p>
<h3 id="3-1-构造方法-1"><a href="#3-1-构造方法-1" class="headerlink" title="3.1 - 构造方法"></a>3.1 - 构造方法</h3><p>​    ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。<br>​    参数:<br>​        InputStream in:字节输入流</p>
<h3 id="3-2-特有的成员方法"><a href="#3-2-特有的成员方法" class="headerlink" title="3.2 - 特有的成员方法"></a>3.2 - 特有的成员方法</h3><p>​    Object readObject() 从 ObjectInputStream 读取对象。</p>
<h3 id="3-3-使用步骤"><a href="#3-3-使用步骤" class="headerlink" title="3.3 - 使用步骤"></a>3.3 - 使用步骤</h3><p>​    1.创建ObjectInputStream对象,构造方法中传递字节输入流<br>​    2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件<br>​    3.释放资源<br>​    4.使用读取出来的对象(打印)</p>
<p> readObject方法声明抛出了ClassNotFoundException(class文件找不到异常)<br> 当不存在对象的class文件时抛出此异常<br> 反序列化的前提:<br>    1.类必须实现Serializable<br>    2.必须存在类对应的class文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ObjectInputStream对象,构造方法中传递字节输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\person.txt"</span>));</span><br><span class="line">        <span class="comment">//2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="comment">//4.使用读取出来的对象(打印)</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        Person p = (Person)o;</span><br><span class="line">        System.out.println(p.getName()+p.getAge());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-练习：序列化集合"><a href="#4-练习：序列化集合" class="headerlink" title="4 - 练习：序列化集合"></a>4 - 练习：序列化集合</h2><pre><code>    当我们想在文件中保存多个对象的时候
    可以把多个对象存储到一个集合中
    对集合进序列化和反序列化
分析:
    1.定义一个存储Person对象的ArrayList集合
    2.往ArrayList集合中存储Person对象
    3.创建一个序列化流ObjectOutputStream对象
    4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化
    5.创建一个反序列化ObjectInputStream对象
    6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
    7.把Object类型的集合转换为ArrayList类型
    8.遍历ArrayList集合
    9.释放资源</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义一个存储Person对象的ArrayList集合</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.往ArrayList集合中存储Person对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="comment">//3.创建一个序列化流ObjectOutputStream对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"10_IO\\list.txt"</span>));</span><br><span class="line">        <span class="comment">//4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//5.创建一个反序列化ObjectInputStream对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10_IO\\list.txt"</span>));</span><br><span class="line">        <span class="comment">//6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//7.把Object类型的集合转换为ArrayList类型</span></span><br><span class="line">        ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o;</span><br><span class="line">        <span class="comment">//8.遍历ArrayList集合</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : list2) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p>java.io.PrintStream:打印流<br>        PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。<br>    PrintStream特点:<br>        1.只负责数据的输出,不负责数据的读取<br>        2.与其他输出流不同，PrintStream 永远不会抛出 IOException<br>        3.有特有的方法,print,println<br>            void print(任意类型的值)<br>            void println(任意类型的值并换行)<br>    ## 1 - 构造方法:</p>
<p>​        PrintStream(File file):输出的目的地是一个文件<br>​        PrintStream(OutputStream out):输出的目的地是一个字节输出流<br>​        PrintStream(String fileName) :输出的目的地是一个文件路径<br>​    PrintStream extends OutputStream<br>​    继承自父类的成员方法:</p>
<pre><code>- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
- public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
- public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
- public abstract void write(int b) ：将指定的字节输出流。
注意:
​        如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a
​        如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">//System.out.println("HelloWorld");</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建打印流PrintStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">       PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"10_IO\\print.txt"</span>);</span><br><span class="line">       <span class="comment">//如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a</span></span><br><span class="line">       ps.write(<span class="number">97</span>);</span><br><span class="line">       <span class="comment">//如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</span></span><br><span class="line">       ps.println(<span class="number">97</span>);</span><br><span class="line">       ps.println(<span class="number">8.8</span>);</span><br><span class="line">       ps.println(<span class="string">'a'</span>);</span><br><span class="line">       ps.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">       ps.println(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//释放资源</span></span><br><span class="line">       ps.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以改变输出语句的目的地(打印流的流向)<br>    输出语句,默认在控制台输出<br>    使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地<br>        static void setOut(PrintStream out)<br>          重新分配“标准”输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"我是在控制台输出"</span>);</span><br><span class="line"></span><br><span class="line">       PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"10_IO\\目的地是打印流.txt"</span>);</span><br><span class="line">       System.setOut(ps);<span class="comment">//把输出语句的目的地改变为打印流的目的地</span></span><br><span class="line">       System.out.println(<span class="string">"我在打印流的目的地中输出"</span>);</span><br><span class="line"></span><br><span class="line">       ps.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杨涵</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/">https://cometorbityh.github.io/2019/11/17/191017-JAVA-IO流-3-其他流/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cometorbityh.github.io">MY</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a><a class="post-meta__tags" href="/tags/IO/">IO    </a></div><div class="post_share"><div class="social-share" data-image="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/18/CET6-CORE-1/"><img class="prev_cover lozad" data-src="undefined" onerror="onerror=null;src='/img/comment_bg.png'"><div class="label">上一篇</div><div class="prev_info"><span>CET6 CORE (1)</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/16/191016-JAVA-IO流-2-IO流/"><img class="next_cover lozad" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png" onerror="onerror=null;src='/img/comment_bg.png'"><div class="label">下一篇</div><div class="next_info"><span>191016_JAVA_IO流(2)_IO流</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/16/191016-JAVA-IO流-2-IO流/" title="191016_JAVA_IO流(2)_IO流"><img class="relatedPosts_cover lozad" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png"><div class="relatedPosts_title">191016_JAVA_IO流(2)_IO流</div></a></div><div class="relatedPosts_item"><a href="/2019/11/13/191013_JAVA_IO流(1)_File类/" title="191013_JAVA_IO流(1)_File类"><img class="relatedPosts_cover lozad" data-src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/img/20191117170933.png"><div class="relatedPosts_title">191013_JAVA_IO流(1)_File类</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2019 By 杨涵</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>